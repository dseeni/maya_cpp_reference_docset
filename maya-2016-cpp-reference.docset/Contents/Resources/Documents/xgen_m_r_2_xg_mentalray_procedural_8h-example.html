<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="MAYAUL" name="product"><meta content="2016" name="release"><meta content="Developer" name="book"><meta content="2015-10-14" name="created"><meta content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887" name="topicid"><meta content="concept" name="topic-type">
<title>xgenMR/XgMentalrayProcedural.h</title>
<meta content="C++" name="topic-subtype"/></meta></meta></meta></meta></meta></meta></meta></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('xgen_m_r_2_xg_mentalray_procedural_8h-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?siteData=y5CYlxTRD0znCzRLDwX0Wy7-g1EdC1XA4dSC-Y1LtaeScyli8_Ps5jPKqTr4xKxMI0OOUfkDplvX3uxN0JnPclebSYW8_J1HBzf4VLQEzQ8M4PsYXF_cMyp1Oumaetky&category=5297189e-446b-459e-ae1d-9d0360400781_tech&ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="position:absolute;right:20px;top:5px;z-index:100;color:white;background-color:#555555;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>xgenMR/XgMentalrayProcedural.h</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">xgenMR/XgMentalrayProcedural.h</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef __XGENMENTALRAYPROCEDURAL_H__</span></div>
<div class="line"><span class="preprocessor">#define __XGENMENTALRAYPROCEDURAL_H__</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;shader.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;XGen/XgRenderAPI.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>XGenRenderAPI;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> miTag miString;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>XGenMR</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">class </span>ProceduralWrapper;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>miMatrixClass</div>
<div class="line">    {</div>
<div class="line">        miMatrix m;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>miMatrixStruct</div>
<div class="line">    {</div>
<div class="line">        miMatrixStruct( <span class="keyword">const</span> miMatrix m )</div>
<div class="line">        {</div>
<div class="line">            mi_matrix_copy( m_matrix, m );</div>
<div class="line">        }</div>
<div class="line">        miMatrixStruct( <span class="keyword">const</span> miMatrixStruct&amp; m )</div>
<div class="line">        {</div>
<div class="line">            *<span class="keyword">this</span> = m;</div>
<div class="line">        }</div>
<div class="line">        miMatrixStruct&amp; operator=( <span class="keyword">const</span> miMatrixStruct&amp; m )</div>
<div class="line">        {</div>
<div class="line">            mi_matrix_copy( m_matrix, m.m_matrix );</div>
<div class="line"> <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*miMatrix&amp; operator()</span></div>
<div class="line"><span class="comment">        {</span></div>
<div class="line"><span class="comment">            return m_matrix;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        const miMatrix&amp; operator() const</span></div>
<div class="line"><span class="comment">        {</span></div>
<div class="line"><span class="comment">            return m_matrix;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">        miMatrix m_matrix;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Registration user data class used for pushing the data on the hair scalars</span></div>
<div class="line"> <span class="comment">// This stores if the data needs to be pushed, and a buffer pointer to it.</span></div>
<div class="line"> <span class="keyword">template</span>&lt; <span class="keyword">class </span>T<span class="comment">/*user data type*/</span>, <span class="keyword">class </span>E<span class="comment">/*enum for the primitive cache*/</span>, <span class="keywordtype">int</span> N<span class="comment">/*Number of components.*/</span> &gt;</div>
<div class="line"> <span class="keyword">class </span>TUserData</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">        TUserData( PrimitiveCache* pc, PrimitiveCache::EBoolAttribute bAdd, E eArray, <span class="keywordtype">int</span> context, <span class="keyword">const</span> <span class="keywordtype">char</span>* name );</div>
<div class="line"></div>
<div class="line">        TUserData( <span class="keyword">const</span> T* p, <span class="keywordtype">int</span> context, <span class="keyword">const</span> <span class="keywordtype">char</span>* name );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">inline</span> T <span class="keyword">get</span>(<span class="keywordtype">size_t</span> j) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">void</span> registerUserData( <span class="keywordtype">size_t</span>&amp; io_perPrim, <span class="keywordtype">size_t</span>&amp; io_perPoint, XGenMR::UserDataFormat&amp; fmt, <span class="keywordtype">size_t</span>&amp; k, <span class="keywordtype">int</span>* interpolateComponent );</div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">void</span> registerUserData( <span class="keywordtype">size_t</span>&amp; io_perPrim, <span class="keywordtype">size_t</span>&amp; io_perPoint, XGenMR::UserDataFormat&amp; fmt );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">void</span> copy( <span class="keywordtype">size_t</span> j, <span class="keywordtype">float</span>* cur, <span class="keywordtype">size_t</span>&amp; k, <span class="keywordtype">int</span> context );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isValid( <span class="keywordtype">int</span> context );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line"> <span class="keywordtype">int</span>         m_context;</div>
<div class="line"> <span class="keywordtype">bool</span>        m_add;</div>
<div class="line"> <span class="keyword">const</span> T*    m_p;</div>
<div class="line">        std::string m_name;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> TUserData&lt;int,PrimitiveCache::EIntArrayAttribute,1&gt; TIntUserData;</div>
<div class="line"> <span class="keyword">typedef</span> TUserData&lt;float,PrimitiveCache::EFloatArrayAttribute,1&gt; TFloatUserData;</div>
<div class="line"> <span class="keyword">typedef</span> TUserData&lt;vec3,PrimitiveCache::EVec3ArrayAttribute,3&gt; TVec3UserData;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt; TIntUserData &gt;     TIntUserDataList;</div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt; TFloatUserData &gt;   TFloatUserDataList;</div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt; TVec3UserData &gt;    TVec3UserDataList;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Holds the 3 user data type lists + some helper functions.</span></div>
<div class="line"> <span class="keyword">class </span>UserDataList</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"> <span class="comment">// Iterate over all the user data vectors</span></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">void</span> pushUserData( <span class="keywordtype">size_t</span> j, <span class="keywordtype">float</span>* cur, <span class="keywordtype">size_t</span>&amp; k, <span class="keywordtype">int</span> context );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// List all the optional built in user data</span></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">void</span> listUserData( PrimitiveCache* pc, <span class="keywordtype">bool</span> isSpline );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Register Hair Optional User Data</span></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">void</span> registerUserData( <span class="keywordtype">size_t</span>&amp; io_perPrim, <span class="keywordtype">size_t</span>&amp; io_perPoint, XGenMR::UserDataFormat&amp; fmt, <span class="keywordtype">size_t</span>&amp; k, <span class="keywordtype">int</span>* interpolateComponent );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Register Hair Optional User Data</span></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">void</span> registerUserData( <span class="keywordtype">size_t</span>&amp; io_perPrim, <span class="keywordtype">size_t</span>&amp; io_perPoint, XGenMR::UserDataFormat&amp; fmt );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        TIntUserDataList vecInt;</div>
<div class="line">        TFloatUserDataList vecFloat;</div>
<div class="line">        TVec3UserDataList vecVec3;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> </div>
<div class="line"> <span class="keyword">class </span>UserDataList; <span class="comment">// forward declaration</span></div>
<div class="line"> <span class="keyword">class </span>Procedural; <span class="comment">// forward declaration</span></div>
<div class="line"></div>
<div class="line"> <span class="keyword">class </span>BaseProcedural : <span class="keyword">public</span> ProceduralCallbacks</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">        BaseProcedural( <span class="keyword">const</span> BaseProcedural* parentProc );</div>
<div class="line"> <span class="keyword">virtual</span> ~BaseProcedural();</div>
<div class="line"></div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <span class="keyword">get</span>( EBoolAttribute ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">get</span>( EStringAttribute ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">float</span> <span class="keyword">get</span>( EFloatAttribute ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">get</span>( EFloatArrayAttribute ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getSize( EFloatArrayAttribute ) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* getOverride( <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">bool</span> getArchiveBoundingBox( <span class="keyword">const</span> <span class="keywordtype">char</span>* in_filename, bbox&amp; out_bbox ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> getTransform( <span class="keywordtype">float</span> in_time, mat44&amp; out_mat ) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        BaseProcedural( );</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> convertMatrix( <span class="keyword">const</span> miMatrix in_mat, mat44&amp; out_mat );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">protected</span>:</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We'll put all the attributes from user/options/camera in a param map.</span></div>
<div class="line"> <span class="comment">// The Parameters maps are initialized a single time in init().</span></div>
<div class="line"> <span class="keyword">class </span>Param</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">            ~Param()</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span>( isString() )</div>
<div class="line">                {</div>
<div class="line">                    std::string* p = (std::string*)m_p;</div>
<div class="line"> <span class="keyword">delete</span> p;</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( isFloat() )</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordtype">float</span>* p = (<span class="keywordtype">float</span>*)m_p;</div>
<div class="line"> <span class="keyword">delete</span> p;</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( isFloatArray() )</div>
<div class="line">                {</div>
<div class="line">                    std::vector&lt;float&gt;* p = (std::vector&lt;float&gt;*)m_p;</div>
<div class="line"> <span class="keyword">delete</span> p;</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( isMatrixArray() )</div>
<div class="line">                {</div>
<div class="line">                    std::vector&lt;miMatrixStruct&gt;* p = (std::vector&lt;miMatrixStruct&gt;*)m_p;</div>
<div class="line"> <span class="keyword">delete</span> p;</div>
<div class="line">                }</div>
<div class="line">                m_p = NULL;</div>
<div class="line">            }</div>
<div class="line">            Param( <span class="keyword">const</span> std::string&amp; in_str )</div>
<div class="line">            {</div>
<div class="line">                m_t = eString;</div>
<div class="line">                std::string* s = <span class="keyword">new</span> std::string;</div>
<div class="line">                *s = in_str;</div>
<div class="line">                m_p = (<span class="keywordtype">void</span>*)s;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordtype">bool</span> isString() { <span class="keywordflow">return</span> m_t==eString; }</div>
<div class="line">            std::string* asString()</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">return</span> m_t==eString ? (std::string*)m_p : NULL;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            Param( <span class="keywordtype">float</span> in_f )</div>
<div class="line">            {</div>
<div class="line">                m_t = eFloat;</div>
<div class="line"> <span class="keywordtype">float</span>* f = <span class="keyword">new</span> float;</div>
<div class="line">                *f = in_f;</div>
<div class="line">                m_p = (<span class="keywordtype">void</span>*)f;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordtype">bool</span> isFloat() { <span class="keywordflow">return</span> m_t==eFloat; }</div>
<div class="line"> <span class="keywordtype">float</span>* asFloat()</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">return</span> m_t==eFloat ? (<span class="keywordtype">float</span>*)m_p : NULL;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            Param( <span class="keyword">const</span> std::vector&lt;float&gt;&amp; in_f )</div>
<div class="line">            {</div>
<div class="line">                m_t = eFloatArray;</div>
<div class="line">                std::vector&lt;float&gt;* f = <span class="keyword">new</span> std::vector&lt;float&gt;;</div>
<div class="line">                *f = in_f;</div>
<div class="line">                m_p = (<span class="keywordtype">void</span>*)f;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordtype">bool</span> isFloatArray() { <span class="keywordflow">return</span> m_t==eFloatArray; }</div>
<div class="line">            std::vector&lt;float&gt;* asFloatArray()</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">return</span> m_t==eFloatArray ? (std::vector&lt;float&gt;*)m_p : NULL;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            Param( <span class="keyword">const</span> std::vector&lt;miMatrixStruct&gt;&amp; in_m )</div>
<div class="line">            {</div>
<div class="line">                m_t = eMatrixArray;</div>
<div class="line">                std::vector&lt;miMatrixStruct&gt;* m = <span class="keyword">new</span> std::vector&lt;miMatrixStruct&gt;;</div>
<div class="line">                *m = in_m;</div>
<div class="line">                m_p = (<span class="keywordtype">void</span>*)m;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordtype">bool</span> isMatrixArray() { <span class="keywordflow">return</span> m_t==eMatrixArray; }</div>
<div class="line">            std::vector&lt;miMatrixStruct&gt;* asMatrixArray()</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">return</span> m_t==eMatrixArray ? (std::vector&lt;miMatrixStruct&gt;*)m_p : NULL;</div>
<div class="line">            }</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">enum</span> ParamType</div>
<div class="line">            {</div>
<div class="line">                eString, eFloat, eFloatArray, eMatrixArray</div>
<div class="line">            };</div>
<div class="line">            ParamType m_t;</div>
<div class="line"> <span class="keywordtype">void</span>* m_p;</div>
<div class="line">        };</div>
<div class="line"> <span class="keyword">typedef</span> std::map&lt;std::string,Param*&gt; ParamMap;</div>
<div class="line">        ParamMap m_user, m_overrides;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> getString( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keyword">const</span> <span class="keywordtype">char</span>*&amp; out_value, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span> ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> getFloat( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keywordtype">float</span>&amp; out_value, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span>  ) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getArraySize( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keywordtype">int</span> in_eType, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span>  ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> getFloatArray( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keyword">const</span> <span class="keywordtype">float</span>*&amp; out_value, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span>  ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> getMatrixArray( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keyword">const</span> miMatrix*&amp; out_value, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span>  ) <span class="keyword">const</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// A face renderer is created by enumerating the Faces on the PatchRenderer.</span></div>
<div class="line"> <span class="comment">// It will take a snapshot of the state of the PatchRenderer.</span></div>
<div class="line"> <span class="comment">// It will also inherit the xgen args and ProceduralCallbacks from the patch.</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">class </span>CountHairDataProcedural : <span class="keyword">public</span> BaseProcedural</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">        CountHairDataProcedural( <span class="keyword">const</span> Procedural&amp; parentProc );</div>
<div class="line"> <span class="keyword">virtual</span> ~CountHairDataProcedural() {}</div>
<div class="line"> <span class="keywordtype">void</span> reset() {</div>
<div class="line">            m_numPrims = 0;</div>
<div class="line">            m_numPoints = 0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// static function for initialization</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">bool</span> initFaceRenderer(CountHairDataProcedural* dProc, </div>
<div class="line">            PatchRenderer* patch, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// XGenRenderAPI::ProceduralCallbacks</span></div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> flush(  <span class="keyword">const</span> <span class="keywordtype">char</span>* in_geom, PrimitiveCache* in_cache );</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> log( <span class="keyword">const</span> <span class="keywordtype">char</span>* in_str ){}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> render() { m_face-&gt;render();}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getNumPrims()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_numPrims;}</div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getNumPoints()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_numPoints;}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        CountHairDataProcedural();</div>
<div class="line">        CountHairDataProcedural( <span class="keyword">const</span> CountHairDataProcedural&amp; );</div>
<div class="line"></div>
<div class="line">        std::auto_ptr&lt;FaceRenderer&gt; m_face;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// approximation settings</span></div>
<div class="line">        miInteger m_approx_degree;</div>
<div class="line">        miInteger m_approx_mode;</div>
<div class="line">        miInteger m_approx_parametric_subdivisions;</div>
<div class="line">        miScalar  m_approx_fine_sub_pixel_size;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_numPrims;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_numPoints;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// A face renderer is created by enumerating the Faces on the PatchRenderer.</span></div>
<div class="line"> <span class="comment">// It will take a snapshot of the state of the PatchRenderer.</span></div>
<div class="line"> <span class="comment">// It will also inherit the xgen args and ProceduralCallbacks from the patch.</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">class </span>InitHairDataProcedural : <span class="keyword">public</span> BaseProcedural</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">        InitHairDataProcedural( <span class="keyword">const</span> Procedural&amp; parentProc, UserDataList* pUserData, miHair_list* pHair);</div>
<div class="line"> <span class="keyword">virtual</span> ~InitHairDataProcedural() {}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// static function for initialization</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">bool</span> initFaceRenderer(InitHairDataProcedural* dProc, </div>
<div class="line">            PatchRenderer* patch, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// XGenRenderAPI::ProceduralCallbacks</span></div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> flush(  <span class="keyword">const</span> <span class="keywordtype">char</span>* in_geom, PrimitiveCache* in_cache );</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> log( <span class="keyword">const</span> <span class="keywordtype">char</span>* in_str ){}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> render() { m_face-&gt;render();}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isValid() { <span class="keywordflow">return</span> m_numInterpolateComponents != -1;}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">inline</span> miGeoIndex getNumScalarsPerPoint()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_numScalarsPerPoint;}</div>
<div class="line"> <span class="keyword">inline</span> miGeoIndex getNumScalarsPerPrim()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_numScalarsPerPrim;}</div>
<div class="line"> <span class="keyword">inline</span> miGeoIndex getNumInterpolateComponents()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_numInterpolateComponents;} </div>
<div class="line"> <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; getUserDataStrFormat()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_userDataStrFormat;}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        InitHairDataProcedural();</div>
<div class="line">        InitHairDataProcedural( <span class="keyword">const</span> InitHairDataProcedural&amp; );</div>
<div class="line"></div>
<div class="line">        std::auto_ptr&lt;FaceRenderer&gt; m_face;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// approximation settings</span></div>
<div class="line">        miInteger m_approx_degree;</div>
<div class="line">        miInteger m_approx_mode;</div>
<div class="line">        miInteger m_approx_parametric_subdivisions;</div>
<div class="line">        miScalar  m_approx_fine_sub_pixel_size;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// this user data list will be initialized</span></div>
<div class="line">        UserDataList* m_pUserData;</div>
<div class="line">        std::string m_userDataStrFormat;</div>
<div class="line">        miHair_list* m_pHair;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// data layout numbers</span></div>
<div class="line">        miGeoIndex m_numScalarsPerPoint;</div>
<div class="line">        miGeoIndex m_numScalarsPerPrim;</div>
<div class="line">        miGeoIndex m_numInterpolateComponents;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">class </span>FlushHairDataProcedural : <span class="keyword">public</span> BaseProcedural</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">        FlushHairDataProcedural(</div>
<div class="line"> <span class="keyword">const</span> Procedural&amp; parentProc,</div>
<div class="line">            miGeoIndex* pHairIndices,</div>
<div class="line">            miScalar* pHairScalars,</div>
<div class="line">            UserDataList* pUserData,</div>
<div class="line">            miGeoIndex numScalarsPerPoint,</div>
<div class="line">            miGeoIndex numScalarsPerPrim,</div>
<div class="line">            miGeoIndex numInterpolateComponents,</div>
<div class="line">            miGeoIndex numScalarsTotal,</div>
<div class="line">            miGeoIndex numIndicesTotal);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">virtual</span> ~FlushHairDataProcedural() {}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// static function for initialization</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">bool</span> initFaceRenderer(FlushHairDataProcedural* dProc, </div>
<div class="line">            PatchRenderer* patch, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// XGenRenderAPI::ProceduralCallbacks</span></div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> flush(  <span class="keyword">const</span> <span class="keywordtype">char</span>* in_geom, PrimitiveCache* in_cache );</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> log( <span class="keyword">const</span> <span class="keywordtype">char</span>* in_str ){}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> render() { m_face-&gt;render();}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        FlushHairDataProcedural();</div>
<div class="line">        FlushHairDataProcedural( <span class="keyword">const</span> FlushHairDataProcedural&amp; );</div>
<div class="line"></div>
<div class="line">        std::auto_ptr&lt;FaceRenderer&gt; m_face;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// approximation settings</span></div>
<div class="line">        miInteger m_approx_degree;</div>
<div class="line">        miInteger m_approx_mode;</div>
<div class="line">        miInteger m_approx_parametric_subdivisions;</div>
<div class="line">        miScalar  m_approx_fine_sub_pixel_size;</div>
<div class="line">        miScalar  m_motion_blur_multiplier;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// buffers to write the data to</span></div>
<div class="line">        miGeoIndex* m_pHairIndices;</div>
<div class="line">        miScalar* m_pHairScalars;</div>
<div class="line">        UserDataList* m_pUserData;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// data layout sizes</span></div>
<div class="line">        miGeoIndex m_numScalarsPerPoint;</div>
<div class="line">        miGeoIndex m_numScalarsPerPrim;</div>
<div class="line">        miGeoIndex m_numInterpolateComponents;</div>
<div class="line"> <span class="comment">// Debug: compute offsets into the buffers to assert total size</span></div>
<div class="line">        miGeoIndex m_hairScalarsOffset;</div>
<div class="line">        miGeoIndex m_hairIndicesOffset;</div>
<div class="line">        miGeoIndex m_numScalarsTotal;</div>
<div class="line">        miGeoIndex m_numIndicesTotal;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">class </span>FlushSphereProcedural : <span class="keyword">public</span> BaseProcedural</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">        FlushSphereProcedural(</div>
<div class="line"> <span class="keyword">const</span> Procedural&amp; parentProc, </div>
<div class="line">            miTag sphereTag);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">virtual</span> ~FlushSphereProcedural() {}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// static function for initialization</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">bool</span> initFaceRenderer(FlushSphereProcedural* dProc, </div>
<div class="line">            PatchRenderer* patch, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f);</div>
<div class="line">        miTag getResultTag() { <span class="keywordflow">return</span> m_result;}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// XGenRenderAPI::ProceduralCallbacks</span></div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> flush(  <span class="keyword">const</span> <span class="keywordtype">char</span>* in_geom, PrimitiveCache* in_cache );</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> log( <span class="keyword">const</span> <span class="keywordtype">char</span>* in_str ){}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> render() { m_face-&gt;render();}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        FlushSphereProcedural();</div>
<div class="line">        FlushSphereProcedural( <span class="keyword">const</span> FlushSphereProcedural&amp; );</div>
<div class="line"></div>
<div class="line">        std::auto_ptr&lt;FaceRenderer&gt; m_face;</div>
<div class="line"></div>
<div class="line">        std::string m_parentName; <span class="comment">// parent name copied from parent procedural </span></div>
<div class="line">        miTag m_sphere; </div>
<div class="line">        miTag m_result;</div>
<div class="line">        std::vector&lt;miTag&gt; m_tags;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">class </span>Procedural : <span class="keyword">public</span> BaseProcedural</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">friend</span> <span class="keyword">class </span>ProceduralWrapper;</div>
<div class="line"> <span class="keyword">friend</span> <span class="keyword">class </span>FlushHairDataProcedural;</div>
<div class="line"> <span class="keyword">friend</span> <span class="keyword">class </span>InitHairDataProcedural;</div>
<div class="line"> <span class="keyword">friend</span> <span class="keyword">class </span>CountHairDataProcedural;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>Params</div>
<div class="line">        {</div>
<div class="line">            miString data;      <span class="comment">// Procedural Arguments</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// User Attributes Arguments. We define everything on the geoshader node for now.</span></div>
<div class="line"> <span class="comment">// All their content is converted into ParamMap, in init();</span></div>
<div class="line"> <span class="comment">// In other renderers, most are defined as user data on options, camera and the procedural.</span></div>
<div class="line">            miString user;      <span class="comment">// User RiAttribute on the geoshader</span></div>
<div class="line">            miString overrides; <span class="comment">// User overrides: length "0.0" width "0.0"</span></div>
<div class="line">            miScalar frame;</div>
<div class="line">            miString patches;   <span class="comment">// List of patches</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Echo params</span></div>
<div class="line">            miBoolean   echo;                   <span class="comment">// Echo the whole geoshader content to an mi file. The echo_* parameters fills the miEchoOptions struct.</span></div>
<div class="line">            miString    echo_filename;          <span class="comment">// Filename where to echo.</span></div>
<div class="line">            miBoolean   echo_ascii;             <span class="comment">// non-binary output</span></div>
<div class="line">            miInteger   echo_explode_objects;   <span class="comment">// write objects to subfiles</span></div>
<div class="line">            miBoolean   echo_verbatim_textures; <span class="comment">// dump textures verbatim ?</span></div>
<div class="line">            miInteger   echo_dont;              <span class="comment">// EO_* bitmap: omit these</span></div>
<div class="line">            miInteger   echo_dont_recurse;      <span class="comment">// EO_* bitmap: no prereqs</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Approx params</span></div>
<div class="line">            miInteger approx_degree;</div>
<div class="line">            miInteger approx_mode;</div>
<div class="line">            miInteger approx_parametric_subdivisions;</div>
<div class="line">            miScalar  approx_fine_sub_pixel_size;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Motion Blur params</span></div>
<div class="line">            miBoolean motion_blur;</div>
<div class="line">            miInteger motion_blur_mode;</div>
<div class="line">            miInteger motion_blur_steps;</div>
<div class="line">            miScalar  motion_blur_factor;</div>
<div class="line">            miScalar  motion_blur_multiplier;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Misc. params</span></div>
<div class="line">            miScalar max_displace;</div>
<div class="line">            miScalar m_hair_object_size;        <span class="comment">// Multiplier for the default hair object size </span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Sphere primitive params</span></div>
<div class="line">            miInteger m_sphere_subdiv_u;</div>
<div class="line">            miInteger m_sphere_subdiv_v;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        Procedural();</div>
<div class="line"> <span class="keyword">virtual</span> ~Procedural();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// MR Entry points.</span></div>
<div class="line"> <span class="keywordtype">void</span> init(miState* state, Params* paras, miBoolean *inst_init_req );</div>
<div class="line"> <span class="keywordtype">void</span> exit( miState* state, Params* paras );</div>
<div class="line">        miBoolean execute( miTag* result, miState* state, Params* paras );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Export geoshader content to disk.</span></div>
<div class="line"> <span class="keywordtype">void</span> echo( miTag* result, miState* state, Params* paras );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// XGenRenderAPI::ProceduralCallbacks</span></div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> flush(  <span class="keyword">const</span> <span class="keywordtype">char</span>* in_geom, PrimitiveCache* in_cache );</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> log( <span class="keyword">const</span> <span class="keywordtype">char</span>* in_str ){}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Render is called from the assembly callback function.</span></div>
<div class="line"> <span class="keywordtype">bool</span> render( miTag* result, <span class="keyword">const</span> miState* state );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Helper function for transferring data from placeholder callbacks</span></div>
<div class="line"> <span class="comment">// to flushSplines and vice versa</span></div>
<div class="line"> <span class="keywordtype">void</span> setPlaceholderObjectTag(<span class="keyword">const</span> miTag tag) { m_tagPlaceholderObject = tag;}</div>
<div class="line">        miTag getUserDataTag() { <span class="keywordflow">return</span> m_tagUserData;}</div>
<div class="line"> <span class="keyword">const</span> std::string&amp; getParentName()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_parentName;}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line"> <span class="comment">// These 4 methods are protected by the global mutex.</span></div>
<div class="line"> <span class="keywordtype">bool</span> nextFace( bbox&amp; b, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; f );</div>
<div class="line"> <span class="keywordtype">bool</span> initPatchRenderer( <span class="keyword">const</span> <span class="keywordtype">char</span>* in_params );</div>
<div class="line"> <span class="keywordtype">bool</span> initFaceRenderer( Procedural* pProc, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// init a new procedural per patch.</span></div>
<div class="line"> <span class="keywordtype">bool</span> initPatchProcedural( Procedural* pParent, <span class="keyword">const</span> std::string&amp; strPatch );</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Helper function for patch-render callback for splines/hair.</span></div>
<div class="line"> <span class="keywordtype">bool</span> renderHairObject( miTag* result, <span class="keyword">const</span> miState* state );</div>
<div class="line"> <span class="comment">// write out the hair object header</span></div>
<div class="line">        miHair_list* beginHairObject( );</div>
<div class="line"> <span class="keywordtype">void</span> endHairObject( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numScalarsTotal, <span class="keyword">const</span> std::string&amp; strFormat );</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> renderSphereAssembly();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> flushCards( <span class="keyword">const</span> <span class="keywordtype">char</span> *geomName, PrimitiveCache* pc );</div>
<div class="line"> <span class="keywordtype">void</span> flushArchives( <span class="keyword">const</span> <span class="keywordtype">char</span> *geomName, PrimitiveCache* pc );</div>
<div class="line"> <span class="keywordtype">void</span> syncArchives( <span class="keyword">const</span> <span class="keywordtype">char</span> *geomName, PrimitiveCache* pc );</div>
<div class="line"></div>
<div class="line"> <span class="comment">//static void pushCustomParams( AtNode* in_node, PrimitiveCache* pc );</span></div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* getUniqueName( <span class="keywordtype">char</span>* buf, <span class="keyword">const</span> <span class="keywordtype">char</span>* basename );</div>
<div class="line"></div>
<div class="line">        miTag m_node;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt;Procedural*&gt; TProcList;</div>
<div class="line">        TProcList m_patches;</div>
<div class="line">        PatchRenderer* m_patch;</div>
<div class="line">        std::string m_patchName;</div>
<div class="line">        FaceRenderer* m_face;</div>
<div class="line"></div>
<div class="line">        std::string m_data;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> getString( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keyword">const</span> <span class="keywordtype">char</span>*&amp; out_value, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span> ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> getFloat( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keywordtype">float</span>&amp; out_value, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span>  ) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getArraySize( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keywordtype">int</span> in_eType, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span>  ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> getFloatArray( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keyword">const</span> <span class="keywordtype">float</span>*&amp; out_value, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span>  ) <span class="keyword">const</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> getMatrixArray( <span class="keyword">const</span> ParamMap&amp; in_params, <span class="keyword">const</span> <span class="keywordtype">char</span>* in_name, <span class="keyword">const</span> miMatrix*&amp; out_value, <span class="keywordtype">bool</span> in_user=<span class="keyword">false</span>  ) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">        miTag makeArchiveInstanceGroup( PrimitiveCache* pc, <span class="keyword">const</span> std::string&amp; instanceName, <span class="keyword">const</span> std::string&amp; instanceGroupName, <span class="keyword">const</span> std::string&amp; filename, <span class="keyword">const</span> std::string&amp; select, <span class="keyword">const</span> std::string&amp; material, miScalar frame, miInteger assembly );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> miState* m_state;</div>
<div class="line">        miTag m_result;</div>
<div class="line">        miTag m_dummy;</div>
<div class="line">        miTag m_tagUserData;</div>
<div class="line">        std::string m_parentName;  </div>
<div class="line">        std::string m_parentNameNoFace;</div>
<div class="line">        std::string m_primType;</div>
<div class="line">        std::vector&lt;miTag&gt; m_tags;</div>
<div class="line">        std::vector&lt;miTag&gt; m_tagsHiddenGroup;</div>
<div class="line"> </div>
<div class="line">        miTag m_tagPlaceholderObject;</div>
<div class="line">        miGeoIndex m_numHairPoints;</div>
<div class="line">        miGeoIndex m_numHairPrims;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_faceBegin;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_faceEnd;</div>
<div class="line"></div>
<div class="line">        std::map&lt;std::string,std::string&gt;* m_archives;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> m_bSyncArchives;</div>
<div class="line"> <span class="keywordtype">bool</span> m_bPerFaceAssemblies;</div>
<div class="line"> <span class="keywordtype">bool</span> m_bEcho;</div>
<div class="line"> </div>
<div class="line">        miInteger m_approx_degree;</div>
<div class="line">        miInteger m_approx_mode;</div>
<div class="line">        miInteger m_approx_parametric_subdivisions;</div>
<div class="line">        miScalar  m_approx_fine_sub_pixel_size;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> m_motion_blur;</div>
<div class="line">        miInteger m_motion_blur_mode;</div>
<div class="line">        miInteger m_motion_blur_steps;</div>
<div class="line">        miScalar  m_motion_blur_factor;</div>
<div class="line">        miScalar  m_motion_blur_multiplier;</div>
<div class="line">        miScalar  m_max_displace;</div>
<div class="line">        miInteger m_sphere_subdiv_u;</div>
<div class="line">        miInteger m_sphere_subdiv_v;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div><br/></div>
</link></link></link></link></div></body>
</html>
