<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../style/prettify.css" type="text/css" rel="stylesheet">
<script type="text/javascript" src="../../scripts/prettify.js"></script><script src="../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="generator" content="pandoc"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../../scripts/utils/adsk.redirect.js"></script>
      <title>Autodesk Maya 2014</title>
   <meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script></script><script></script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Autodesk Maya 2014</h1>
         </div>

<div class='section'><a id="autodesk-maya-2014"></a></div>
<div class='section'><a id="openmaya-render"></a><h2 id="openmaya-render">OpenMaya Render</h2></div>
<p>UI Drawing enhancements</p>
<ul>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MUIDrawManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUIDrawManager</a></span> (new interface for Maya 2014)</p>
<p>See <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/UI-draw-manager.html' title=''>Section 3.9 UI draw manager</a>.</p></li>
</ul>
<p>Geometry Enhancements</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MGeometryExtractor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGeometryExtractor</a></span> now supports tangents, bitangents and colors.</li>
<li>Fixed <span class='code'><a href="javascript:void(0)" data-symbol="MGeometryExtractor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_geometry_extractor.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGeometryExtractor</a></span> to allow for more than one set of colors or texture coodinates to be extracted.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MIndexBuffer::unload()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a75d84312cb36261792b879ffc61e7e16&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MIndexBuffer::unload()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBuffer::unload()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html#a75d84312cb36261792b879ffc61e7e16&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVertexBuffer::unload()</a></span> added to move a buffer out of GPU memory and into system memory.</li>
<li>The &#39;object&#39; parameter of the <span class='code'><a href="javascript:void(0)" data-symbol="MPxVertexBufferGenerator::getSourceIndexing()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_vertex_buffer_generator.html#ad73980d05ffa932027a037d57303f806&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxVertexBufferGenerator::getSourceIndexing()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxVertexBufferGenerator::createVertexStream()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_vertex_buffer_generator.html#a6d88a4f50ab1fbce8592dc910291c832&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxVertexBufferGenerator::createVertexStream()</a></span> methods has changed its type from <span class='code'><a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDagPath</a></span> to <span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a></span> so as to reinforce that these settings are per object and not per DAG instance.</li>
</ul>
<p>Shader Override Enhancements</p>
<ul>
<li>There is now a new type of shader override (<span class='code'><a href="javascript:void(0)" data-symbol="MPxShadingNodeOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShadingNodeOverride</a></span>) based on shader fragments. This new system is a direct exposure of the internal system Maya uses to dynamically build effects for its shading networks. <span class='code'><a href="javascript:void(0)" data-symbol="MPxShadingNodeOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShadingNodeOverride</a></span> differs from the pre-existing <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride</a></span> in that implementations of <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride</a></span> are required to produce the whole shading effect for a shading network (including lighting), while <span class='code'><a href="javascript:void(0)" data-symbol="MPxShadingNodeOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShadingNodeOverride</a></span> is only required to produce a small fragment for an individual node within the network.</li>
<li>Implementations of <span class='code'><a href="javascript:void(0)" data-symbol="MPxShadingNodeOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShadingNodeOverride</a></span> define a shader fragment or graph of shader fragments to be used to draw a specific node in Viewport 2.0. This fragment or fragment graph is then connected to the fragments for the other nodes in the shading network (both those defined internally and by other plug-ins). The final composite fragment graph is then compiled to a shading effect and used to draw the objects associated with the shading network for which it was produced.</li>
<li>Shading fragments and fragment graphs are managed by the new <span class='code'><a href="javascript:void(0)" data-symbol="MFragmentManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_fragment_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_fragment_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFragmentManager</a></span> class. This class allows plug-ins to define new fragments for both GL and DX using XML to define the structure, parameters and source code of the fragment. <span class='code'><a href="javascript:void(0)" data-symbol="MFragmentManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_fragment_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_fragment_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFragmentManager</a></span> can also be used to query the XML definitions of Maya internal fragments in order to get examples of how to write new fragments that integrate well with the Maya fragment-based shader system.</li>
<li>A subclass of <span class='code'><a href="javascript:void(0)" data-symbol="MPxShadingNodeOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShadingNodeOverride</a></span>, called <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShadingNodeOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_surface_shading_node_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_surface_shading_node_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSurfaceShadingNodeOverride</a></span>, has also been introduced. This class provides extra functionality for supporting surface shaders (in other words, nodes that can be connected to the surface slot on the shading engine, generally classified with <em>shader/surface</em>).</li>
<li>For more details, see the API documentation for the new classes: <span class='code'><a href="javascript:void(0)" data-symbol="MPxShadingNodeOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shading_node_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShadingNodeOverride</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MFragmentManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_fragment_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_fragment_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFragmentManager</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShadingNodeOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_surface_shading_node_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_surface_shading_node_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSurfaceShadingNodeOverride</a></span>, as well as the updates to the <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide.html' title=''>Maya Viewport 2.0 API Guide</a>.</li>
</ul>
<p>Shader Instance Enhancements</p>
<ul>
<li>Addition of new simple stock shader to render color for depth passes.</li>
<li>Addition of stock shaders for drawing UI:
<ul>
<li>dashed or non-dashed, thick or non-thick, using constant color or color per vertex variations of shaders for lines</li>
<li>stipple face shader</li>
</ul></li>
<li><p>A uniform semantic <em>RelativeViewportDimensions</em> can be specified to obtain the relative viewport dimensions. This semantic can be used to adjust the UV transform on quad render operations.</p>
<p>The following example modifies the texture coordinates:</p>
<div class="codeBlock"><pre class="prettyprint">float4 gUVTransform : RelativeViewportDimensions;
In.UV * gUVTransform.zw + gUVTransform.xy”
</pre></div><p>The following shaders have been modified to use the new semantic:</p>
<ul>
<li>OpenGL: BlendGL.cgfx, BlurGL.cgfx, ThresholdGL.cgfx, AnaglyphGL.cgfx, FreeViewGL.cgfx, CheckerBoardGL.cgfx, InterlaceGL.cgfx</li>
<li>Direct3D10: Blend10.fx, Blur.fx, Threshold10.fx, Anaglyph10.fx, FreeView10.fx</li>
</ul></li>
<li>Addition of new fragment-based shader instance creation method: <span class='code'><a href="javascript:void(0)" data-symbol="MShaderManager::getFragmentShader()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderManager::getFragmentShader()</a></span>. It returns a new instance of a shader generated from a name shader fragment or fragment graph.</li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance</a></span> objects now support a <span class='code'>clone()</span> interface for use in situations where many identical shaders are needed in a high-performance manner.</p></li>
</ul>
<p>Texturing Enhancements</p>
<ul>
<li>There have been a number of modifications to the texture API that enhances how color textures are acquired, cached and updated:
<ul>
<li>For acquisition, the <span class='code'>acquireTexture()</span> methods on <span class='code'><a href="javascript:void(0)" data-symbol="MTextureManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTextureManager</a></span> have been modified to allow NULL data to be passed over on creation and to allow for unnamed textures (empty string). Unnamed textures are not cached by the internal texture caching system; as a result, the acquisition creates a new texture for each method call. The behavior of named textures remains the same. If a texture with that name exists in the cache, then it is returned.</li>
<li>In general, continuously reacquiring a texture is not recommended. Therefore, new interfaces that perform updates of existing textures have been added to <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture</a></span>:
<ul>
<li>MStatus update(const void* pixelData, bool generateMipMaps, unsigned int rowPitch=0);</li>
<li>MStatus update(const MImage &amp;image, bool generateMipMaps);</li>
</ul></li>
<li><p>Along with the new method <span class='code'><a href="javascript:void(0)" data-symbol="MTexture::bytesPerPixel()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#ac5a2b82710739bfaa0763e8d03116783&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture::bytesPerPixel()</a></span>, and the existing method <span class='code'><a href="javascript:void(0)" data-symbol="MTexture::rawData()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#ae99c4e325062e162a32dfd435d81725c&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture::rawData()</a></span> there are a number of different ways that textures can be updated:</p>
<ul>
<li>The raw data can be extracted from an existing <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture</a></span> and used for updating. In this case, it is important that the rowPitch from the <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture</a></span> be used during the <span class='code'>update()</span> call to ensure proper data transfer when there is row padding. This affects textures created under DirectX.</li>
<li>New raw data can be passed to update an existing <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture</a></span>. It is the responsibility of the caller to ensure that the data is of the correct size.</li>
<li><p>Data from an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a></span> can be used to update an existing <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture</a></span>. It is the responsibility of the caller to ensure that the format of the texture matches that of the <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a></span> which is currently 4-byte, 8 bytes per channel RGBA color. The <span class='code'>bytesPerPixel()</span> method can be used to query the <span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture</a></span> for a matching format.</p>
<p>The update mechanism is currently restricted to updating 2D non-array textures.</p>
<p>Each method call has an inherent cost. Different situations may warrant using different methods.</p></li>
<li><span class='code'>RawData()</span> copies memory back to the CPU from the GPU</li>
<li><span class='code'>Update()</span>, using raw pixel data, transfers CPU data to the GPU.</li>
<li><p><span class='code'>Update()</span>, using MImage, maps GPU memory to the CPU, performs a copy and then maps back to GPU.</p></li>
</ul>
<p>The existing plug-in <em>hwAPITextureTest</em> and a new plug-in <em>viewImageBlitOverride</em> demonstrate various methods of performing a color texture update. The first has a new option to invert the pixels in a texture before displaying, and the latter allows the updating of a texture for each refresh of a render override (<span class='code'><a href="javascript:void(0)" data-symbol="MRenderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderOverride</a></span>).</p></li>
</ul></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtil::eval2dTexture()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_render_util.html#a2ab946308e39ee33bf4c7ef07dae2ee3&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtil::eval2dTexture()</a></span> allows the evaluation of supported texture nodes at one or more (u,v) positions.</li>
<li>New interfaces have been added as convenience methods to acquire textures which are suitable for rendering to the depth buffer:
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture</a>* acquireDepthTexture(const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> &amp;textureName, const <a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a> &amp;image, bool generateMipMaps, const <a href="javascript:void(0)" data-symbol="MDepthNormalizationDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDepthNormalizationDescription</a> *normalizationDesc);</span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MTexture" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_texture.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture</a>* acquireDepthTexture(const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> &amp;textureName, float *pixelData, unsigned int width, unsigned int height, bool generateMipMaps, const <a href="javascript:void(0)" data-symbol="MDepthNormalizationDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDepthNormalizationDescription</a> *normalizationDesc);</span></li>
<li>The internal format used for these interfaces is R32F (single channel 32-bit floating point stored as the red channel, as opposed to a depth format).</li>
<li>The methods can normalize the input data to the \[0…1\] range, which is suitable for just performing a blit of the data to the depth buffer. The new structure <span class='code'><a href="javascript:void(0)" data-symbol="MDepthNormalizationDescription" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_depth_normalization_description.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDepthNormalizationDescription</a></span> is a way for the plug-in writer to provide input parameters for normalization. It assumes that input data adheres to the convention used for depth buffers produced by Maya’s software renderer, and hence what is stored in an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a></span>’s depth buffer. If textures are created unnormalized, then it is up to the plug-in writer to provide suitable shader logic to normalize them at render time.</li>
<li>The <span class='code'>acquireDepthTexture()</span> interface, which takes an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a></span> as an input, assumes that there is a valid depth buffer stored.</li>
<li>A new method has been added to <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a></span>, which can be used to aid in the computation of normalized data. The method returns the depth value ranges for the depth buffer in an <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a></span>:
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> getDepthMapRange( float &amp;minValue, float &amp;maxValue ) const;</span></li>
</ul></li>
<li><p>The plug-in <em>viewImageBlitOverride</em> provides example code for both generating raw data to fill in a normalized depth texture, as well as for reading an existing depth buffer from an iff file on disk.</p>
<p>In order to blit to depth, a depth-stencil state override is used on a custom <span class='code'><a href="javascript:void(0)" data-symbol="MQuadRender" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MQuadRender</a></span>.</p></li>
<li><p>Refer to related modifications for <span class='code'><a href="javascript:void(0)" data-symbol="MQuadRender" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MQuadRender</a></span> (see <a href='#!/url=./developer/What-s-New-What-s-Changed-/Autodesk-Maya-2014.htmlGUID-BACBD199-749A-4B23-BA46-5A0FC033FCCA' title=''>MQuadRender</a>) for details on state setting changes.</p></li>
</ul></li>
</ul>
<p>Lighting Enhancements</p>
<ul>
<li><em>Unlimited</em> light access:
<ul>
<li>The existing interfaces for accessing light information have been modified to allow you to specify whether or not to ignore the Viewport 2.0 renderer’s light limit setting. The number of shadow maps accessible is still currently clamped to the light limit.</li>
<li><p>The following interfaces now accept a new <span class='code'>LightFilter</span> parameter:</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MDrawContext::numberOfActiveLights()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html#a245ec3740263f7f3c076dd9c723141b7&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext::numberOfActiveLights()</a></span> \[new method\]</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MDrawContext::getLightInformation()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html#ad76985f8ee279b7ffd948dc492a748a3&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext::getLightInformation()</a></span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MDrawContext::getLightParameterInformation()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html#a05eaca3528290935c1b9ee55ae020c75&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext::getLightParameterInformation()</a></span></li>
</ul>
<p>The previous version of the method <span class='code'>numberOfActiveLights()</span> is now obsolete.</p></li>
</ul></li>
<li>Shadow updates “by request”
<ul>
<li>It is possible to ask to compute shadow maps on specific light DAG objects even if they are beyond the Viewport 2.0 renderer’s light limit setting. The method <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::setLightRequiresShadows()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#ac777540ab7b1bca5d51f7d03e62b4643&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::setLightRequiresShadows()</a></span> can be used to either queue or remove from queue such a request. This method does not force a given shadow map to be computed, nor does it force any refresh or new render to occur. It triggers a check for the need for a shadow map update. <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::setLightsAndShadowsDirty()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a06b742a8850af64d01e3fcbd9450916f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::setLightsAndShadowsDirty()</a></span> (see <a href='#!/url=./developer/What-s-New-What-s-Changed-/Autodesk-Maya-2014.html#openmaya-render' title=''>Change Management</a>) can be used to force computation, if necessary.</li>
<li>If this method is called from within the rendering of a frame, then any shadow map computation update occurs on the next scene update. For example, if this is called from within a hardware shader plug-in (<span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride</a></span>), then updates occur in the next frame (refresh). If called from a render override operation, then the next scene render triggers an update. The scene render is either the next <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender</a></span> called from within an override, or the next scene render called by the renderer internally when there is no render override.</li>
<li>Example code using this interface can be found in the <em>dx11Shader</em> (<span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride</a></span>) and <em>viewRenderOverrideShadows</em> (<span class='code'><a href="javascript:void(0)" data-symbol="MRenderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderOverride</a></span>) plug-ins. The <em>dx11Shader</em> plug-in has code that illustrates invoking an additional refresh on light binding changes.</li>
</ul></li>
<li>Enhanced lighting / shadowing interfaces for render overrides
<ul>
<li>Generally, lighting information is only updated during a scene render (<span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_scene_render.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender</a></span>). If a shadow request is performed from within a user operation (<span class='code'><a href="javascript:void(0)" data-symbol="MUserRenderOperation" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUserRenderOperation</a></span>) in a custom render override, then only the last available lighting information is available. If a user operation requires lighting information, the new virtual method <span class='code'><a href="javascript:void(0)" data-symbol="MUserRenderOperation::requiresLightData()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html#a3f130aa677f7fc44a7c8c26b8452a276&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUserRenderOperation::requiresLightData()</a></span> can be overridden and set to return true.</li>
<li>To allow for a scene render in a render override to access information such as shadow maps after update, two new methods have been added: <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::preSceneRender()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#ad15ab1a015ce24728b96c4580f66521c&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::preSceneRender()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::postSceneRender()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#a35198ec596b08ec1d753fc888afd9e0a&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::postSceneRender()</a></span>. They are called before and after either: shadow map update, or the rendering of the scene. At this time, the current draw context is available, and hence lighting/shadowing information (<span class='code'><a href="javascript:void(0)" data-symbol="MLightParameterInformation" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_light_parameter_information.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_light_parameter_information.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MLightParameterInformation</a></span>).</li>
<li>An example which uses the new interfaces is the new <span class='code'>viewRenderOverrideShadows</span> render override plug-in. This plug-in performs a user operation to queue shadow requests and then uses them in a custom scene render. The pre-scene render method is overridden to extract the requested shadow maps for use during scene rendering by a custom shader. Light and shadow information beyond the light limit can be accessed.</li>
</ul></li>
</ul>
<p>Render Item Enhancements</p>
<ul>
<li>Instances of <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem</a></span> may no longer be created or deleted directly. Plug-ins must now use the static <span class='code'>Create()</span> and <span class='code'>Destroy()</span> methods on <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem</a></span>. This change addresses stability issues encountered when the allocation/deallocation of the memory occurs in different DLLs.</li>
<li>Can now specify the “Bounding Box” viewport mode for render items.</li>
<li>Can now set the transform matrix for render items.</li>
<li>Can now set whether or not a render item should be included in post-effects such as screen-space ambient occlusion or motion blur.</li>
<li>The “depth priority” of a render item can now be set. “Depth priority” sets how far towards the active camera a render item is moved when drawing. This helps to avoid depth-fighting which can occur for render items with drawing that overlaps each other in depth. For example, a render item drawing wireframe and another drawing filled could be drawn at the same depth. To avoid the wireframe item from being obscured by the shaded item, the depth priority on the wireframe item can be “raised” to avoid being obscured. See <span class='code'>depthPriority()</span> methods for more information.</li>
<li>Previously, any <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem</a></span>s created by a plug-in had their status for casting and receiving shadows automatically set each time <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride::updateRenderItems()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#abad8e8b1f0e06eea32e2be8f97200941&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride::updateRenderItems()</a></span> was called. This continues to occur for internally created render items, but this is no longer the case for render items created by the plug-in. It is the responsibility of the plug-in to either track the status on any associated DAG object, or set the values based on other logic. Any items that are marked as drawing in wireframe mode never cast nor receive shadows. Note that render items that draw using lines or points can still cast shadows as long as they are not marked to draw in wireframe mode. The plug-in <em>apiMeshShape</em> provides an example that demonstrates various usage scenarios.</li>
<li>Although the following methods are exposed on <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem</a></span>, they have no effect on internally created render items:
<ul>
<li><span class='code'>setDrawMode()</span></li>
<li><span class='code'>setMatrix()</span></li>
<li><span class='code'>setShader()</span></li>
<li><span class='code'>setExcludedFromPostEffects()</span></li>
<li><span class='code'>castShadows()</span></li>
<li><span class='code'>receivesShadows()</span></li>
<li><span class='code'>depthPriority()</span></li>
</ul></li>
<li>The <span class='code'>setExclucedFromPostEffects()</span> method only disables screen-space ambient occlusion if the render item is marked as drawing in shaded or textured mode. If the item is marked as drawing in wireframe mode, then all post-effects are disabled (screen-space ambient occlusion, motion blur and depth-of-field).</li>
</ul>
<p>State Enhancements</p>
<ul>
<li>The methods on <span class='code'><a href="javascript:void(0)" data-symbol="MStateManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_state_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_state_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStateManager</a></span> for acquiring state objects are now static; therefore, states can now be both created and deleted without access to an <span class='code'><a href="javascript:void(0)" data-symbol="MDrawContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext</a></span>. Only activating states require a draw context.</li>
</ul>
<p>Pass Information Enhancements</p>
<ul>
<li>There are a few new pass context semantics which have been exposed as part of the addition of the <span class='code'><a href="javascript:void(0)" data-symbol="MUIDrawManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUIDrawManager</a></span> interface:
<ul>
<li>UI geometry : UI is being drawn
<ul>
<li>Pre-UI geometry : UI drawn before the scene (for example, the ground plane).</li>
<li>Post UI geometry: UI drawn relative to filled drawing (for example, wireframe or components on a surface).</li>
<li>Opaque UI : Opaque UI is being drawn.</li>
<li>Transparent UI : Transparent UI is being drawn.</li>
<li>Xray UI : UI in x-ray mode is being drawn.</li>
</ul></li>
</ul></li>
</ul>
<p>Render Override Enhancements</p>
<ul>
<li>Fixed so that post-effects do not affect scene render operations which only draw the UI.</li>
<li>Ability to explicitly disable post-effects for scene render operations.</li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MQuadRender" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MQuadRender</a></span> now allows for the specification of state setters. By default, when rendering the geometry for a quad render operation, blending is disabled, depth write is disabled, and culling is disabled. Any of the following methods can be implemented by classes derived from <span class='code'><a href="javascript:void(0)" data-symbol="MQuadRender" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_quad_render.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MQuadRender</a></span> to replace the default behavior for a given state:</p>
<ul>
<li><span class='code'>virtual const <a href="javascript:void(0)" data-symbol="MDepthStencilState" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_depth_stencil_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_depth_stencil_state.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDepthStencilState</a>* depthStencilStateOverride(); // Override depth-stencil state</span></li>
<li><span class='code'>virtual const <a href="javascript:void(0)" data-symbol="MRasterizerState" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_rasterizer_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_rasterizer_state.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRasterizerState</a>* rastersizerStateOverride(); // Override rasterizer state</span></li>
<li><span class='code'>virtual const <a href="javascript:void(0)" data-symbol="MBlendState" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_blend_state.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_blend_state.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MBlendState</a>* blendStateOverride(); // Override blend state</span></li>
</ul>
<p>If an override is specified for a given state, then the default state is used for those other states that are not overridden.</p>
<p>The <em>viewImageBlitOverride</em> plug-in from the devkit provides an example of overriding the depth write state.</p></li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::theRenderer()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::theRenderer()</a></span> now takes an optional <span class='code'>initializeRenderer</span> parameter. Passing false suppresses full initialization of the renderer. This can speed up the loading of plug-ins by allowing them to register their rendering overrides without the overhead of full renderer initialization.</p></li>
</ul>
<p>Change Management Enhancements</p>
<ul>
<li>There is a new method on <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer</a></span> that informs Maya that lights and shadow maps in the scene need to be re-evaluated: <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::setLightsAndShadowsDirty()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a06b742a8850af64d01e3fcbd9450916f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::setLightsAndShadowsDirty()</a></span>. This is useful, for example, for shaders that can modify the geometry of an object through hardware tessellation. Maya cannot automatically detect that the geometry has changed in such a case; therefore, it is up to the shader to notify Maya when changes occur that would require shadows to be recomputed.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::disableChangeManagementUntilNextRefresh()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a36396613f85279a61dde9946bf5b9844&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::disableChangeManagementUntilNextRefresh()</a></span> can be used to avoid the overhead of Viewport 2.0 processing changes to the scene when large changes are being made that do not require viewport updates.</li>
</ul>
<p>Draw Override Enhancements</p>
<ul>
<li><p>The <span class='code'>prepareForDraw()</span> interface now accepts <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a></span> as a parameter as follows:</p>
<p><span class='code'>virtual <a href="javascript:void(0)" data-symbol="MUserData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_user_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_user_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUserData</a>* prepareForDraw( const <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDagPath</a>&amp; objPath, const <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDagPath</a>&amp; cameraPath, const <a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a>&amp; frameContext, <a href="javascript:void(0)" data-symbol="MUserData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_user_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_user_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUserData</a>* oldData) = 0</span></p></li>
<li><p>Because occasionally geometry information is computed based on viewport attributes (for example, viewport size); therefore, plug-in developers may require this information in preparing for the draw data stage.</p></li>
</ul>
<p>Geometry Override Enhancements</p>
<ul>
<li>Switching between templating and not templating a Maya DAG object automatically toggles the visibility of shaded render items, which makes this consistent with the logic used for the default viewport interface. Plug-ins can override this behavior as desired to disable/enable any or all of these items.</li>
<li>Improvements to the <span class='code'>apiMeshShape</span> example that uses <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride</a></span>. The code demonstrates the following:
<ul>
<li>Drawing the wireframe in different display modes (display mode detection), and not just when the object is active (active display mode) .</li>
<li>Drawing of dormant and active vertices using the “fat point” stock shader.</li>
<li>Sample code for acquiring thick line and dash line stock shaders.</li>
<li>Support for hiding render items when the object is templated and appropriate render items for drawing templates.</li>
<li>Usage of new <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::depthPriority()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a6e865e2cf5c9d818b1cbb99af2360c47&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::depthPriority()</a></span> methods to avoid depth-fighting between UI drawing (for example active and dormant vertex drawing).</li>
</ul></li>
</ul>
<p>Maya Callback Enhancements</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MUiMessage::add3dViewRendererChangedCallback()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_ui_message.html#a3844c3a1b1cf18818560df527afb0ab1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUiMessage::add3dViewRendererChangedCallback()</a></span> lets you track changes to the renderer used for a particular view, while <span class='code'><a href="javascript:void(0)" data-symbol="MUiMessage::add3dViewRenderOverrideChangedCallback()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_ui_message.html#a7108d8024a910c316bc343affd775e8a&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUiMessage::add3dViewRenderOverrideChangedCallback()</a></span> lets you track changes to a view&#39;s render override.</li>
</ul>
<div class='section'><a id="mframecontext"></a><h2 id="mframecontext">MFrameContext</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a></span> is a new interface for Maya 2014. It is designed to provide information which is available per frame render. This includes information such as render targets, viewport size and camera information.</p>
<p>In terms of relative scope, <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a></span> can be thought of as encompassing the time period for a one or more &quot;passes&quot; (<span class='code'><a href="javascript:void(0)" data-symbol="MPassContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_pass_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_pass_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPassContext</a></span>) and the time period for actual drawing (<span class='code'><a href="javascript:void(0)" data-symbol="MDrawContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext</a></span>).</p>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MDrawContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext</a></span> is derived from <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a></span> and provides its own implementation for all virtual methods. The values returned from these methods may differ slightly between <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MDrawContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext</a></span> as <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a></span> retrieves the values from Maya and <span class='code'><a href="javascript:void(0)" data-symbol="MDrawContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext</a></span> retrieves the values from the GPU device state. Also, <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::getMatrix()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a71cbe2a3f2dfa967ebc43b5e97456ccb&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::getMatrix()</a></span> is not able to return values for any matrix type requiring the object-to-world matrix, as that information is only available at draw time.</p>
<p>Frame context information available includes:</p>
<ul>
<li>Camera and view information.</li>
<li>Viewport and active render target information.</li>
<li>Display style (mimicking the Viewport 2.0 render globals and viewport options)</li>
<li>Lighting mode and light limit (same)</li>
<li>Indication of which post effects are active</li>
<li>Indication of which transparency algorithm is used</li>
<li>Global line width setting in the viewport Shading menu</li>
</ul>
<div class='section'><a id="mpxsubsceneoverride"></a><h2 id="mpxsubsceneoverride">MPxSubSceneOverride</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride</a></span> is a new interface for Maya 2014. It is an alternative to <span class='code'><a href="javascript:void(0)" data-symbol="MPxDrawOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxDrawOverride</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride</a></span>, and is specifically optimized for representing plug-in DAG objects in Viewport 2.0 that need to produce a large number of independent drawable objects. For example, a plug-in node that can define a whole sub-scene (such as the <em>gpuCache</em> plug-in) is a good fit for this interface as a single node may need to produce tens of thousands of drawable objects.</p>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride</a></span> falls in between <span class='code'><a href="javascript:void(0)" data-symbol="MPxDrawOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxDrawOverride</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride</a></span> with respect to the amount of control given to the implementation. <span class='code'><a href="javascript:void(0)" data-symbol="MPxDrawOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxDrawOverride</a></span> allows full control over the entire draw of the object, but as a result the implementation is entirely responsible for the draw. <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride</a></span> is relatively simple to work with, but as a result only limited control of the draw is available. <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride</a></span> can fully define all render items, geometry and shaders, providing a high degree of control. However, this definition is abstracted from the hardware draw API; therefore, only one implementation is needed to get support for both DirectX and OpenGL. Furthermore, Maya handles drawing of the render items and thus the items can participate more fully in the Maya rendering pipeline (including screen-space effects such as screen-space ambient occlusion, transparency sorting, shadow casting/receiving, and so forth).</p>
<div class='section'><a id="ghosting-support"></a><h2 id="ghosting-support">Ghosting support</h2></div>
<p>The Maya 2014 API explicitly does not call back to render overrides to render ghosted objects.</p>
<p>Previously, when the dag object for which an override is attached to is set to be ghosted, it is possible for the render item or draw code to be called multiple times – once for each ghost.</p>
<p>This no longer occurs. Thus, it is up to the plug-in writer to write code to perform the plug-in&#39;s own ghosting.</p>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxDrawOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_draw_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxDrawOverride</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride</a></span> are the affected classes.</p>
<div class='section'><a id="net-api"></a><h2 id="net-api">.NET API</h2></div>
<p>The port of the MetaData C++ API to the .NET API has been revamped and improved significantly to:</p>
<ul>
<li>support standard .NET interfaces such as <span class='code'>IDictionary</span> and <span class='code'>IEnumerable</span> on key classes</li>
<li>simplify the concept of data description and data access where the user can now simply provide a .NET type for the data. This completely replaces the need for using the classes <span class='code'><a href="javascript:void(0)" data-symbol="Structure" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/classadsk_1_1_data_1_1_structure.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">Structure</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="Handle" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/classadsk_1_1_data_1_1_handle.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">Handle</a></span> as they are now created automatically from this client type.</li>
</ul>
<p>For more information, see <a href='#!/url=./developer/Maya-NET-API/Meta-Data.html' title=''>MetaData</a>.</p>
<div class='section'><a id="new-api-for-reference-edits"></a><h2 id="new-api-for-reference-edits">New API for Reference Edits</h2></div>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPxEditData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_edit_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxEditData</a></span> gives you the ability to create your own custom data to associate with reference edits.</li>
</ul>
<div class='section'><a id="new-api-for-generic-metadata-blind-data"></a><h2 id="new-api-for-generic-metadata-blind-data">New API for Generic Metadata (blind data)</h2></div>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFileIO" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_file_i_o.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFileIO</a></span> - Added the <span class='code'>setMetadata()</span>, <span class='code'>deleteMetadata()</span> and <span class='code'>metadata()</span> methods to allow the specification of persistent scene-level metadata (that is, it is stored with the scene file).</li>
</ul>
<div class='section'><a id="new-external-content-api"></a><h2 id="new-external-content-api">New External Content API</h2></div>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MExternalContentInfoTable" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_external_content_info_table.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_external_content_info_table.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MExternalContentInfoTable</a></span> is used to store the locations of all the external content (files, textures, and so forth) that is needed by a node to perform its work. <span class='code'><a href="javascript:void(0)" data-symbol="MExternalContentLocationTable" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_external_content_location_table.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_external_content_location_table.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MExternalContentLocationTable</a></span> is used to pass updates to those locations to the node (for example, from the File Path Editor).</li>
<li><span class='code'>getExternalContent()</span>, <span class='code'>setExternalContent()</span> and <span class='code'>addExternalContentForFileAttr()</span> have been added to <span class='code'><a href="javascript:void(0)" data-symbol="MFnDependencyNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_dependency_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_dependency_node.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDependencyNode</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode</a></span> to access and modify the external content of nodes.</li>
</ul>
<div class='section'><a id="miscellaneous"></a><h2 id="miscellaneous">Miscellaneous</h2></div>
<ul>
<li><span class='code'>MnObject::fnObject</span> and <span class='code'>fOwn</span> have been made private. These should not been used and if they are, modifications must be made accordingly.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MRampAttribute" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_ramp_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_ramp_attribute.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRampAttribute</a></span> has had a number of methods added to make it easier to use. <span class='code'>setRamp()</span> makes it easier to set new values on the ramp and <span class='code'>createRamp()</span> makes it easier to create a ramp with initial values. Also added are <span class='code'>sort()</span>, <span class='code'>pack()</span>, and <span class='code'>hasIndex()</span>.</li>
<li>The <span class='code'>evalNoSelectNotify</span> command executes a command with selection change notifications disabled. This can significantly improve performance in those situations where a script is executing a large number of commands which change the current selection (for example, <span class='code'>createNode</span>), but where only the final selection state is significant.</li>
</ul>
<div class='section'><a id="documentation"></a><h2 id="documentation">Documentation</h2></div>
<p>Plug-in transforms</p>
<ul>
<li><p>Plug-in writers should be aware that, in order for a plug-in transform to be recognized in Viewport 2.0, the appropriate classification string <em>drawdb/geometry/transform</em> must be added when registering the transform. This must be done so that:</p>
<ul>
<li>Local rotation axis and pivots draw.</li>
<li>Transforming the object moves any children parented under it in the DAG.</li>
</ul>
<p>For example, for the <em>rockingTransform</em> plug-in, the code is as follows:</p>
<div class="codeBlock"><pre class="prettyprint">// Classify the node as a transform.  This causes Viewport
// 2.0 to treat the node the same way it treats a regular
// transform node.
const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> classification = &quot;drawdb/geometry/transform&quot;;
status = plugin.registerTransform(&quot;rockingTransform&quot;,                               
                                   rockingTransformNode::id,                                    
                                   &amp;rockingTransformNode::creator,                              
                                   &amp;rockingTransformNode::initialize,
                                   &amp;rockingTransformMatrix::creator,
                                   rockingTransformMatrix::id,
                                   &amp;classification);

</pre></div><p>This functionality was available beginning Maya 2012.</p>
<p>In Maya 2014, <span class='code'>registerTransform()</span> has been updated to automatically add the <span class='code'>drawdb/geometry/transform</span> classification if no other <span class='code'>drawdb</span> classification is specified. The <span class='code'>getClassification</span> command documentation has also been updated with the general list of classifications recognized by Viewport 2.0.</p></li>
</ul>
<p>Updates to Viewport 2.0 API chapter</p>
<ul>
<li><a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide.html' title=''>Maya Viewport 2.0 API Guide</a>.</li>
</ul>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
