<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../style/prettify.css" type="text/css" rel="stylesheet">
<script type="text/javascript" src="../../scripts/prettify.js"></script><script src="../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="generator" content="pandoc"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../../scripts/utils/adsk.redirect.js"></script>
      <title>Threading and Maya</title>
   <meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script></script><script></script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Threading and Maya</h1>
         </div>

<div class='section'><a id="threading-and-maya"></a></div>
<div class='section'><a id="maya-api-threading-interface-description-and-examples"></a><h2 id="maya-api-threading-interface-description-and-examples">Maya API threading interface, description and examples</h2></div>
<p>Having laid the groundwork by describing required threading functionality, this section discusses the functionality provided by the Maya API, and illustrates usage with some example plug-ins supplied with Maya.</p>
<p>In Maya, a number of threading classes exist to provide support for thread creation, management and locking. These threading classes build on Intel&#39;s TBB threads, which are used internally by Maya. The classes expose a native threading-like API to plug-in writers. Note that these classes do not require the plug-in writer to use TBB directly in their plug-ins, or even be familiar with TBB. Since these threads are actual internal Maya threads, they respect thread count settings applied in Maya, and avoid the problem of creating increasing numbers of active threads as plug-ins are themselves threaded. They also provide protection from oversubscription problems in some cases due to the way TBB implements threading.</p>
<p>The API provides the following three major areas of functionality:</p>
<ul>
<li>fork-join threading implementation model</li>
<li>asynchronous task-based threading model</li>
<li>threading synchronization interfaces</li>
</ul>
<p>The architecture employs object reference counting to assist with memory management and to delay deallocation of objects until all users of the object are finished with it. A successful call to an API function returns an interface pointer, and the caller is responsible for calling <span class='code'>release()</span> on that interface when they are finished with it. Failure to do so could lead to memory leaks.</p>
<p>The return <span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a></span> of calls should always be checked, as it should never be assumed that a call will always succeed.</p>
<div class='section'><a id="thread-creation-and-management-using-the-maya-api"></a><h2 id="thread-creation-and-management-using-the-maya-api">Thread creation and management using the Maya API</h2></div>
<div class='section'><a id="mthreadpool"></a><h3 id="mthreadpool">MThreadPool</h3></div>
<p>This class creates or reuses a thread pool. Since creation and deletion of threads is expensive, it is a good idea to make use of the thread pool where possible, and try to keep it around between invocations of the plug-in rather than recreate it each call. The thread pool is reference counted, so it is possible to create it in the <span class='code'>initialize()</span> method of the plug-in and keep it for the duration of the application, releasing it in the <span class='code'>uninitialize()</span> method. It provides methods common to native threading implementations, allowing for migration of plug-ins from native threads over to this API.</p>
<p>The implementation requires the creation of a fork-join context which takes a function pointer as an argument. This function needs to implement the decomposition of the given problem into smaller chunks (tasks) which are then mapped to threads by TBB internally.</p>
<p>Note that the use of TBB internally means that it is possible to nest threaded fork-join regions created with <span class='code'><a href="javascript:void(0)" data-symbol="MThreadPool" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_thread_pool.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MThreadPool</a></span> without causing oversubscription, as TBB will schedule all the tasks in parallel by mapping them to cores.</p>
<div class='section'><a id="example"></a><h4 id="example">Example</h4></div>
<p>See the example plug-in <span class='code'>threadTestCmd</span>, supplied with Maya, which computes prime numbers using a thread pool. This requires the creation of a new function, <span class='code'>DecomposePrimes</span>, to decompose the problem into smaller parts. The code within <span class='code'>DecomposePrimes</span> looks very similar to a native threading implementation, the main difference being the use of the control variable NUM_TASKS rather than the number of threads. As discussed above, TBB internally takes care of mapping the tasks to threads, and ensures optimal load balancing.</p>
<div class='section'><a id="mthreadasync"></a><h3 id="mthreadasync">MThreadAsync</h3></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MThreadAsync" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_thread_async.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MThreadAsync</a></span> class provides methods common to native threads that allow the user to map independent asynchronous tasks to threads. The current implementation does not use a thread pool for this interface but instead creates new threads for each asynchronous task. This means it is possible to cause oversubscription, so care must be taken in managing the number of asynchronous threads and the amount of work they do concurrently.</p>
<p>The <span class='code'>createTask()</span> method takes a function pointer that executes the asynchronous task and also a pointer to a callback function that can be used by developers to implement a fork-join or any other signaling mechanism.</p>
<div class='section'><a id="example-1"></a><h4 id="example-1">Example</h4></div>
<p>Refer to the example plug-in <span class='code'>threadTestWithLocksCmd.cpp</span>. This plug-in is shipped with Maya. Compared with the thread pool example described previously, this implementation does not require the creation of a separate function like <span class='code'>DecomposePrimes</span>, as it mimics the native threading API closely. However the asynchronous threading interface does not provide a join method. The example shows how the equivalent functionality may be implemented by implementing barriers in the callback functions (<span class='code'>WaitForAsyncThreads</span>.)</p>
<p>The function <span class='code'>Maya_InterlockedCompare()</span> could be implemented more efficiently using the atomic <span class='code'>compareAndSwap()</span> method in the <span class='code'>MAtomic.h</span> header provided with the Maya API.</p>
<div class='section'><a id="locking-operations-using-the-maya-api"></a><h2 id="locking-operations-using-the-maya-api">Locking operations using the Maya API</h2></div>
<div class='section'><a id="system-locks"></a><h3 id="system-locks">System locks</h3></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MMutexLock" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_mutex_lock.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MMutexLock</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MSpinLock" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_spin_lock.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSpinLock</a></span> are system locks. <span class='code'><a href="javascript:void(0)" data-symbol="MMutexLock" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_mutex_lock.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MMutexLock</a></span> uses <span class='code'>pthread_mutex_lock</span> on OSX and Linux, and <span class='code'>EnterCriticalSection</span> on Windows. The difference between these is that a mutex lock is a heavier operation but requires no CPU resources once the lock is held. A spin lock is a light operation, but requires heavy CPU resources while waiting. So if the wait is likely to be short, use a spin lock. These classes release the lock in their destructor, meaning explicit release is not required, and the lock will be safely released even if an exception is thrown in the locked code.</p>
<p>It is best to use different instances of lock objects for unrelated code. If a single lock object is used in many different places, threads may be blocked even if working on unrelated tasks.</p>
<div class='section'><a id="atomic-operations"></a><h3 id="atomic-operations">Atomic operations</h3></div>
<p>The Maya API includes an implementation of atomic operations in the API header called <span class='code'>MAtomic.h</span> which provides cross-platform atomic operation functionality. Below is a listing of the atomic operations available. Full descriptions are given in the file itself and in the Maya API class documentation.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MAtomic::preIncrement" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#a6e8874b8bf5bfffb6fac137dba28f888&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::preIncrement</a>()
<a href="javascript:void(0)" data-symbol="MAtomic::postIncrement" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#ac2c0d7597183016c73e3e44f3eca453b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::postIncrement</a>()
<a href="javascript:void(0)" data-symbol="MAtomic::increment" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#acddba9e14f0627bf4e38792f81a47fd4&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::increment</a>()
<a href="javascript:void(0)" data-symbol="MAtomic::preDecrement" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#aa9a012890f5cbfe4b7cb76d29d934fd9&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::preDecrement</a>()
<a href="javascript:void(0)" data-symbol="MAtomic::postDecrement" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#a65228d140e8bc76f047708eaff3a9210&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::postDecrement</a>()
<a href="javascript:void(0)" data-symbol="MAtomic::decrement" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#afe75af9726e9e7070d5a4ded46b49df2&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::decrement</a>()
<a href="javascript:void(0)" data-symbol="MAtomic::set" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#afadcfa2eca88f808d9eb8b3b73c1e515&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::set</a>()
<a href="javascript:void(0)" data-symbol="MAtomic::compareAndSwap" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#ada84e1d5fb08e43440e14bff2793fb69&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::compareAndSwap</a>()

</pre></div><div class='section'><a id="performance-of-locking-and-atomic-operations"></a><h3 id="performance-of-locking-and-atomic-operations">Performance of locking and atomic operations</h3></div>
<p>The following are the performance numbers for the cost of spin and mutex locks and atomic operations on Windows 64. (Other platforms are similar with the exception of OSX that mutex is much slower.) The plug-in to generate these numbers is called <span class='code'>threadingLockTests</span>, and is shipped with Maya as a sample plug-in for you to test performance on your own system. It requires a compiler that supports OpenMP. Note that this plug-in is an extreme case as the code does very little actual parallel work within the locked region. However it does give an indication of the relative cost of these locks under heavy contention. (A contended lock is one where another thread attempts to gain the lock that is already held by one thread. Having more running threads increases the chances of lock contention dramatically. Performance suffers significantly if there is high contention.)</p>
<div class='figure'><img src='developer/images/Threading_6a.png' title=''></div>
<p>Note the benefit of atomic operations over the various mutex locks. Also note that code without any locking is far faster than even the atomic implementation. Clearly it is best to avoid locks wherever possible. If not, atomic operations should be used, and only if this is not possible should full mutex or spin locks be used.</p>
<p><strong>Lock granularity</strong> is a large complex topic in itself. In general it is best to lock at a finer grained level rather than a coarser level, as it allows more opportunities for parallelism. However too much fine grained locking can eat up a lot of system time and add significant complexity to the code. The challenge is to find an optimal balance point between coarse and fine grained locking. Since coarse grained locking is easiest, it is best to start with such locking and then more to progressively finer grained locking until performance stops improving.</p>
<p>The worst locking problems are those that prevent the application from progressing at all:</p>
<ul>
<li><strong>Deadlocks</strong> occur when two threads each take a different lock, then each attempts to acquire the lock held by the other thread. No further progress is possible and the application hangs.</li>
<li><strong>Livelocks</strong> are similar to deadlocks except that each thread continually remains active without progressing past the lock. An example would be code that can detect a deadlock and roll back from it, but then simply allows the same evaluation to recur, leading to an infinitely repeating cycle.</li>
</ul>
<div class='section'><a id="maya-api-threading-example---deformer"></a><h2 id="maya-api-threading-example---deformer">Maya API threading example - deformer</h2></div>
<p>The plug-in <span class='code'>splatDeformer</span> supplied with Maya is an example of a threaded deformer implementation. This example uses OpenMP rather than the Maya native API, since the focus here is on the approach taken to threading a deformer rather than the threading implementation itself, and OpenMP requires the least amount of additional code to implement threading.</p>
<p>The deformer is somewhat similar to a Maya sculpt deformer. A deforming mesh can be used to modify a selected mesh. The algorithm applies a deformation to every point on the mesh by snapping it to the closest point on the deforming object. The closest point operation is computationally intensive, and therefore is a good candidate for threading, unlike some simpler deformers where threading overhead is likely to outweigh any potential benefit.</p>
<p>Here are some items of note in this implementation:</p>
<ul>
<li>Note that all DG access is performed outside the threaded region. This is because DG access is generally not threadsafe, although there are exceptions (see section <a href='#!/url=./developer/Multithreading-plug-ins/Threading-and-Maya.html#threadsafe-maya-api-methods-and-classes' title=''>Threadsafe Maya API methods and classes</a> below.)</li>
<li>All the elements are read into arrays using <span class='code'><a href="javascript:void(0)" data-symbol="MItGeometry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_it_geometry.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MItGeometry</a></span> rather than using the iterator to do the loop traversal. This again ensures we avoid DG access in threads, and also avoids the problem that it is difficult to thread an iterator (although it can be done with Intel&#39;s OpenMP <span class='code'>taskq</span> extension.)</li>
<li>There are fast methods on <span class='code'><a href="javascript:void(0)" data-symbol="MItGeometry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_it_geometry.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MItGeometry</a></span> that read and write all points in a single function call, <span class='code'>allPositions()</span> and <span class='code'>setAllPositions()</span>. These are much more efficient than querying and setting the points one by one. If you are working directly with points on an <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMesh</a></span> in Maya there are new methods <span class='code'>getRawPoints()</span> and <span class='code'>getRawNormals()</span> which are even faster as they return a const pointer directly to the internal data. Do not be tempted to cast away the const and modify the data in place via this pointer, as this will almost certainly lead to data corruption.</li>
<li>The closest point methods on <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMesh</a></span> are not threadsafe, and are also relatively inefficient for multiple evaluations of a fixed mesh. The class <span class='code'><a href="javascript:void(0)" data-symbol="MMeshIntersector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_mesh_intersector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_mesh_intersector.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MMeshIntersector</a></span> uses a cached tree traversal so is much faster, and is also threadsafe. The intersector is set up and initialized outside the loop, then evaluated inside the loop to get the full parallelism benefit.</li>
<li>The <span class='code'>meshPoint</span> object must be allocated inside the loop so it is created on the current thread&#39;s stack. Allocating the object outside the loop would cause race conditions. Inadvertently writing to variables that were declared outside the loop is a common problem when trying to add threading to code that was not initially threaded, and great care must be taken to track all such variables down. It is good practice to declare variables in as local a scope as possible and avoid the practice of declaring variables at the top of a function anyway, and the fact that it makes any potential threading work easier in future is an additional benefit. It is also worth declaring any variables before the loop as const where possible, so write access to these variables from within the loop can be caught at compile time.</li>
<li>The values are read from a shared array and written into a shared array so there is some risk of cache misses on reads and false sharing on writes. However the default OpenMP traversal scheme for a loop like this would be to have the first thread evaluate the first (nPoints/nThreads) elements and other threads evaluate equal sized contiguous chunks. This access pattern minimizes both cache misses and false sharing.</li>
<li>If one of the closest point operations fails, the evaluator does not immediately abort, but instead sets a bad status flag and skips remaining iterations. In this specific case it is because OpenMP does not permit break calls from inside a threaded region. However it is often the easiest approach in general, compared with attempting to abort other threads that are in mid-evaluation.</li>
<li>After the threaded region, the iterator is used to write the values back into the output object.</li>
</ul>
<p>Scalability is limited by the serial portion of the code. For this reason it is important to optimize the code outside the threaded region. So for example it is best to get and set data in as large chunks as possible from the DG. This minimizes DG overhead. Several methods were added to <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMesh</a></span> to allow the user to retrieve all components of various types in a single operation, specifically for this purpose. The danger of course is increased memory usage, as these arrays must be maintained for the duration of the compute method compared with the iterator approach that updates one element at a time in place. The method <span class='code'>MFnMesh::getRawPoints</span> provides maximum speed and avoids memory overhead by returning a pointer directly to the internal data.</p>
<p>Some deformers cache their weights in the datablock. Reading from the datablock is slow and potentially not threadsafe. Often deformer weights do not change from frame to frame anyway, so in such cases it is best to read the weights once and store them in local arrays within the deformer class, then do the threaded deformer evaluation using those cached weight values.</p>
<div class='section'><a id="initializing-singleton-objects-in-maya-plug-ins"></a><h2 id="initializing-singleton-objects-in-maya-plug-ins">Initializing singleton objects in Maya plug-ins</h2></div>
<p>A common coding pattern is creation of a singleton object, perhaps initializing global data for a solver. Usually this is a very simple operation:</p>
<div class="codeBlock"><pre class="prettyprint">static solver* singleton = 0
if (singleton == 0) {
   singleton = new Solver();
}

</pre></div><p>However when it comes to threaded code it becomes a very challenging problem, and entire papers have been written on the best approach to implementing this pattern, the problem being that optimizers often reorder code to break apparently threadsafe implementations. An obvious solution is to use a lock, but that is a heavyweight operation that is only really required on first construction.</p>
<p>In general, if the overhead of the initialization is not too large, it is best to put it into the <span class='code'>initialize()</span> method of the plug-in, which can be guaranteed to run serially.</p>
<p>If the object is large or expensive to construct, or the plug-in is not always executed, it is preferable to use lazy evaluation and initialize the object only when required. If this is the case, here is an implementation that may be helpful. It makes use of the <span class='code'><a href="javascript:void(0)" data-symbol="MAtomic" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic</a></span> API class supplied with Maya:</p>
<div class="codeBlock"><pre class="prettyprint">static Solver* singleton = 0
if (singleton == 0) {
    Solver* solver = new Solver();
    if(!<a href="javascript:void(0)" data-symbol="MAtomic::compareAndSwap" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#ada84e1d5fb08e43440e14bff2793fb69&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::compareAndSwap</a>(&amp;singleton, 0, solver)) {
       delete solver;
    }
}

</pre></div><p>On invocation, multiple threads enter the <strong>if</strong> condition and potentially create multiple solvers at the same time. The first thread to reach the <span class='code'>compareAndSwap</span> sets the <span class='code'>solverSingleton</span> pointer to the address of the new solver, and all subsequent threads delete their solver instances once they finish creating them. Although this seems disturbingly wasteful at first glance, it is actually very efficient, because the performance hit is taken just once on startup, but all subsequent calls to the code just do a simple pointer compare, with no locking at all required.</p>
<p>If it is unsafe to have multiple threads in the Solver constructor, here is an alternative template to start from:</p>
<div class="codeBlock"><pre class="prettyprint">static Solver* singleton = 0
static int doneInit=0;
if(<a href="javascript:void(0)" data-symbol="MAtomic::compareAndSwap" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_atomic.html#ada84e1d5fb08e43440e14bff2793fb69&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAtomic::compareAndSwap</a>(&amp;doneInit, 0, 1)) {
    singleton = new Solver();
    doneInit = 2;
}
while(doneInit != 2) {}; // spin-wait

</pre></div><p>This code ensures the solver is only initialized once. To prevent other threads from accessing the object after the constructor has initialized the <span class='code'>solver</span> pointer but before it has finished its work, a spin-wait loop is applied that is not exited until the object has been fully initialized. The downside is that this approach requires an atomic operation and at least one traversal of the while loop for every subsequent call. There is also some concern about the compiler reordering the <span class='code'>doneInit=2</span> line to above the constructor, so an additional lock around the solver constructor call may be required to ensure this is avoided.</p>
<p>This is a good illustration of how even simple tasks can become tricky in a threaded environment.</p>
<div class='section'><a id="threadsafe-maya-api-methods-and-classes"></a><h2 id="threadsafe-maya-api-methods-and-classes">Threadsafe Maya API methods and classes</h2></div>
<p>The Maya API is very extensive, and it is not possible at this point to document every function and class to indicate whether it is threadsafe. This section focuses on some of the key classes that users are likely to want to call from threaded code.</p>
<p>Unfortunately it is not safe to make any assumptions about which methods may be threadsafe. Unless the function is inline and can be checked directly, there is always the risk that code may not be threadsafe. Even query methods may occasionally be unsafe as their classes may store internal state that is modified by the query.</p>
<p>Some classes rely on lazy evaluation so certain methods must be &quot;primed&quot; by calling them once outside a threaded region to update the internal data structure. For example, <span class='code'>MFnMesh::getVertexNormal</span> will first check to ensure the normals are up to date, and if they are not, it will recompute them. Thus two simultaneous calls to this function when the normals are not up to date will be unsafe. However once one call has been made and the internal data structures are updated, subsequent calls are threadsafe as long as the object has not been modified since the initial priming call.</p>
<div class='section'><a id="threadsafe-classes"></a><h3 id="threadsafe-classes">Threadsafe classes</h3></div>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPoint" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_point.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_point.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPoint</a></span>/<span class='code'><a href="javascript:void(0)" data-symbol="MFloatPoint" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_float_point.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_float_point.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFloatPoint</a></span>/<span class='code'><a href="javascript:void(0)" data-symbol="MVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_vector.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVector</a></span>/<span class='code'><a href="javascript:void(0)" data-symbol="MFloatVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_float_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_float_vector.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFloatVector</a></span>/<span class='code'><a href="javascript:void(0)" data-symbol="MMatrix" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_matrix.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_matrix.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MMatrix</a></span>
<ul>
<li>All read-only methods, no write methods.</li>
</ul></li>
<li><p><span class='code'>M*Array</span> container classes</p>
<p>Array classes are safe for read access. For writes, the <span class='code'>set()</span> methods are safe as they do not resize the array. However <span class='code'>append()</span>, <span class='code'>insert()</span>, <span class='code'>remove()</span> are not safe as they potentially resize the array.</p></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMesh</a></span>
<ul>
<li>closestPoint/intersection methods are NOT threadsafe.</li>
<li>get* and numNormals methods are safe once they have been primed.</li>
<li>getRawPoints/getRawNormals are threadsafe.</li>
</ul></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MMeshIntersector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_mesh_intersector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_mesh_intersector.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MMeshIntersector</a></span> is threadsafe.</li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MDataHandle" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_data_handle.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_data_handle.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDataHandle</a></span> - methods can not in general be assumed to be threadsafe.</p>
<ul>
<li><span class='code'>asXXX()</span> calls are safe since they just return pointers to the data referenced by the handle without worrying about whether they are clean or not (which is also the least common thing to do when reading data).</li>
<li><span class='code'>asGenericXXX()</span> calls are not safe since they use the read/write reference counting to get at <span class='code'>Tdata</span> information.</li>
</ul>
<p>The context is important too - if you just have a bunch of <span class='code'><a href="javascript:void(0)" data-symbol="MDataHandle" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_data_handle.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_data_handle.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDataHandle</a></span> objects lying around then you have already done the thread-unsafe part of extracting them from the datablock. The first level of danger is that the datablocks may not exist at all yet since they are lazily created so you have to make sure only one thread does that. The second level is when you are getting handles for the purpose of reading data the datablock may trigger an evaluation (if you use the <span class='code'>inputValue</span>(...) methods) which has its own thread safety issues.</p>
<p>The safest algorithm for doing a compute would be:</p>
<ol>
<li>Get all input <span class='code'>MDataHandles</span>.</li>
<li>PARALLEL( Get all input values from unique handles )</li>
<li>Perform the computation (in parallel if possible)</li>
<li>PARALLEL( Put all output values into handles )</li>
<li>PARALLEL( Get any output values of interest, in any order, not necessarily unique)</li>
</ol></li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MArrayDataHandle" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_array_data_handle.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_array_data_handle.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArrayDataHandle</a></span></p>
<p>This class maintains internal state since it is effectively a smart pointer into the datablock, so there are obvious dangers in using the same handle in multiple threads. Multiple threads making calls in parallel to <span class='code'>jumpToElement()</span> followed by query calls will not be threadsafe.</p></li>
</ul>
<div class='section'><a id="non-threadsafe-functionality"></a><h3 id="non-threadsafe-functionality">Non-threadsafe functionality</h3></div>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnNurbsCurve" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNurbsCurve</a></span> evaluation, for example, point on curve computation</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnNurbsSurface" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_nurbs_surface.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNurbsSurface</a></span> evaluation, for example, point on surface computation</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnSubd" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_subd.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnSubd</a></span> evaluation</li>
</ul>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
