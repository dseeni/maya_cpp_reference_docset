<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../scripts/utils/adsk.redirect.js"></script>
      <title>MPxGPUDeformer Class Reference</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_px_g_p_u_deformer.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>MPxGPUDeformer Class Reference</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/files.html"><span>Files</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="#!/url=./cpp_ref/classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="#!/url=./cpp_ref/hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="#!/url=./cpp_ref/functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  
  <div class="headertitle">
<div class="title">MPxGPUDeformer Class Reference<div class="ingroups"><a class="el" translate="no" href="#!/url=./cpp_ref/group___open_maya_anim.html">OpenMayaAnim - API module for animation</a> &#124; <a class="el" translate="no" href="#!/url=./cpp_ref/group___m_px.html">Proxy classes</a></div></div>  </div>
<div id="OverviewLinksDiv"><div id="dynsection-overview" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><img id="dynsection-overview-trigger" src="cpp_ref/closed.png" alt="+"> Related help topics: </div><div id="dynsection-overview-content" class="dyncontent" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-Maya-API-in-2018/What-s-New-in-the-Animation-API.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in Maya API in 2018 &gt; What&#39;s New in the Animation API</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016 Extension 2</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2/C-API-Changes-in-Maya-2016.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016 &gt; C++ API Changes in Maya 2016</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_px_g_p_u_deformer.html#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_px_g_p_u_deformer.html#pub-static-methods">Static Public Member Functions</a>  </div></div><!--header-->
<div class="contents">

<p><code>#include &lt;MPxGPUDeformer.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><p>Base class for user defined GPU deformer override evaluators. </p>
<p><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> lets you create user-defined GPU deformer overrides. A GPU deformer override replaces the CPU implementation of a deformer node when the evaluation manager is enabled and the deformerEvaluator plug-in is enabled. Use <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> to override the deformation for a Maya deformer or for a plug-in deformer implemented through <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_deformer_node.html" title="Base class for user defined deformers with per-vertex weights. ">MPxDeformerNode</a>. <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> must register which node type it overrides using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_registry.html" title="Registration class for MPxGPUDeformer. ">MGPUDeformerRegistry</a>.</p>
<p><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> defines a deformer node as a node which has input geometry and output geometry. <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> assumes that the number of vertices in the input and output geometry of a deformer node are the same. This definition includes nodes which are traditionally thought of as deformer nodes, such as skinCluster or blendShape, but also includes nodes like groupParts, which may be part of deformation chains.</p>
<p>To ensure optimal performance when you implement <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a>, keep the following in mind: </p><ul>
<li>Calls to the constructor must be fast. Do not do heavy work in the constructor because the deformer evaluator may allocate <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> instances which are never used. Save heavy work for the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a> method. </li>
<li>Cache needed values on the graphics card during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a>. Use the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_evaluation_node.html" title="Provides access to Evaluation Manager node information. ">MEvaluationNode</a> interface to determine if input values are constant or change over time.</li>
</ul>
<p>If you use this interface, you must implement the virtual method <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a> for <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> to function. See the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a> documentation for additional requirements on the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a> method. The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a74a45d2648335936561898c390281a6a" title="This method is called when the GPU deformer is being destroyed. ">terminate()</a> method is optional.</p>
<p><b>About the deformer evaluator:</b></p>
<p>The deformer evaluator identifies chains of supported nodes terminated by a mesh. The deformer evaluator then replaces CPU evaluation of these nodes with GPGPU kernels. The final deformed geometry is directly shared with Viewport 2.0, which avoids any GPU read back. When you implement an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> for a given node type, you expand the list of deformer evaluator supported nodes, which then allows more deformer chains to execute on the GPU.</p>
<p>A deformer chain is created by identifying an animated display mesh and then following geometry connections upstream until a source plug, that meets any one of the following criteria, is reached: </p><ul>
<li>On a node not supported by deformer evaluator. </li>
<li>On a node which does not depend on time. </li>
<li>Contains fan out connections.</li>
</ul>
<p>When one of the preceding conditions is true for a source plug, that source plug is considered the <em>input</em> to the deformation chain, and the corresponding source plug node is not evaluated in the deformer evaluator.</p>
<p>Example Chains: </p><ul>
<li>HistoryNode: any node (supported or unsupported) which does not depend on time. </li>
<li>origMesh: the original mesh shape: the ultimate source of the deformation chain. </li>
<li>SupportedNode: a node that the deformer evaluator explicitly supports that also depends on time. </li>
<li>UnsupportedNode: any node that the deformer evaluator does not support that also depends on time.</li>
</ul>
<p><b>Example 1:</b> </p><ul>
<li>HistoryNode1 -&gt; origMesh -&gt; HistoryNode2 -&gt; SupportedNode1 -&gt; SupportedNode1 -&gt; displayMesh</li>
</ul>
<p>When the deformer evaluator initializes it identifies HistoryNode2.outputData as the source plug. The first time that the deformer evaluator runs on example 1, the HistoryNode2 geometry output is copied to the GPU. SupportedNode1 and SupportedNode2 then run kernels to perform the deformations, and the final deformed result is then shared with VP2. Subsequent evaluations re-use the copy of HistoryNode2 output geometry already on the GPU, which avoids expensive data transfer.</p>
<p><b>Example 2:</b> </p><ul>
<li>HistoryNode1 -&gt; origMesh -&gt; HistoryNode2 -&gt; UnsupportedNode1 -&gt; SupportedNode1 -&gt; displayMesh</li>
</ul>
<p>In this scenario, UnsupportedNode1 runs on the CPU and generates an intermediate result. This intermediate result is copied to the GPU. Once copied, SupportedNode1 runs its kernel and displayMesh shares data with VP2. The intermediate result is copied to the GPU every frame, resulting in slower performance.</p>
<p><b>Example 3:</b> </p><ul>
<li>HistoryNode1-&gt; origMesh -&gt; HistoryNode2 -&gt; SupportedNode1 -&gt; UnsupportedNode1 -&gt; displayMesh</li>
</ul>
<p>In this scenario, the deformer evaluator does nothing. If we performed SupportedNode1's deformation on the GPU, we would need to read back that data and use it as an input for UnsupportedNode1 on the CPU. Read back is not supported by the deformer evaluator.</p>
<p><b>Example 4:</b> </p><ul>
<li>origMesh1 -&gt; SupportedNode1.outMesh[0] -&gt; displayMesh1 </li>
<li>origMesh2 -&gt; SupportedNode1.outMesh[1] -&gt; displayMesh2</li>
</ul>
<p>In this scenario, the deformer evaluator creates two chains, one for displayMesh1 and a second for displayMesh2. These chains both run on the GPU. Note that if SupportedNode1 is derived from <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_deformer_node.html" title="Base class for user defined deformers with per-vertex weights. ">MPxDeformerNode</a>, then there can be zero relationship between the mesh data used in displayMesh1 and displayMesh2. displayMesh1 could have 100 vertices, and displayMesh2 could have one million vertices.</p>
<p><b>Example 5:</b> </p><ul>
<li>origMesh1 -&gt; SupportedNode1.outMesh[0] -&gt; displayMesh1 </li>
<li>origMesh2 -&gt; SupportedNode1.outMesh[1] -&gt; UnsupportedNode1 -&gt;displayMesh2</li>
</ul>
<p>In this scenario, the deformer evaluator does nothing. We do support the first chain for displayMesh1, but we do not support the chain for displayMesh2. The deformer evaluator does not support the partial override of a node. In this case, SupportedNode1 has only partial support because the deformer evaluator can override evaluation for outMesh[0] but not for outMesh[1]. This prevents deformer evaluator from doing any GPU work in this scenario.</p>
<p>The deformer evaluator allocates a unique <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> object for each supported node in each supported chain. In Example 4, two <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a> objects are allocated for SupportedNode1, one for multi-element 0 and a second for multi-element 1.</p>
<p>The deformer evaluator's emphasis on avoiding geometry read back from the GPU means that unsupported nodes that follow a deformation chain exclude that chain from GPU evaluation. </p>
<dl class="section "><div id="dynsection-example0" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example0-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example0-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/identity_node_2identity_node_8cpp-example.html#_a13">identityNode/identityNode.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/offset_node_2offset_node_8cpp-example.html#_a34">offsetNode/offsetNode.cpp</a>.</dd></div>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdd7b10161b08897a80214a9e03cbc57"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="anchor" id="abdd7b10161b08897a80214a9e03cbc57"></a>
&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#abdd7b10161b08897a80214a9e03cbc57">MPxGPUDeformer</a> ()</td></tr>
<tr class="memdesc:abdd7b10161b08897a80214a9e03cbc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html" title="Base class for user defined GPU deformer override evaluators. ">MPxGPUDeformer</a>. <br></td></tr>
<tr class="separator:abdd7b10161b08897a80214a9e03cbc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc8b4a4be9364b5c2c17806eea85f63"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="anchor" id="a0cc8b4a4be9364b5c2c17806eea85f63"></a>
virtual&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a0cc8b4a4be9364b5c2c17806eea85f63">~MPxGPUDeformer</a> ()</td></tr>
<tr class="memdesc:a0cc8b4a4be9364b5c2c17806eea85f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr class="separator:a0cc8b4a4be9364b5c2c17806eea85f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070259639bc552fd702c9e8e042f0331"><td class="memItemLeft" translate="no" align="right" valign="top">virtual DeformerStatus&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331">evaluate</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a> &amp;block, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a> &amp;evaluationNode, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;outputPlug, unsigned int numElements, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_auto_c_l_mem.html">MAutoCLMem</a>, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_auto_c_l_event.html">MAutoCLEvent</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_auto_c_l_mem.html">MAutoCLMem</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_auto_c_l_event.html">MAutoCLEvent</a> &amp;)</td></tr>
<tr class="memdesc:a070259639bc552fd702c9e8e042f0331"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is deprecated and should no longer be used.  <a href="class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331">More...</a><br></td></tr>
<tr class="separator:a070259639bc552fd702c9e8e042f0331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a45d2648335936561898c390281a6a"><td class="memItemLeft" translate="no" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a74a45d2648335936561898c390281a6a">terminate</a> ()</td></tr>
<tr class="memdesc:a74a45d2648335936561898c390281a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called when the GPU deformer is being destroyed.  <a href="class_m_px_g_p_u_deformer.html#a74a45d2648335936561898c390281a6a">More...</a><br></td></tr>
<tr class="separator:a74a45d2648335936561898c390281a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af684dd523a1adfe5f06de3e513e8146a"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html">MGPUDeformerBuffer</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#af684dd523a1adfe5f06de3e513e8146a">createOutputBuffer</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html">MGPUDeformerBuffer</a> &amp;inputBuffer)</td></tr>
<tr class="memdesc:af684dd523a1adfe5f06de3e513e8146a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates an output buffer based on inputBuffer.  <a href="class_m_px_g_p_u_deformer.html#af684dd523a1adfe5f06de3e513e8146a">More...</a><br></td></tr>
<tr class="separator:af684dd523a1adfe5f06de3e513e8146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abb7238dc52214c1b33a9c4000c1f237e"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#abb7238dc52214c1b33a9c4000c1f237e">hasAttributeBeenModified</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a> &amp;evaluationNode, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;attribute)</td></tr>
<tr class="memdesc:abb7238dc52214c1b33a9c4000c1f237e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if the data for attribute on the overridden deformation node has been modified since the last call to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">MPxGPUDeformer::evaluate()</a>.  <a href="class_m_px_g_p_u_deformer.html#abb7238dc52214c1b33a9c4000c1f237e">More...</a><br></td></tr>
<tr class="separator:abb7238dc52214c1b33a9c4000c1f237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a070259639bc552fd702c9e8e042f0331"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">MPxGPUDeformer::DeformerStatus evaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a> &amp;&#160;</td>
          <td class="paramname"><em>evaluationNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;&#160;</td>
          <td class="paramname"><em>outputPlug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_auto_c_l_mem.html">MAutoCLMem</a>&#160;</td>
          <td class="paramname"><em>inputPositionBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_auto_c_l_event.html">MAutoCLEvent</a>&#160;</td>
          <td class="paramname"><em>inputEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_auto_c_l_mem.html">MAutoCLMem</a>&#160;</td>
          <td class="paramname"><em>outputPositionBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_auto_c_l_event.html">MAutoCLEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>outputEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is deprecated and should no longer be used. </p>
<p>Instead use MPxGPUDeformer::evaluate(MdataBlock&amp;, const MEvaluationNode&amp;, const MPlug&amp;, const MGPUDeformerData&amp;, MGPUDeformerData&amp;). The provided implementation of this function returns kDeformerFailure. Derived classes should only implement one version of the evaluate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>The data block of the deformer node to be overridden. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evaluationNode</td><td>The evaluation node of the deformer to be overridden. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputPlug</td><td>The output plug of the deformer to be overridden. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of float3 elements in inputPositionBuffer and outputPositionBuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputPositionBuffer</td><td>The handle to the input positions on the GPU. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputEvent</td><td>The event that must be completed before it is safe to read values in inputPositionBuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputPositionBuffer</td><td>The handle of the output positions on the GPU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputEvent</td><td>The event which must be completed before it is safe to read outputPositionBuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>MPxGPUDeformer::kDeformerSuccess</b> if a kernel was successfully created and enqueued. </li>
<li><b>MPxGPUDeformer::kDeformerFailure</b> if no kernel can be created. </li>
<li><b>MPxGPUDeformer::kDeformerRetryMainThread</b> if <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a> requires access to the d3d/gl context. </li>
<li><b>MPxGPUDeformer::kDeformerPassThrough</b> if the inputPositionBuffer should be used as the inputPositionBuffer by the next deformer. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example1" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example1-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example1-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/identity_node_2identity_node_8cpp-example.html#a18">identityNode/identityNode.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/offset_node_2offset_node_8cpp-example.html#a35">offsetNode/offsetNode.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a74a45d2648335936561898c390281a6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called when the GPU deformer is being destroyed. </p>
<p>Any data stored on this object should be released. </p>
<dl class="section "><div id="dynsection-example2" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example2-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example2-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/identity_node_2identity_node_8cpp-example.html#a20">identityNode/identityNode.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/offset_node_2offset_node_8cpp-example.html#a39">offsetNode/offsetNode.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="af684dd523a1adfe5f06de3e513e8146a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html">MGPUDeformerBuffer</a> createOutputBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html">MGPUDeformerBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>inputBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method creates an output buffer based on inputBuffer. </p>
<p>If inputBuffer is read only then the returned <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html" title="Store GPU Representation of a data buffer. ">MGPUDeformerBuffer</a> will be backed by a different cl_mem object large enough to hold the data stored in inputBuffer. If inputBuffer is writable then the returned <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html" title="Store GPU Representation of a data buffer. ">MGPUDeformerBuffer</a> is backed by the same cl_mem as inputBuffer. The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html" title="Store GPU Representation of a data buffer. ">MGPUDeformerBuffer</a> returned by <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#af684dd523a1adfe5f06de3e513e8146a" title="This method creates an output buffer based on inputBuffer. ">createOutputBuffer()</a> is never read only.</p>
<p>It is not safe to hold the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html" title="Store GPU Representation of a data buffer. ">MGPUDeformerBuffer</a> returned by createOutputBuffer after the end of the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a> call. It is not safe to hold a reference to the cl_mem underlying an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html" title="Store GPU Representation of a data buffer. ">MGPUDeformerBuffer</a> after the end of the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a> call.</p>
<p>createOutputBuffer uses a pool of cl_mem objects to fulfill requests for output buffers. This avoids allocating a new writable cl_mem object each time the deformation chain is evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputBuffer</td><td>The input version of the buffer we would like to create an output buffer for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_g_p_u_deformer_buffer.html" title="Store GPU Representation of a data buffer. ">MGPUDeformerBuffer</a> to be used as an output buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="abb7238dc52214c1b33a9c4000c1f237e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool hasAttributeBeenModified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a> &amp;&#160;</td>
          <td class="paramname"><em>evaluationNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns true if the data for attribute on the overridden deformation node has been modified since the last call to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">MPxGPUDeformer::evaluate()</a>. </p>
<p>hasAttributeBeenModified returning true may indicate that the attribute is animated or that the attribute has been interactively changed.</p>
<dl class="section note"><dt>Note</dt><dd>hasAttributeBeenModified stores the top-most array/parent of the plug tree in which given attribute exists in exactly the same way <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_evaluation_node.html#abc632b073f3b3abeb4ca052f20573dd6" title="Returns true if the specified attribute has a dirty plug. ">MEvaluationNode::dirtyPlugExists()</a> does.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evaluationNode</td><td>The evaluation node of the deformer which is overridden. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute</td><td>The attribute to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the attribute has changed since the last call to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_px_g_p_u_deformer.html#a070259639bc552fd702c9e8e042f0331" title="This method is deprecated and should no longer be used. ">evaluate()</a>. </dd></dl>
<dl class="section "><div id="dynsection-example3" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example3-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example3-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/offset_node_2offset_node_8cpp-example.html#a67">offsetNode/offsetNode.cpp</a>.</dd></div>
</dl>
</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MPxGPUDeformer.h</li>
<li>MPxGPUDeformer.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
