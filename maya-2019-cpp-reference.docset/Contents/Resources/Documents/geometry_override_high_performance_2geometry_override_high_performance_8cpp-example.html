<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><script src="../scripts/utils/adsk.redirect.js" type="text/javascript"></script>
<title>geometryOverrideHighPerformance/geometryOverrideHighPerformance.cpp</title>
<meta content="C++" name="topic-subtype"/></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"/><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('geometry_override_high_performance_2geometry_override_high_performance_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>geometryOverrideHighPerformance/geometryOverrideHighPerformance.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./files.html"><span>Files</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">geometryOverrideHighPerformance/geometryOverrideHighPerformance.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">// Copyright 2018 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk</span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download,</span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic</span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This plug-in shows how to use MPxGeometryOverride to render geometry with the best performance </span></div>
<div class="line"><span class="comment">// as possible. It will register a new type of node "geometryOverrideHighPerformance_shape" and associate it to </span></div>
<div class="line"><span class="comment">// a MPxGeometryOverride.</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// The GeometryOverrideHighPerformance_shape class derives from MPxSurfaceShape and add two attributes to the node.</span></div>
<div class="line"><span class="comment">// The first attribute is the size of the shape that will be used by the geometry override to scale </span></div>
<div class="line"><span class="comment">// the vertex position data. The second attribute is a input mesh that will be use by the geometry </span></div>
<div class="line"><span class="comment">// override to render. The GeometryOverrideHighPerformance_shape also enable the shape to be selectable in</span></div>
<div class="line"><span class="comment">// Viewport 2.0.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The GeometryOverrideHighPerformance class derives from MPxGeometryOverride and shows how to</span></div>
<div class="line"><span class="comment">// create / update different render items and fill vertex / index buffers to render the geometry </span></div>
<div class="line"><span class="comment">// of geometryOverrideHighPerformance_shape. This class try to be smart as possible to only update the geometry</span></div>
<div class="line"><span class="comment">// data as needed.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This plugin uses two different techniques to optimize the performance of the GeometryOverrideHighPerformance_shape</span></div>
<div class="line"><span class="comment">// draw in VP2.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Technique 1:</span></div>
<div class="line"><span class="comment">// In order to know when the GeometryOverrideHighPerformance render items need to be updated</span></div>
<div class="line"><span class="comment">// the factors affecting how render items are drawn are stored.  When updateRenderItems()</span></div>
<div class="line"><span class="comment">// is called the current values can be compared against the previously used values,</span></div>
<div class="line"><span class="comment">// allowing Maya to call updateRenderItems() only when necessary.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Technique 2:</span></div>
<div class="line"><span class="comment">// In order to know when the GeometryOverrideHighPerformance geometry needs to be updated the</span></div>
<div class="line"><span class="comment">// GeometryOverrideHighPerformance_shape node look into dirty propagation and the evaluation manager </span></div>
<div class="line"><span class="comment">// to track when attributes which affect geometry change.  GeometryOverrideHighPerformance can then query</span></div>
<div class="line"><span class="comment">// GeometryOverrideHighPerformance_shape to find out if a geometry update is necessary.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Evaluation Manager Parallel Update:</span></div>
<div class="line"><span class="comment">// This plugin enable the Evaluation Manager Parallel Update by returning true from</span></div>
<div class="line"><span class="comment">// supportsEvaluationManagerParallelUpdate(). Evaluation Manager Parallel Update is a </span></div>
<div class="line"><span class="comment">// performance optimization which allows the updateDG() and populateGeometry() step </span></div>
<div class="line"><span class="comment">// of the draw preparation to occur during Evaluation Graph Execution rather than during </span></div>
<div class="line"><span class="comment">// VP2 refresh. That's means the Maya nodes begin preparing render data for </span></div>
<div class="line"><span class="comment">// VP2 immediately after a node is evaluated, and before the rest of the graph has </span></div>
<div class="line"><span class="comment">// finished evaluation. This improves performance by allowing updateDG() and </span></div>
<div class="line"><span class="comment">// populateGeometry() calls of several plug-ins to run in parallel with each other </span></div>
<div class="line"><span class="comment">// and with Evaluation Manager dependency graph evaluation.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Evaluation Caching:</span></div>
<div class="line"><span class="comment">// GeometryOverrideHighPerformance is fully compatible with Evaluation Caching. Supporting Evaluation Caching</span></div>
<div class="line"><span class="comment">// adds some additional, subtle requirements on the plug-in node. Evaluation Caching</span></div>
<div class="line"><span class="comment">// automatically caches  data for two types of attributes: output attributes and dynamic</span></div>
<div class="line"><span class="comment">// attributes, where output attributes are defined as any attribute which is affected by</span></div>
<div class="line"><span class="comment">// another attribute on the node.  The affects relationship can be created either by</span></div>
<div class="line"><span class="comment">// calling MPxNode::attributeAffects() or by returning affected attributes from</span></div>
<div class="line"><span class="comment">// MPxNode::setDependentsDirty().</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// By default, Maya doesn't add a custom shape (MPxSurfaceShape) into the cache system.</span></div>
<div class="line"><span class="comment">// So, that means we need to add the node type into the system ourselves</span></div>
<div class="line"><span class="comment">// with mel command. See geometryOverrideHighPerformance.mel.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Using Evaluation Caching with Evaluation Manager Parallel Update has an additional issue</span></div>
<div class="line"><span class="comment">// to be aware of.  When using Evaluation Manager Parallel Update some MPxGeometryOverride</span></div>
<div class="line"><span class="comment">// methods are called after the corresponding DAG node has been evaluated but before the </span></div>
<div class="line"><span class="comment">// full evaluation graph has been evaluated.  When Evaluation Caching is enabled only</span></div>
<div class="line"><span class="comment">// cached DG values may be read before the full evaluation graph has been evaluated.  Therefore,</span></div>
<div class="line"><span class="comment">// when using Evaluation Manager Parallel Update and Evaluation Caching only cached DG values </span></div>
<div class="line"><span class="comment">// may be read.  Attempting to read an uncached value before evaluation finishes results in </span></div>
<div class="line"><span class="comment">// undefined behavior (incorrect data or crashes).</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// VP2 Custom Caching:</span></div>
<div class="line"><span class="comment">// GeometryOverrideHighPerformance is fully compatible with VP2 Custom Caching.  When using VP2</span></div>
<div class="line"><span class="comment">// custom caching the MPxGeometryOverride may be invoked in the normal context or in a </span></div>
<div class="line"><span class="comment">// background thread using another context.  If playback and background evaluation occur</span></div>
<div class="line"><span class="comment">// concurrently Maya guarantees that all of the MPxGeoemtryOverride methods called for a</span></div>
<div class="line"><span class="comment">// context occur atomically without being interleaved with MPxGeometryOverride methods</span></div>
<div class="line"><span class="comment">// for the same DAG object in a different context.</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// To use this plug-in run the following mel or python commands once the plugin is loaded</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Mel script:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      //</span></div>
<div class="line"><span class="comment">//      // Add the geometryOverrideHighPerformance_shape node type in evaluation caching </span></div>
<div class="line"><span class="comment">//      //</span></div>
<div class="line"><span class="comment">//      cacheEvaluator -newFilter "nodeTypes"</span></div>
<div class="line"><span class="comment">//                     -newFilterParam "types=+geometryOverrideHighPerformance_shape" </span></div>
<div class="line"><span class="comment">//                     -newAction "enableEvaluationCache";</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      //</span></div>
<div class="line"><span class="comment">//      // Add geometryOverrideHighPerformance_shape node type in VP2 SW Cache</span></div>
<div class="line"><span class="comment">//      //             </span></div>
<div class="line"><span class="comment">//      cacheEvaluator -newFilter "nodeTypes" </span></div>
<div class="line"><span class="comment">//                     -newFilterParam "types=+geometryOverrideHighPerformance_shape"                </span></div>
<div class="line"><span class="comment">//                     -newAction "enableVP2Cache" </span></div>
<div class="line"><span class="comment">//                     -newActionParam "useHardware=0";</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      //</span></div>
<div class="line"><span class="comment">//      // Add geometryOverrideHighPerformance_shape node type in VP2 HW Cache</span></div>
<div class="line"><span class="comment">//      //                         </span></div>
<div class="line"><span class="comment">//      cacheEvaluator -newFilter "nodeTypes" </span></div>
<div class="line"><span class="comment">//                     -newFilterParam "types=+geometryOverrideHighPerformance_shape"                </span></div>
<div class="line"><span class="comment">//                     -newAction "enableVP2Cache" </span></div>
<div class="line"><span class="comment">//                     -newActionParam "useHardware=1";</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      $shapeNodeName = `createNode geometryOverrideHighPerformance_shape`;</span></div>
<div class="line"><span class="comment">//      sets -add initialShadingGroup $shapeNodeName;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Python script:</span></div>
<div class="line"><span class="comment">//      </span></div>
<div class="line"><span class="comment">//      maya.cmds.cacheEvaluator(newFilter="nodeTypes", newFilterParam = "types=+geometryOverrideHighPerformance_shape" , newAction = "enableEvaluationCache")</span></div>
<div class="line"><span class="comment">//      maya.cmds.cacheEvaluator(newFilter="nodeTypes", newFilterParam = "types=+geometryOverrideHighPerformance_shape" , newAction = "enableVP2Cache", newActionParam = "useHardware=0")</span></div>
<div class="line"><span class="comment">//      maya.cmds.cacheEvaluator(newFilter="nodeTypes", newFilterParam = "types=+geometryOverrideHighPerformance_shape" , newAction = "enableVP2Cache", newActionParam = "useHardware=1")</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      shapeNodeName = maya.cmds.createNode('geometryOverrideHighPerformance_shape')</span></div>
<div class="line"><span class="comment">//      maya.cmds.sets(shapeNodeName, add = 'initialShadingGroup')</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Or run the geometryOverrideHighPerformance_shape.mel</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="preprocessor">#include "geometryOverrideHighPerformance.h"</span></div>
<div class="line"><span class="preprocessor">#include "geometryOverrideHighPerformanceHelper.h"</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnPlugin.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawRegistry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MShaderManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSelectionMask.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MEvaluationNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDependencyNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDagNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDistance.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnUnitAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNumericAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnTypedAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlugArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGeometryExtractor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDGModifier.h&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> instancingChangedCallback(<a name="_a0"></a><a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; child, <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; parent, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line"> <a name="a1"></a><a class="code" href="./class_m_global.html#acb043e7fc4eb7fc0f39833d31364b8a4">MGlobal::displayWarning</a>(<span class="stringliteral">"GeometryOverrideHighPerformance does't support instancing !"</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              GeometryOverrideHighPerformance_shape implementation</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"></div>
<div class="line"><a name="_a2"></a><a class="code" href="./class_m_type_id.html">MTypeId</a> GeometryOverrideHighPerformance_shape::fsId = <a class="code" href="./class_m_type_id.html">MTypeId</a>(0x8003F);</div>
<div class="line"><a name="_a3"></a><a class="code" href="./class_m_object.html">MObject</a> GeometryOverrideHighPerformance_shape::fsSize;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> GeometryOverrideHighPerformance_shape::fsInputMesh;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> GeometryOverrideHighPerformance_shape::fsInputMeshBoundingBoxMin;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> GeometryOverrideHighPerformance_shape::fsInputMeshBoundingBoxMax;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> GeometryOverrideHighPerformance_shape::fsSizeChangedSinceVP2Update;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> GeometryOverrideHighPerformance_shape::fsInputMeshChanged;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> GeometryOverrideHighPerformance_shape::fsInputMeshGeoChanged;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> GeometryOverrideHighPerformance_shape::fsMaterialChanged;</div>
<div class="line">Float3Array  GeometryOverrideHighPerformance_shape::fPositions;</div>
<div class="line">Float3Array  GeometryOverrideHighPerformance_shape::fNormals;</div>
<div class="line">Float3Array  GeometryOverrideHighPerformance_shape::fTangents;</div>
<div class="line">Float3Array  GeometryOverrideHighPerformance_shape::fBiTangents;</div>
<div class="line">Float2Array  GeometryOverrideHighPerformance_shape::fTextureCoords;</div>
<div class="line">IndexList    GeometryOverrideHighPerformance_shape::fIndices;</div>
<div class="line"><a name="_a4"></a><a class="code" href="./class_m_bounding_box.html">MBoundingBox</a> GeometryOverrideHighPerformance_shape::fBoundingBox;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GeometryOverrideHighPerformance_shape::GeometryOverrideHighPerformance_shape()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a name="_a5"></a><a class="code" href="./class_m_status.html">MStatus</a>  GeometryOverrideHighPerformance_shape::initialize()</div>
<div class="line">{ </div>
<div class="line"> <a name="_a6"></a><a class="code" href="./class_m_fn_unit_attribute.html">MFnUnitAttribute</a> unitFn;</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a>          stat;</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create the size attribute</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    fsSize = unitFn.<a name="a7"></a><a class="code" href="./class_m_fn_unit_attribute.html#a31f804de81a968aa11b510a6231e7874">create</a>(<span class="stringliteral">"size"</span>, <span class="stringliteral">"sz"</span>, <a name="a8"></a><a class="code" href="./class_m_fn_unit_attribute.html#a1d1cfd8ffb84e947f82999c682b666a7a1925172d8d6f77cdb98f7f486f706024">MFnUnitAttribute::kDistance</a>);</div>
<div class="line">    unitFn.<a name="a9"></a><a class="code" href="./class_m_fn_unit_attribute.html#a02a46e1b4ae48c38d85678a8611e3e77">setDefault</a>(1.0);</div>
<div class="line"> </div>
<div class="line">    stat = addAttribute(fsSize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a name="a10"></a><a class="code" href="./class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">"Failed to create the size attribute !"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create the input mesh attribute</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a name="_a11"></a><a class="code" href="./class_m_fn_typed_attribute.html">MFnTypedAttribute</a> typedFn;</div>
<div class="line">    fsInputMesh = typedFn.<a name="a12"></a><a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">"inputMesh"</span>, <span class="stringliteral">"inm"</span>, <a name="a13"></a><a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62">MFnData::kMesh</a>, <a name="a14"></a><a class="code" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>);</div>
<div class="line">    stat = addAttribute(fsInputMesh);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="./class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">"Failed to create the inputMesh attribute !"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// bbox attributes</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a name="_a15"></a><a class="code" href="./class_m_fn_numeric_attribute.html">MFnNumericAttribute</a> numericAttributeFn;</div>
<div class="line">    fsInputMeshBoundingBoxMin = numericAttributeFn.<a name="a16"></a><a class="code" href="./class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">"inputBoundMin"</span>, <span class="stringliteral">"inbn"</span>, <a name="a17"></a><a class="code" href="./class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7add817d1d2e1e1d24ac2e2819a58e8f99">MFnNumericData::k3Double</a>, 0);</div>
<div class="line">    numericAttributeFn.<a name="a18"></a><a class="code" href="./class_m_fn_attribute.html#acc80b84249f9c028f2c6d085a026b50c">setArray</a>(<span class="keyword">false</span>);</div>
<div class="line">    numericAttributeFn.<a name="a19"></a><a class="code" href="./class_m_fn_attribute.html#a08fb5fd3764795485a0d799616646ef1">setUsesArrayDataBuilder</a>(<span class="keyword">false</span>);</div>
<div class="line">    numericAttributeFn.<a name="a20"></a><a class="code" href="./class_m_fn_attribute.html#ab8e48be1f1009a30d0e40dfcaf9e649d">setHidden</a>(<span class="keyword">false</span>);</div>
<div class="line">    numericAttributeFn.<a name="a21"></a><a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>(<span class="keyword">false</span>);</div>
<div class="line">    addAttribute(fsInputMeshBoundingBoxMin);</div>
<div class="line"></div>
<div class="line">    fsInputMeshBoundingBoxMax = numericAttributeFn.<a class="code" href="./class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">"inputBoundMax"</span>, <span class="stringliteral">"inbm"</span>, <a class="code" href="./class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7add817d1d2e1e1d24ac2e2819a58e8f99">MFnNumericData::k3Double</a>, 0);</div>
<div class="line">    numericAttributeFn.<a class="code" href="./class_m_fn_attribute.html#acc80b84249f9c028f2c6d085a026b50c">setArray</a>(<span class="keyword">false</span>);</div>
<div class="line">    numericAttributeFn.<a class="code" href="./class_m_fn_attribute.html#a08fb5fd3764795485a0d799616646ef1">setUsesArrayDataBuilder</a>(<span class="keyword">false</span>);</div>
<div class="line">    numericAttributeFn.<a class="code" href="./class_m_fn_attribute.html#ab8e48be1f1009a30d0e40dfcaf9e649d">setHidden</a>(<span class="keyword">false</span>);</div>
<div class="line">    numericAttributeFn.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>(<span class="keyword">false</span>);</div>
<div class="line">    addAttribute(fsInputMeshBoundingBoxMax);</div>
<div class="line"></div>
<div class="line">    attributeAffects(fsInputMeshBoundingBoxMin, <a name="a22"></a><a class="code" href="./class_m_px_surface_shape.html#a20781dbb7a5c1fc5d58365860247abc9">MPxSurfaceShape::nodeBoundingBoxMin</a>);</div>
<div class="line">    attributeAffects(fsInputMeshBoundingBoxMax, <a name="a23"></a><a class="code" href="./class_m_px_surface_shape.html#a561dd332a87a898ad27c45f8df63ce5e">MPxSurfaceShape::nodeBoundingBoxMax</a>);</div>
<div class="line">    attributeAffects(fsSize, <a class="code" href="./class_m_px_surface_shape.html#a20781dbb7a5c1fc5d58365860247abc9">MPxSurfaceShape::nodeBoundingBoxMin</a>);</div>
<div class="line">    attributeAffects(fsSize, <a class="code" href="./class_m_px_surface_shape.html#a561dd332a87a898ad27c45f8df63ce5e">MPxSurfaceShape::nodeBoundingBoxMax</a>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">    VP2 Custom Caching: When using VP2 custom caching the MPxGeometryOverride associated</span></div>
<div class="line"><span class="comment">    with the node might be invoked in the normal context or in the background</span></div>
<div class="line"><span class="comment">    context.  If playback and background evaluation occur concurrently Maya guarantees</span></div>
<div class="line"><span class="comment">    that all of the MPxGeometryOverride methods called for a context occur atomically</span></div>
<div class="line"><span class="comment">    without being interleaved with MPxGeometryOverride methods for the same object in</span></div>
<div class="line"><span class="comment">    a different context.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    However, Maya does not make any timing guarantee between the call(s) to evaluate the</span></div>
<div class="line"><span class="comment">    MPxNode and calls to the MPxGeometryOverride.  For example, a postEvaluation call</span></div>
<div class="line"><span class="comment">    in the background evaluation thread may occur at the same time that the foreground</span></div>
<div class="line"><span class="comment">    thread is using the MPxGeometryOverride.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    This means that any communication which occurs between the MPxNode during evaluation</span></div>
<div class="line"><span class="comment">    and the MPxGeometryOverride must be context aware.  The communication channel must</span></div>
<div class="line"><span class="comment">    use different storage for each context.  The easiest way to implement this to use</span></div>
<div class="line"><span class="comment">    internal attributes on the MPxNode that the MPxGeometryOverride has access to.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Don't create any affects relationships because those attribute doesn't use any </span></div>
<div class="line"><span class="comment">    Maya dirty management or evaluation.  They are used only by getting the MDataHandle </span></div>
<div class="line"><span class="comment">    directly from the MDataBlock using outputValue().</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"> <a class="code" href="./class_m_fn_numeric_attribute.html">MFnNumericAttribute</a> attrFn;</div>
<div class="line">    fsSizeChangedSinceVP2Update = attrFn.<a class="code" href="./class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">"sizeChangedSinceVP2Update"</span>, <span class="stringliteral">"sd"</span>, <a name="a24"></a><a class="code" href="./class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7a8cfc0ab572a96edfc9db7c02f0d025d7">MFnNumericData::kBoolean</a>, <span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a name="a25"></a><a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">false</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#ab8e48be1f1009a30d0e40dfcaf9e649d">setHidden</a>(<span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a name="a26"></a><a class="code" href="./class_m_fn_attribute.html#ab1986dcbce4e2fd86c5cb0bff5119dc0">setConnectable</a>(<span class="keyword">false</span>);</div>
<div class="line">    stat = addAttribute(fsSizeChangedSinceVP2Update);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="./class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">"Failed to create the sizeChangedSinceVP2Update attribute !"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    fsInputMeshChanged = attrFn.<a class="code" href="./class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">"inputMeshChangedSinceVP2Update"</span>, <span class="stringliteral">"imd"</span>, <a class="code" href="./class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7a8cfc0ab572a96edfc9db7c02f0d025d7">MFnNumericData::kBoolean</a>, <span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">false</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#ab8e48be1f1009a30d0e40dfcaf9e649d">setHidden</a>(<span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#ab1986dcbce4e2fd86c5cb0bff5119dc0">setConnectable</a>(<span class="keyword">false</span>);</div>
<div class="line">    stat = addAttribute(fsInputMeshChanged);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="./class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">"Failed to create the inputMeshChangedSinceVP2Update attribute !"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fsInputMeshGeoChanged = attrFn.<a class="code" href="./class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">"inputMeshGeoChangedSinceVP2Update"</span>, <span class="stringliteral">"img"</span>, <a class="code" href="./class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7a8cfc0ab572a96edfc9db7c02f0d025d7">MFnNumericData::kBoolean</a>, <span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">false</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#ab8e48be1f1009a30d0e40dfcaf9e649d">setHidden</a>(<span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#ab1986dcbce4e2fd86c5cb0bff5119dc0">setConnectable</a>(<span class="keyword">false</span>);</div>
<div class="line">    stat = addAttribute(fsInputMeshGeoChanged);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="./class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">"Failed to create the inputMeshGeoChangedSinceVP2Update attribute !"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    fsMaterialChanged = attrFn.<a class="code" href="./class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">"materialChangedSinceVP2Update"</span>, <span class="stringliteral">"mcd"</span>, <a class="code" href="./class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7a8cfc0ab572a96edfc9db7c02f0d025d7">MFnNumericData::kBoolean</a>, <span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">false</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#ab8e48be1f1009a30d0e40dfcaf9e649d">setHidden</a>(<span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a class="code" href="./class_m_fn_attribute.html#ab1986dcbce4e2fd86c5cb0bff5119dc0">setConnectable</a>(<span class="keyword">false</span>);</div>
<div class="line">    stat = addAttribute(fsMaterialChanged);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="./class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">"Failed to create the materialChangedSinceVP2Update attribute !"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">    }   </div>
<div class="line"></div>
<div class="line">    createSphere(1, 50, 50, </div>
<div class="line">                 GeometryOverrideHighPerformance_shape::fPositions, </div>
<div class="line">                 GeometryOverrideHighPerformance_shape::fNormals, </div>
<div class="line">                 GeometryOverrideHighPerformance_shape::fTangents, </div>
<div class="line">                 GeometryOverrideHighPerformance_shape::fBiTangents, </div>
<div class="line">                 GeometryOverrideHighPerformance_shape::fTextureCoords, </div>
<div class="line">                 GeometryOverrideHighPerformance_shape::fIndices, </div>
<div class="line">                 GeometryOverrideHighPerformance_shape::fBoundingBox);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GeometryOverrideHighPerformance_shape::~GeometryOverrideHighPerformance_shape()</div>
<div class="line">{</div>
<div class="line"> <a name="a27"></a><a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(mInstanceAddedCallbackId);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  When instances of this node are created internally, the MObject associated</span></div>
<div class="line"><span class="comment">//  with the instance is not created until after the constructor of this class</span></div>
<div class="line"><span class="comment">//  is called. This means that no member functions of MPxSurfaceShape can</span></div>
<div class="line"><span class="comment">//  be called in the constructor.</span></div>
<div class="line"><span class="comment">//  The postConstructor solves this problem. Maya will call this function</span></div>
<div class="line"><span class="comment">//  after the internal object has been created.</span></div>
<div class="line"><span class="comment">//  As a general rule do all of your initialization in the postConstructor.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxSurfaceShape::postConstructor()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance_shape::postConstructor()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// This call allows the shape to have shading groups assigned</span></div>
<div class="line">    setRenderable(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Add a callback that will be called when instance are added.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_dag_path.html">MDagPath</a> path;</div>
<div class="line"> <a name="a28"></a><a class="code" href="./class_m_dag_path.html#a422aa5ec02565f757c13fe2873ed25d7">MDagPath::getAPathTo</a>(thisMObject(), path);</div>
<div class="line">    mInstanceAddedCallbackId = <a name="a29"></a><a class="code" href="./class_m_dag_message.html#a9c301d5a30d9424eea522166b283a98d">MDagMessage::addInstanceAddedDagPathCallback</a>(const_cast&lt;MDagPath&amp;&gt;(path), &amp;instancingChangedCallback);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method is overriden to support interactive object selection in Viewport 2.0</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Returns The selection mask of the shaper.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxSurfaceShape::getShapeSelectionMask()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a name="_a30"></a><a class="code" href="./class_m_selection_mask.html">MSelectionMask</a>  GeometryOverrideHighPerformance_shape::getShapeSelectionMask()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879d">MSelectionMask::SelectionType</a> selType = <a name="a31"></a><a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da4e61eacbb5f904df37be9e14d36286b1">MSelectionMask::kSelectMeshes</a>;</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_selection_mask.html">MSelectionMask</a>(selType);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Returns the bounding box for this object.</span></div>
<div class="line"><span class="comment">//  It is a good idea not to recompute here as this funcion is called often.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : This function is only called if MPxSurfaceShape::isBounded() return true.</span></div>
<div class="line"><span class="comment">//         For more information, see MPxSurfaceShape::boundingBox()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a class="code" href="./class_m_bounding_box.html">MBoundingBox</a> GeometryOverrideHighPerformance_shape::boundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> thisNode = thisMObject();</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Get the value of the size attribute</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a name="_a32"></a><a class="code" href="./class_m_plug.html">MPlug</a> sizePlug(thisNode, fsSize);</div>
<div class="line"> <a name="_a33"></a><a class="code" href="./class_m_distance.html">MDistance</a> sizeVal;</div>
<div class="line">    sizePlug.getValue(sizeVal);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> multiplier = sizeVal.<a name="a34"></a><a class="code" href="./class_m_distance.html#ace39ab92685b0f5ab1a2925e748efb1f">asCentimeters</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Return the scaled input mesh bounding box if there is a input </span></div>
<div class="line"> <span class="comment">// mesh connected to the node</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span>(fUseInputMesh)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a35"></a><a class="code" href="./class_m_data_block.html">MDataBlock</a> block = <span class="keyword">const_cast&lt;</span>GeometryOverrideHighPerformance_shape*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;forceCache();</div>
<div class="line">        double3&amp; boundingBoxMin = block.<a name="a36"></a><a class="code" href="./class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(fsInputMeshBoundingBoxMin).<a name="a37"></a><a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line">        double3&amp; boundingBoxMax = block.<a class="code" href="./class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(fsInputMeshBoundingBoxMax).<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>(<a name="_a38"></a><a class="code" href="./class_m_point.html">MPoint</a>(boundingBoxMin) * multiplier, <a class="code" href="./class_m_point.html">MPoint</a>(boundingBoxMax) * multiplier);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Return the scaled hardcoded mesh bounding box</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>(fBoundingBox.min() * multiplier, fBoundingBox.max() * multiplier);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method gets called when connections are made to attributes</span></div>
<div class="line"><span class="comment">//  of this node.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxNode::connectionMade()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> GeometryOverrideHighPerformance_shape::connectionMade(<span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; otherPlug, <span class="keywordtype">bool</span> asSrc)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// If the plug get connected with a shading engine, set fMaterialChanged to true, </span></div>
<div class="line"> <span class="comment">// so in the geometry override updateRenderItems() we can return true to force</span></div>
<div class="line"> <span class="comment">// the render items to be updated.</span></div>
<div class="line"> <span class="keywordflow">if</span> (asSrc &amp;&amp;</div>
<div class="line">        otherPlug.<a name="a39"></a><a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>().<a name="a40"></a><a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a41"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a1fe410ba33fcc24e08a319ee3db38896">MFn::kShadingEngine</a>) &amp;&amp;</div>
<div class="line">        (plug.<a name="a42"></a><a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == instObjGroups || plug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == objectGroups))</div>
<div class="line">    {</div>
<div class="line">        setMaterialChangedSinceVP2Update(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// When a input mesh is connected to the node, we must also connect the input mesh</span></div>
<div class="line"> <span class="comment">// bounding box attribute to this node to be able to get easly the mesh bounding box.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!asSrc &amp;&amp;</div>
<div class="line">        otherPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>().<a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a43"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62">MFn::kMesh</a>) &amp;&amp;</div>
<div class="line">        (plug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == fsInputMesh))</div>
<div class="line">    {</div>
<div class="line">        fUseInputMesh = <span class="keyword">true</span>;</div>
<div class="line">        setInputMeshChangedSinceVP2Update(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> thisNode = thisMObject();</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   boundingBoxMinPlug(thisNode, fsInputMeshBoundingBoxMin);</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   boundingBoxMaxPlug(thisNode, fsInputMeshBoundingBoxMax);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   inputMeshBoundingBoxMinPlug(otherPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), <a class="code" href="./class_m_px_surface_shape.html#a20781dbb7a5c1fc5d58365860247abc9">MPxSurfaceShape::nodeBoundingBoxMin</a>);</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   inputMeshBoundingBoxMaxPlug(otherPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), <a class="code" href="./class_m_px_surface_shape.html#a561dd332a87a898ad27c45f8df63ce5e">MPxSurfaceShape::nodeBoundingBoxMax</a>);</div>
<div class="line"></div>
<div class="line"> <a name="_a44"></a><a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> modifier;</div>
<div class="line">        modifier.<a name="a45"></a><a class="code" href="./class_m_d_g_modifier.html#afbd18f066f70fcd1864ddb4af91f3c7b">connect</a>(inputMeshBoundingBoxMinPlug, boundingBoxMinPlug);</div>
<div class="line">        modifier.connect(inputMeshBoundingBoxMaxPlug, boundingBoxMaxPlug);</div>
<div class="line">        modifier.doIt();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a46"></a><a class="code" href="./class_m_px_node.html#a82d0d0e95d46b8f41c4fd4bea409c1b3">MPxNode::connectionMade</a>(plug, otherPlug, asSrc);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method gets called when connections are broken with attributes</span></div>
<div class="line"><span class="comment">//  of this node.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxNode::connectionBroken()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> GeometryOverrideHighPerformance_shape::connectionBroken(<span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; otherPlug, <span class="keywordtype">bool</span> asSrc)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// If the plug get disconnected with a shading engine, set fMaterialChanged to true, </span></div>
<div class="line"> <span class="comment">// so in the geometry override updateRenderItems() we can return true to force</span></div>
<div class="line"> <span class="comment">// the render items to be updated.</span></div>
<div class="line"> <span class="keywordflow">if</span> (asSrc &amp;&amp; </div>
<div class="line">        otherPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>().<a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a1fe410ba33fcc24e08a319ee3db38896">MFn::kShadingEngine</a>) &amp;&amp;</div>
<div class="line">        (plug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == instObjGroups || plug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == objectGroups))</div>
<div class="line">    {</div>
<div class="line">        setMaterialChangedSinceVP2Update(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// When a input mesh is disconnected from the node,</span></div>
<div class="line"> <span class="comment">// we also must disconnect the input mesh bounding box attribute from this node </span></div>
<div class="line"> <span class="keywordflow">if</span> (!asSrc &amp;&amp;</div>
<div class="line">        otherPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>().<a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62">MFn::kMesh</a>) &amp;&amp;</div>
<div class="line">        (plug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == fsInputMesh))</div>
<div class="line">    {</div>
<div class="line">        fUseInputMesh = <span class="keyword">false</span>;</div>
<div class="line">        setInputMeshChangedSinceVP2Update(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> thisNode = thisMObject();</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   boundingBoxMinPlug(thisNode, fsInputMeshBoundingBoxMin);</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   boundingBoxMaxPlug(thisNode, fsInputMeshBoundingBoxMax);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   inputMeshBoundingBoxMinPlug(otherPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), <a class="code" href="./class_m_px_surface_shape.html#a20781dbb7a5c1fc5d58365860247abc9">MPxSurfaceShape::nodeBoundingBoxMin</a>);</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   inputMeshBoundingBoxMaxPlug(otherPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), <a class="code" href="./class_m_px_surface_shape.html#a561dd332a87a898ad27c45f8df63ce5e">MPxSurfaceShape::nodeBoundingBoxMax</a>);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> modifier;</div>
<div class="line">        modifier.<a name="a47"></a><a class="code" href="./class_m_d_g_modifier.html#aee585c763e12aa6277000a028dbfa619">disconnect</a>(inputMeshBoundingBoxMinPlug, boundingBoxMinPlug);</div>
<div class="line">        modifier.disconnect(inputMeshBoundingBoxMaxPlug, boundingBoxMaxPlug);</div>
<div class="line">        modifier.doIt();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a48"></a><a class="code" href="./class_m_px_node.html#ac2493af8700f32f6bc164414ac2b906d">MPxNode::connectionBroken</a>(plug, otherPlug, asSrc);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method can be overridden in user defined nodes to specify</span></div>
<div class="line"><span class="comment">//  which plugs should be set dirty based upon an input plug</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Warning : any time you implement setDependentsDirty you probably also need to implement</span></div>
<div class="line"><span class="comment">//  something similar in preEvaluation() or postEvaluation() so the code works correctly</span></div>
<div class="line"><span class="comment">//  with Evaluation Manager enabled.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxNode::setDependentsDirty()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> GeometryOverrideHighPerformance_shape::setDependentsDirty(<span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <a name="_a49"></a><a class="code" href="./class_m_plug_array.html">MPlugArray</a>&amp; plugArray)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (plug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == GeometryOverrideHighPerformance_shape::fsSize)</div>
<div class="line">    {</div>
<div class="line">        setSizeChangedSinceVP2Update(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>() == GeometryOverrideHighPerformance_shape::fsInputMesh)</div>
<div class="line">    {</div>
<div class="line">        setInputMeshGeoChangedSinceVP2Update(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a50"></a><a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  After the evaluation graph execution, each node gets a chance to</span></div>
<div class="line"><span class="comment">//  restore / update its internal states.For example, resetting</span></div>
<div class="line"><span class="comment">//  draw state.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This code has to be thread safe, non - blocking and work only on</span></div>
<div class="line"><span class="comment">//  data owned by the node.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This call will most likely happen from a worker thread.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxNode::postEvaluation</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Evaluation Caching : It is critical for Evaluation Caching that the EM dirty information</span></div>
<div class="line"><span class="comment">// is accessed from postEvaluation rather than preEvaluation. During Evaluation</span></div>
<div class="line"><span class="comment">// Caching restore(or VP2 Custom Caching restore) preEvaluation will not be called,</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// preEvaluation should be used to prepare for the drawing override calls</span></div>
<div class="line"><span class="comment">// postEvaluation should be used to notify consumers of the data(VP2) that new data is ready.</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// Warning: any time you implement preEvaluation or postEvaluation and use dirtyPlugExists</span></div>
<div class="line"><span class="comment">//          you probably also need to implement something similar in setDependentsDirty() so</span></div>
<div class="line"><span class="comment">//          the code works correctly without Evaluation Manager.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> GeometryOverrideHighPerformance_shape::postEvaluation(<span class="keyword">const</span> <a name="_a51"></a><a class="code" href="./class_m_d_g_context.html">MDGContext</a>&amp; context, <span class="keyword">const</span> <a name="_a52"></a><a class="code" href="./class_m_evaluation_node.html">MEvaluationNode</a>&amp; evaluationNode, PostEvaluationType evalType)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (evaluationNode.<a name="a53"></a><a class="code" href="./class_m_evaluation_node.html#abc632b073f3b3abeb4ca052f20573dd6">dirtyPlugExists</a>(GeometryOverrideHighPerformance_shape::fsSize, &amp;status) &amp;&amp; status)</div>
<div class="line">    {</div>
<div class="line">        setSizeChangedSinceVP2Update(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (evaluationNode.<a class="code" href="./class_m_evaluation_node.html#abc632b073f3b3abeb4ca052f20573dd6">dirtyPlugExists</a>(GeometryOverrideHighPerformance_shape::fsInputMesh, &amp;status) &amp;&amp; status)</div>
<div class="line">    {</div>
<div class="line">        setInputMeshGeoChangedSinceVP2Update(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance_shape::setSizeChangedSinceVP2Update(<span class="keywordtype">bool</span> sizeChanged) </div>
<div class="line">{ </div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">    Calling forceCache here should be fast.  Possible calling sites are:</span></div>
<div class="line"><span class="comment">    - setDependentsDirty() -&gt; the normal context is current.</span></div>
<div class="line"><span class="comment">    - preparing the draw in VP2 -&gt; the normal context is current.</span></div>
<div class="line"><span class="comment">    - background evaluation postEvaluation() -&gt; datablock for background context already exists.</span></div>
<div class="line"><span class="comment">    - background evaluation for VP2 Custom Caching -&gt; datablock for background context already exists.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> block = forceCache();</div>
<div class="line"> <a name="_a54"></a><a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle = block.<a name="a55"></a><a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(fsSizeChangedSinceVP2Update);</div>
<div class="line">    dataHandle.<a name="a56"></a><a class="code" href="./class_m_data_handle.html#ad1c723b684b73109b0918a3dd8984340">setBool</a>(sizeChanged);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance_shape::evalSizeChangedSinceVP2Update() </div>
<div class="line">{ </div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> block = forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle = block.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(fsSizeChangedSinceVP2Update);</div>
<div class="line"> <span class="keywordflow">return</span> dataHandle.<a name="a57"></a><a class="code" href="./class_m_data_handle.html#a69fdebf4dcdf33c1b313eb4a426e0d45">asBool</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance_shape::setInputMeshChangedSinceVP2Update(<span class="keywordtype">bool</span> value) </div>
<div class="line">{ </div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> block = forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle = block.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(fsInputMeshChanged);</div>
<div class="line">    dataHandle.<a class="code" href="./class_m_data_handle.html#ad1c723b684b73109b0918a3dd8984340">setBool</a>(value);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance_shape::evalInputMeshChangedSinceVP2Update() </div>
<div class="line">{ </div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> block = forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle = block.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(fsInputMeshChanged);</div>
<div class="line"> <span class="keywordflow">return</span> dataHandle.<a class="code" href="./class_m_data_handle.html#a69fdebf4dcdf33c1b313eb4a426e0d45">asBool</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance_shape::setInputMeshGeoChangedSinceVP2Update(<span class="keywordtype">bool</span> value)</div>
<div class="line">{ </div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> block = forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle = block.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(fsInputMeshGeoChanged);</div>
<div class="line"> <span class="keywordflow">return</span> dataHandle.<a class="code" href="./class_m_data_handle.html#ad1c723b684b73109b0918a3dd8984340">setBool</a>(value);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance_shape::evalInputMeshGeoChangedSinceVP2Update()</div>
<div class="line">{ </div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> block = forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle = block.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(fsInputMeshGeoChanged);</div>
<div class="line"> <span class="keywordflow">return</span> dataHandle.<a class="code" href="./class_m_data_handle.html#a69fdebf4dcdf33c1b313eb4a426e0d45">asBool</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance_shape::evalMaterialChangedSinceVP2Update() </div>
<div class="line">{ </div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> block = forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle = block.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(fsMaterialChanged);</div>
<div class="line"> <span class="keywordflow">return</span> dataHandle.<a class="code" href="./class_m_data_handle.html#a69fdebf4dcdf33c1b313eb4a426e0d45">asBool</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance_shape::setMaterialChangedSinceVP2Update(<span class="keywordtype">bool</span> value)</div>
<div class="line">{ </div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> block = forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle = block.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(fsMaterialChanged);</div>
<div class="line"> <span class="keywordflow">return</span> dataHandle.<a class="code" href="./class_m_data_handle.html#ad1c723b684b73109b0918a3dd8984340">setBool</a>(value);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              GeometryOverrideHighPerformance implementation</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* GeometryOverrideHighPerformance::sActiveWireframeRenderItemName  = <span class="stringliteral">"GeometryOverrideHighPerformance_ActiveWireframe"</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* GeometryOverrideHighPerformance::sDormantWireframeRenderItemName = <span class="stringliteral">"GeometryOverrideHighPerformance_DormantWireframe"</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* GeometryOverrideHighPerformance::sCustomShadedItemName           = <span class="stringliteral">"GeometryOverrideHighPerformance_shaded"</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GeometryOverrideHighPerformance::GeometryOverrideHighPerformance(<span class="keyword">const</span> <a class="code" href="./class_m_object.html">MObject</a>&amp; obj) </div>
<div class="line">    : <a class="code" href="./namespace_m_h_w_render.html">MHWRender</a>::MPxGeometryOverride(obj)</div>
<div class="line">    , fSurfaceNode(obj)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// get the real mesh object from the MObject</span></div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"> <a name="_a58"></a><a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> node(obj, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (status)</div>
<div class="line">    {</div>
<div class="line">        fMesh = <span class="keyword">dynamic_cast&lt;</span>GeometryOverrideHighPerformance_shape*<span class="keyword">&gt;</span>(node.userNode());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GeometryOverrideHighPerformance::~GeometryOverrideHighPerformance()</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This function return draw API that is supported by this plugin.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::supportedDrawAPIs()</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a class="code" href="./namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49">MHWRender::DrawAPI</a> GeometryOverrideHighPerformance::supportedDrawAPIs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">return</span>  (<a name="a59"></a><a class="code" href="./namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49a72361be679c1aca1c1be5f9b500a3315">MHWRender::kOpenGL</a> | <a name="a60"></a><a class="code" href="./namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49a90bc0a1678af7ac4d1e62e2e954be4e5">MHWRender::kDirectX11</a> | <a name="a61"></a><a class="code" href="./namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49aaebf48c70b63878eff38483392f19fb7">MHWRender::kOpenGLCoreProfile</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Perform any work required to translate the geometry data that needs to get</span></div>
<div class="line"><span class="comment">//  information from the dependency graph.This should be the only place that</span></div>
<div class="line"><span class="comment">//  dependency graph evaluation occurs. Any data retrieved should be cached for</span></div>
<div class="line"><span class="comment">//  later stages.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::updateDG()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance::updateDG()</div>
<div class="line">{   </div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Cache the input mesh dagpath if the input mesh has changed</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (fMesh &amp;&amp; fMesh-&gt;evalInputMeshChangedSinceVP2Update())</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> plug(fSurfaceNode, GeometryOverrideHighPerformance_shape::fsInputMesh);</div>
<div class="line"> </div>
<div class="line"> <a class="code" href="./class_m_plug_array.html">MPlugArray</a> connections;</div>
<div class="line"> <span class="keywordflow">if</span> (plug.<a name="a62"></a><a class="code" href="./class_m_plug.html#acf1340576a4a0a78a0045e67ee4155bf">connectedTo</a>(connections, <span class="keyword">true</span><span class="comment">/*asDst*/</span>, <span class="keyword">false</span><span class="comment">/*asSrc*/</span>))</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; connections.<a name="a63"></a><a class="code" href="./class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); ++i)</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> node = connections[i].node();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (node.<a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62">MFn::kMesh</a>))</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_dag_path.html#a422aa5ec02565f757c13fe2873ed25d7">MDagPath::getAPathTo</a>(node, fInputMeshPath);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                fInputMeshPath = <a class="code" href="./class_m_dag_path.html">MDagPath</a>();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            fInputMeshPath = <a class="code" href="./class_m_dag_path.html">MDagPath</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Only update fSizeMultiplier if the size changed</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (fMesh &amp;&amp; fMesh-&gt;evalSizeChangedSinceVP2Update())</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> plug(fSurfaceNode, GeometryOverrideHighPerformance_shape::fsSize);</div>
<div class="line"> <span class="keywordflow">if</span> (!plug.<a name="a64"></a><a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>())</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_distance.html">MDistance</a> sizeVal;</div>
<div class="line"> <span class="keywordflow">if</span> (plug.<a name="a65"></a><a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>(sizeVal))</div>
<div class="line">            {</div>
<div class="line">                fSizeMultiplier = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(sizeVal.<a class="code" href="./class_m_distance.html#ace39ab92685b0f5ab1a2925e748efb1f">asCentimeters</a>());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method is called once during each draw-preparation phase.  If this method returns true </span></div>
<div class="line"><span class="comment">//  then the associated DAG object will have a chance to update its render geometry this frame.</span></div>
<div class="line"><span class="comment">//  (Maya will call populateGeometry())</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This code has to be thread safe, non - blocking and work only on</span></div>
<div class="line"><span class="comment">//  data owned by the associated DAG object.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Dependency graph evaluation is not allowed in this function.</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::requiresGeometryUpdate()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance::requiresGeometryUpdate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// In this example, there is only two situation where we need update the geometry on the GPU</span></div>
<div class="line"> <span class="comment">// 1-) The input mesh connection changed, so we need to update all the vertex data on the gpu.</span></div>
<div class="line"> <span class="comment">// 2-) The input mesh geometry changed, so we need to update all the vertex data on the gpu.</span></div>
<div class="line"> <span class="comment">// 3-) The size attribute changed, so we need to scale the vertex position on the CPU and</span></div>
<div class="line"> <span class="comment">//     update the vertex position on the GPU.</span></div>
<div class="line"> <span class="keywordflow">return</span> fMesh &amp;&amp;</div>
<div class="line">           (fMesh-&gt;evalInputMeshChangedSinceVP2Update() || </div>
<div class="line">            fMesh-&gt;evalInputMeshGeoChangedSinceVP2Update() ||</div>
<div class="line">            fMesh-&gt;evalSizeChangedSinceVP2Update());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method is called for each geometry stream on the assocated DAG object</span></div>
<div class="line"><span class="comment">//  whenever the object changes.This method is passed a vertex buffer</span></div>
<div class="line"><span class="comment">//  descriptor representing one stream on the object to be updated.This</span></div>
<div class="line"><span class="comment">//  method should return false if it is safe to reuse the existing buffer rather</span></div>
<div class="line"><span class="comment">//  than filling a new buffer with data. Note that returning false from</span></div>
<div class="line"><span class="comment">//  isStreamDirty may NOT prevent populateGeometry from requiring that a stream</span></div>
<div class="line"><span class="comment">//  be updated.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Dependency graph evaluation is not allowed in this function.</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::isStreamDirty()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance::isStreamDirty(<span class="keyword">const</span> <a name="_a66"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a> &amp;desc)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span>(fInputMeshPath.isValid())</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fMesh &amp;&amp; fMesh-&gt;evalInputMeshChangedSinceVP2Update())</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// The input mesh changed since the last VP2 update (populate geometry).</span></div>
<div class="line"> <span class="comment">// That means during the last VP2 update we were using the default mesh </span></div>
<div class="line"> <span class="comment">// or another input mesh so, make all the stream dirty to be able to </span></div>
<div class="line"> <span class="comment">// populate them with the default mesh data.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fMesh &amp;&amp; </div>
<div class="line">                 ( fMesh-&gt;evalInputMeshGeoChangedSinceVP2Update() ||</div>
<div class="line">                   fMesh-&gt;evalSizeChangedSinceVP2Update()))</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// When the input mesh geometry change or when the size attribute change,</span></div>
<div class="line"> <span class="comment">// we need to mark all the streams as dirty because MGeometryExtractor is used</span></div>
<div class="line"> <span class="comment">// to get the input mesh data and MGeometryExtractor return different result </span></div>
<div class="line"> <span class="comment">// depending on stream combination (Number of vertex for each stream).</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }   </div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>(fMesh &amp;&amp; fMesh-&gt;evalInputMeshChangedSinceVP2Update())</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// The input mesh changed since the last VP2 update (populate geometry).</span></div>
<div class="line"> <span class="comment">// That means during the last VP2 update we were using a input mesh that </span></div>
<div class="line"> <span class="comment">// have been disconnected so, make all the stream dirty to be able to </span></div>
<div class="line"> <span class="comment">// populate them with the default mesh data.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (desc.<a name="a67"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>() == MGeometry::kPosition)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// We only need to make the position stream dirty if the size attribute changed</span></div>
<div class="line"> <span class="keywordflow">return</span> fMesh &amp;&amp; fMesh-&gt;evalSizeChangedSinceVP2Update();</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// For the default mesh, we assume that all the others stream (Normal, Tangent ...)</span></div>
<div class="line"> <span class="comment">// does't change so mark them all as not dirty.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This method is called for each render item on the assocated DAG object</span></div>
<div class="line"><span class="comment">// whenever the object changes.This method is passed a render item.This</span></div>
<div class="line"><span class="comment">// method should return true if the indexing for the render item has changed</span></div>
<div class="line"><span class="comment">// since the last frame.Note that returning false from isIndexingDirty may</span></div>
<div class="line"><span class="comment">// NOT prevent populate geometry from requiring that an index buffer is</span></div>
<div class="line"><span class="comment">// updated.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Dependency graph evaluation is not allowed in this function.</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::isIndexingDirty()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance::isIndexingDirty(<span class="keyword">const</span> MRenderItem&amp; item)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// In this example, we only need to invalidate the index data when the input mesh changed</span></div>
<div class="line"> <span class="keywordflow">return</span> fMesh &amp;&amp; fMesh-&gt;evalInputMeshChangedSinceVP2Update();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//  </span></div>
<div class="line"><span class="comment">//  If this method returns false for an MDagPath instance</span></div>
<div class="line"><span class="comment">//  of the associated DAG object then updateRenderItems() will not be called for that MDagPath</span></div>
<div class="line"><span class="comment">//  draw-preparation phase.  If requiresUpdateRenderItems() returns false for all MDagPaths</span></div>
<div class="line"><span class="comment">//  then updateRenderItems() will not be called at all for the draw-preparation phase.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Dependency graph evaluation is not allowed in this function.</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::requiresUpdateRenderItems()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance::requiresUpdateRenderItems(<span class="keyword">const</span> <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; path)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>(fMesh &amp;&amp; fMesh-&gt;evalMaterialChangedSinceVP2Update())</div>
<div class="line">    {</div>
<div class="line">        fMesh-&gt;setMaterialChangedSinceVP2Update(<span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bca">MHWRender::DisplayStatus</a> currentDisplayStatus = <a name="a68"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#aa2838b92c9f7db4a810690a986199134">MHWRender::MGeometryUtilities::displayStatus</a>(path);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If the display status not changed, then don't do any render item updates.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Note : In a real situation, you will probably want to check if fDisplayStatus changed </span></div>
<div class="line"> <span class="comment">//        per dag path instance. In this example, we try to keep thing as simple as possible.</span></div>
<div class="line"> <span class="keywordflow">if</span> (currentDisplayStatus == fDisplayStatus)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  If this method returns true then the MPxGeometryOverride will be considered</span></div>
<div class="line"><span class="comment">//  for Evaluation Manager Parallel Update.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Dependency graph evaluation is not allowed in this function.</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::supportsEvaluationManagerParallelUpdate()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance::supportsEvaluationManagerParallelUpdate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method is called at any time during evaluation to determine if VP2</span></div>
<div class="line"><span class="comment">//  Custom Caching is supported.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Dependency graph evaluation is not allowed in this function.</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::supportsVP2CustomCaching()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideHighPerformance::supportsVP2CustomCaching()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// This method must return the same value for the entire lifetime of the object.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method is called for each instance of the associated DAG object whenever </span></div>
<div class="line"><span class="comment">//  the object changes and receive the path to the instance and the current list </span></div>
<div class="line"><span class="comment">//  of render items associated with that instance. Implementations of this method </span></div>
<div class="line"><span class="comment">//  may add, remove or modify items in the list. As an alternative this method </span></div>
<div class="line"><span class="comment">//  can enable or disable items that must be used or not based on some properties.</span></div>
<div class="line"><span class="comment">//  </span></div>
<div class="line"><span class="comment">//  A render item represents a single renderable entity and contain many properties </span></div>
<div class="line"><span class="comment">//  to let the Viewport 2.0 to know how to render the entity. By example, A render </span></div>
<div class="line"><span class="comment">//  item contain a name, a type, the geometry primitive type, a set of geometry buffers</span></div>
<div class="line"><span class="comment">//  and a shader instance. </span></div>
<div class="line"><span class="comment">//  </span></div>
<div class="line"><span class="comment">//  In this example, this functions will create 3 render items to render the object's </span></div>
<div class="line"><span class="comment">//  geometry. The first render item will be use to display the oject with a single color </span></div>
<div class="line"><span class="comment">//  only when the Viewport 2.0 is in shaded or textured mode. The second render item </span></div>
<div class="line"><span class="comment">//  will be use to display the object in wireframe with a single color only when the </span></div>
<div class="line"><span class="comment">//  Viewport 2.0 is in wireframe mode. The last render item will be use to render the </span></div>
<div class="line"><span class="comment">//  object with a single color in wireframe only when the object is selected independing </span></div>
<div class="line"><span class="comment">//  of the Viewport 2.0 display mode. Both wireframe render item will be enable or disable </span></div>
<div class="line"><span class="comment">//  depending of the object selection state.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Dependency graph evaluation is not allowed in this function.</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::updateRenderItems()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance::updateRenderItems(<span class="keyword">const</span> <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; path, <a name="_a69"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItems)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!path.<a name="a70"></a><a class="code" href="./class_m_dag_path.html#a095ae34296e81703965265a42ee783ca">isValid</a>())</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    MRenderer* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">const</span> MShaderManager* shaderManager = renderer-&gt;getShaderManager();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderManager)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Look if there is a "StandardShadedItem" render item in the list.</span></div>
<div class="line"> <span class="comment">// This render item is created by maya when the object is attached </span></div>
<div class="line"> <span class="comment">// to a shader network node.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keyword">auto</span> standardShadedItemIndex   = renderItems.<a name="a71"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a4cfe9fc51a24bca06d2619a55542f689">indexOf</a>(<span class="stringliteral">"StandardShadedItem"</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">auto</span> renderItemIndex      = renderItems.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a4cfe9fc51a24bca06d2619a55542f689">indexOf</a>(sCustomShadedItemName);</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create a render item that will render geometry with a single color </span></div>
<div class="line"> <span class="comment">// if it didn't already exist and there is not shader network attached </span></div>
<div class="line"> <span class="comment">// to the object.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// This render item will be used only in shaded and textured mode.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (standardShadedItemIndex &lt; 0 &amp;&amp; renderItemIndex &lt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Create the new render item with the given name.</span></div>
<div class="line"> <span class="comment">// We designate this item as a UI Material.</span></div>
<div class="line"> <span class="comment">// The topology for the render item is a triangle list.</span></div>
<div class="line"> <a name="_a72"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* shadedRenderItem = </div>
<div class="line"> <a name="a73"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#ac74a014f3346d8ddac693b7f034fa228">MHWRender::MRenderItem::Create</a>(sCustomShadedItemName,</div>
<div class="line"> <a name="a74"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49ea9990000c1137c9606135fe45d6b0ef50">MHWRender::MRenderItem::MaterialSceneItem</a>,</div>
<div class="line"> <a name="a75"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1eaa2c70dd76c8172a9298334473c914304">MHWRender::MGeometry::kTriangles</a>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We want this render item to only show up when in shaded or textured mode</span></div>
<div class="line">        shadedRenderItem-&gt;<a name="a76"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a8e28487092f00765128c2ffdd43d0fe4">setDrawMode</a>((<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3">MHWRender::MGeometry::DrawMode</a>)(<a name="a77"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a3ba47eb2caff6eea24d37de5f572f769">MHWRender::MGeometry::kShaded</a> | </div>
<div class="line"> <a name="a78"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a17e882561d8db0dedc215d0d4978e887">MHWRender::MGeometry::kTextured</a>));</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The the depth priority of this render item to sDormantFilledDepthPriority (The default value).</span></div>
<div class="line"> <span class="comment">// Depth priority is usefull when an object is displayed with many render items.</span></div>
<div class="line"> <span class="comment">// Viewport 2.0 will use the depth priority to know which render item must be draw on top</span></div>
<div class="line"> <span class="comment">// of others.</span></div>
<div class="line">        shadedRenderItem-&gt;<a name="a79"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a6e865e2cf5c9d818b1cbb99af2360c47">depthPriority</a>(<a name="a80"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#ae591b9bc3a27641c854ab0703a90cab1">MHWRender::MRenderItem::sDormantFilledDepthPriority</a>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Enable the render item so it will be use for rendering</span></div>
<div class="line">        shadedRenderItem-&gt;<a name="a81"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a1e9d2a5708b2231a8e72d22dc3be53fe">enable</a>(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get an instance of a "mayaLambertSurface" from the shader manager.</span></div>
<div class="line"> <span class="comment">// The shader tells the graphics hardware how to draw the geometry. </span></div>
<div class="line"> <span class="comment">// The MShaderInstance is a reference to a shader along with the values for the shader parameters.</span></div>
<div class="line">        MShaderInstance* shader = shaderManager-&gt;getFragmentShader(<span class="stringliteral">"mayaLambertSurface"</span>, <span class="stringliteral">"outSurfaceFinal"</span>, <span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (shader)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Set the shader color parameter</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> blueColor[] = { 0.0f, 0.0f, 1.0f, 1.0f };</div>
<div class="line">            shader-&gt;setParameter(<span class="stringliteral">"color"</span>, blueColor);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Assign the shader to the render item. This adds a reference to that</span></div>
<div class="line"> <span class="comment">// shader.</span></div>
<div class="line">            shadedRenderItem-&gt;<a name="a82"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#ad283b157fa4f6c40bceb9d398c53a72a">setShader</a>(shader);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Once assigned, no need to hold on to shader instance</span></div>
<div class="line">            shaderManager-&gt;releaseShader(shader);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The item must be added to the persistent list to be considered</span></div>
<div class="line"> <span class="comment">// for update / rendering</span></div>
<div class="line">        renderItems.<a name="a83"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a238f55e85f694b4f74535aaedc6ebe01">append</a>(shadedRenderItem);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// If the 'StandardShadedItem' and the custom render item exists,</span></div>
<div class="line"> <span class="comment">// enable the 'StandardShadedItem'  render item and disable the custom render item.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// This situation can happen if the geometry override was first created without a </span></div>
<div class="line"> <span class="comment">// shading engine, than a shading enine was attached to the node.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span>(standardShadedItemIndex &gt;= 0 &amp;&amp; renderItemIndex &gt;= 0)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* renderItem = renderItems.<a name="a84"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(renderItemIndex);</div>
<div class="line"> <span class="keywordflow">if</span> (renderItem)</div>
<div class="line">            renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a1e9d2a5708b2231a8e72d22dc3be53fe">enable</a>(<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">        renderItem = renderItems.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(standardShadedItemIndex);</div>
<div class="line"> <span class="keywordflow">if</span> (renderItem)</div>
<div class="line">            renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a1e9d2a5708b2231a8e72d22dc3be53fe">enable</a>(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Make sure the custom render item is enable if the 'StandardShadedItem' render item </span></div>
<div class="line"> <span class="comment">// does not exists.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (standardShadedItemIndex &lt; 0 &amp;&amp; renderItemIndex &gt;= 0)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* renderItem = renderItems.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(renderItemIndex);</div>
<div class="line"> <span class="keywordflow">if</span> (renderItem)</div>
<div class="line">            renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a1e9d2a5708b2231a8e72d22dc3be53fe">enable</a>(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the inherited DAG display properties.</span></div>
<div class="line">    fDisplayStatus = <a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#aa2838b92c9f7db4a810690a986199134">MHWRender::MGeometryUtilities::displayStatus</a>(path);</div>
<div class="line">    fWireframeDisplayColor = <a name="a85"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#a6221bc7407b14246b14f79a751496276">MHWRender::MGeometryUtilities::wireframeColor</a>(path);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the wireframe render item used when the object will be selected</span></div>
<div class="line"> <span class="keywordtype">bool</span> isWireFrameRenderItemEnabled = fDisplayStatus == <a name="a86"></a><a class="code" href="./namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaa1606a62e097fcfa55af6251a83b44243">MHWRender::kLead</a> || fDisplayStatus == <a name="a87"></a><a class="code" href="./namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaab6a8784b4cf96692e0d71d19c44ce732">MHWRender::kActive</a>;</div>
<div class="line">    updateWireframeItems(sActiveWireframeRenderItemName,</div>
<div class="line"> <a name="a88"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a8d857bf5569760ac7306382a558cb092">MHWRender::MGeometry::kAll</a>, </div>
<div class="line"> <a name="a89"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#abf0686a71845159b7a473312fe05044a">MHWRender::MRenderItem::sSelectionDepthPriority</a>,</div>
<div class="line">                          fWireframeDisplayColor,</div>
<div class="line">                          isWireFrameRenderItemEnabled,</div>
<div class="line">                          renderItems, </div>
<div class="line">                          *shaderManager);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the wireframe render item used when the object will not be selected</span></div>
<div class="line">    isWireFrameRenderItemEnabled = fDisplayStatus == <a name="a90"></a><a class="code" href="./namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaa658348c4d7bc7605d9359a41fd393c86">MHWRender::kDormant</a>;</div>
<div class="line">    updateWireframeItems(sDormantWireframeRenderItemName,</div>
<div class="line"> <a name="a91"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a62a997a862929eb62b0273d1db9e8e0d">MHWRender::MGeometry::kWireframe</a>, </div>
<div class="line"> <a name="a92"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a6915079c9389d5b9354d5b40fb8112ca">MHWRender::MRenderItem::sDormantWireDepthPriority</a>,</div>
<div class="line">                          fWireframeDisplayColor,</div>
<div class="line">                          isWireFrameRenderItemEnabled,</div>
<div class="line">                          renderItems,</div>
<div class="line">                          *shaderManager);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Fill in data and index streams based on the requirements passed in.</span></div>
<div class="line"><span class="comment">//  Associate indexing with the render items passed in.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Dependency graph evaluation is not allowed in this function.</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::populateGeometry()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance::populateGeometry(<span class="keyword">const</span> <a name="_a93"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html">MHWRender::MGeometryRequirements</a>&amp; requirements, <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItems, <a name="_a94"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>&amp; data)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!fMesh)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span>(fInputMeshPath.isValid())</div>
<div class="line">    {</div>
<div class="line">        populateInputMeshGeometry(requirements, renderItems, data);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        populateDefaultMeshGeometry(requirements, renderItems, data);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Now that the current geometry have been updated</span></div>
<div class="line"> <span class="comment">// clear the signal flags.</span></div>
<div class="line">    fMesh-&gt;setSizeChangedSinceVP2Update(<span class="keyword">false</span>);</div>
<div class="line">    fMesh-&gt;setInputMeshChangedSinceVP2Update(<span class="keyword">false</span>);</div>
<div class="line">    fMesh-&gt;setInputMeshGeoChangedSinceVP2Update(<span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Clean up any cached data stored from the updateDG() phase.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::cleanUp()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance::cleanUp()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Nothing here because the plugin doesn't keep any temporary data.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Update the wireframe render item named 'renderItemName' or create it</span></div>
<div class="line"><span class="comment">//  if it doesn't exists.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Arguments drawMode and depthPriority are only used for creation of </span></div>
<div class="line"><span class="comment">//         the render item.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance::updateWireframeItems(<span class="keyword">const</span> <span class="keywordtype">char</span>* renderItemName, MGeometry::DrawMode drawMode, </div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> depthPriority, <a name="_a95"></a><a class="code" href="./class_m_color.html">MColor</a> color, <span class="keywordtype">bool</span> isEnabled,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItemList, </div>
<div class="line"> <span class="keyword">const</span> <a name="_a96"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MHWRender::MShaderManager</a>&amp; shaderManager)</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* renderItem = <span class="keyword">nullptr</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Try to find the active wireframe render item.</span></div>
<div class="line"> <span class="comment">// If the returning index is smaller than 0, that means </span></div>
<div class="line"> <span class="comment">// the render item does't exists yet. So, create it.</span></div>
<div class="line"> <span class="keyword">auto</span> renderItemIndex = renderItemList.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a4cfe9fc51a24bca06d2619a55542f689">indexOf</a>(renderItemName);</div>
<div class="line"> <span class="keywordflow">if</span> (renderItemIndex &lt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Create the new render item with the given name.</span></div>
<div class="line"> <span class="comment">// We designate this item as a UI decoration and will not be</span></div>
<div class="line"> <span class="comment">// involved in rendering aspects such as casting shadows</span></div>
<div class="line"> <span class="comment">// The topology for the render item is a line list.</span></div>
<div class="line">        renderItem = <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#ac74a014f3346d8ddac693b7f034fa228">MHWRender::MRenderItem::Create</a>(renderItemName,</div>
<div class="line"> <a name="a97"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49eab87ea4b9433d4e99398728f2cf29b881">MHWRender::MRenderItem::DecorationItem</a>,</div>
<div class="line"> <a name="a98"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea9808e481c6346dfc333afb4c52890ac9">MHWRender::MGeometry::kLines</a>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We want this render item to show up when in all mode ( Wireframe, Shaded, Textured and BoundingBox)</span></div>
<div class="line">        renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a8e28487092f00765128c2ffdd43d0fe4">setDrawMode</a>(drawMode);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set selection priority: on top of everything</span></div>
<div class="line">        renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a6e865e2cf5c9d818b1cbb99af2360c47">depthPriority</a>(depthPriority);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get an instance of a 3dSolidShader from the shader manager.</span></div>
<div class="line"> <span class="comment">// The shader tells the graphics hardware how to draw the geometry. </span></div>
<div class="line"> <span class="comment">// The MShaderInstance is a reference to a shader along with the values for the shader parameters.</span></div>
<div class="line">        MShaderInstance* shader = shaderManager.<a name="a99"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a8e4ad27d691969622af2b05d8c6213d9">getStockShader</a>(MShaderManager::k3dSolidShader);</div>
<div class="line"> <span class="keywordflow">if</span> (shader)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Assign the shader to the render item. This adds a reference to that</span></div>
<div class="line"> <span class="comment">// shader.</span></div>
<div class="line">            renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#ad283b157fa4f6c40bceb9d398c53a72a">setShader</a>(shader);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Once assigned, no need to hold on to shader instance</span></div>
<div class="line">            shaderManager.<a name="a100"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a0c7deb55edc231cbb2365b271ecd55f8">releaseShader</a>(shader);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The item must be added to the persistent list to be considered</span></div>
<div class="line"> <span class="comment">// for update / rendering</span></div>
<div class="line">        renderItemList.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a238f55e85f694b4f74535aaedc6ebe01">append</a>(renderItem);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        renderItem = renderItemList.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(renderItemIndex);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(renderItem)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a101"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MHWRender::MShaderInstance</a>* shader = renderItem-&gt;<a name="a102"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#aa606047c9ccc32d66b93d07327b65be9">getShader</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (shader)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Set the shader color parameter</span></div>
<div class="line">            shader-&gt;<a name="a103"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef">setParameter</a>(<span class="stringliteral">"solidColor"</span>, &amp;color.<a name="a104"></a><a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a1e9d2a5708b2231a8e72d22dc3be53fe">enable</a>(isEnabled);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This function is used to populate the geometry data from the </span></div>
<div class="line"><span class="comment">//  input mesh. It used the MGeometryExtractor to extract</span></div>
<div class="line"><span class="comment">//  the data.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance::populateInputMeshGeometry(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html">MHWRender::MGeometryRequirements</a>&amp; requirements, <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItems, <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>&amp; data)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Use MGeometryExtractor to extract geometry from the input mesh path</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line">    MGeometryExtractor extractor(requirements, fInputMeshPath, <a name="a105"></a><a class="code" href="./namespace_m_h_w_render.html#adc29c2ff13d900c2f185ee95427fb06ca891eaab0dc4731ae402710120a0aa503">MHWRender::kPolyGeom_NotSharing</a>, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure == status)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> MVertexBufferDescriptorList&amp;  vertexBufferDescriptorList = requirements.<a name="a106"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#a960f411f65fde2d97da465a6b276d774">vertexRequirements</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vertexBufferDescriptorList.length(); i++)</div>
<div class="line">    {</div>
<div class="line">        MVertexBufferDescriptor desc{};</div>
<div class="line"> <span class="keywordflow">if</span> (!vertexBufferDescriptorList.getDescriptor(i, desc))</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        MVertexBuffer* vertexBuffer = data.<a name="a107"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"> <span class="keywordflow">if</span> (vertexBuffer)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertexCount = extractor.<a name="a108"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a42db940e8d3c623487a4e2c34024751c">vertexCount</a>();</div>
<div class="line"> <span class="keywordtype">float</span>* data = (<span class="keywordtype">float</span>*)vertexBuffer-&gt;acquire(vertexCount, <span class="keyword">true</span> <span class="comment">/*writeOnly - we don't need the current buffer values*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (data)</div>
<div class="line">            {</div>
<div class="line">                status = extractor.populateVertexBuffer(data, vertexCount, desc);</div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure == status)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// For vertex position, scale the position with the size multiplicator</span></div>
<div class="line"> <span class="keywordflow">if</span> (desc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>() == MGeometry::kPosition)</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vertexCount; i++)</div>
<div class="line">                    {</div>
<div class="line">                        data[i * 3]     *= fSizeMultiplier;</div>
<div class="line">                        data[i * 3 + 1] *= fSizeMultiplier;</div>
<div class="line">                        data[i * 3 + 2] *= fSizeMultiplier;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                vertexBuffer-&gt;commit(data);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">//   Update indexing data for all appropriate render items</span></div>
<div class="line"><span class="comment"></span> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; renderItems.<a name="a109"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); ++i)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> MRenderItem* item = renderItems.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(i);</div>
<div class="line"> <span class="keywordflow">if</span> (!item) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        MIndexBuffer* indexBuffer = data.createIndexBuffer(MGeometry::kUnsignedInt32);</div>
<div class="line"> <span class="keywordflow">if</span> (!indexBuffer) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (item-&gt;primitive() == MGeometry::kTriangles)</div>
<div class="line">        {</div>
<div class="line">            MIndexBufferDescriptor triangleDesc(MIndexBufferDescriptor::kTriangle, <a name="_a110"></a><a class="code" href="./class_m_string.html">MString</a>(), MGeometry::kTriangles, 3);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles = extractor.primitiveCount(triangleDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexBuffer-&gt;acquire(3 * numTriangles, <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Fill a buffer with geometry indexing data</span></div>
<div class="line">            status = extractor.populateIndexBuffer(indices, numTriangles, triangleDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure == status)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">            indexBuffer-&gt;commit(indices);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (item-&gt;primitive() == MGeometry::kLines)</div>
<div class="line">        {</div>
<div class="line">            MIndexBufferDescriptor edgeDesc(MIndexBufferDescriptor::kEdgeLine, <a class="code" href="./class_m_string.html">MString</a>(), MGeometry::kLines, 2);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numEdges = extractor.primitiveCount(edgeDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexBuffer-&gt;acquire(2 * numEdges, <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Fill a buffer with geometry indexing data</span></div>
<div class="line">            status = extractor.populateIndexBuffer(indices, numEdges, edgeDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure == status)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">            indexBuffer-&gt;commit(indices);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        item-&gt;associateWithIndexBuffer(indexBuffer);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This function is used to populate the geometry data from the </span></div>
<div class="line"><span class="comment">//  default mesh (Hardcoded mesh) in case there is no input mesh</span></div>
<div class="line"><span class="comment">//  attached to the node.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideHighPerformance::populateDefaultMeshGeometry(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html">MHWRender::MGeometryRequirements</a>&amp; requirements, <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItems, <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>&amp; data)</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">const</span> MVertexBufferDescriptorList&amp;  vertexBufferDescriptorList = requirements.<a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#a960f411f65fde2d97da465a6b276d774">vertexRequirements</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vertexBufferDescriptorList.length(); i++)</div>
<div class="line">    {</div>
<div class="line">        MVertexBufferDescriptor desc{};</div>
<div class="line"> <span class="keywordflow">if</span> (!vertexBufferDescriptorList.getDescriptor(i, desc))</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (desc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>())</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the vertex position buffer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kPosition:</div>
<div class="line">        {</div>
<div class="line"> <a name="_a111"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* positionBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> Float3Array&amp; positions = fMesh-&gt;getPositions();</div>
<div class="line"></div>
<div class="line">                Float3* buffer = <span class="keyword">static_cast&lt;</span>Float3*<span class="keyword">&gt;</span>(positionBuffer-&gt;<a name="a112"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(positions.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly */</span>));</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// copie the cube vertices and scale them by the size multiplier</span></div>
<div class="line"> <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; positions.size(); i++)</div>
<div class="line">                    {</div>
<div class="line">                        buffer[i].x = positions[i].x * fSizeMultiplier;</div>
<div class="line">                        buffer[i].y = positions[i].y * fSizeMultiplier;</div>
<div class="line">                        buffer[i].z = positions[i].z * fSizeMultiplier;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    positionBuffer-&gt;<a name="a113"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the vertex normal buffer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kNormal:</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* normalsBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (normalsBuffer)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> Float3Array&amp; normals = fMesh-&gt;getNormals();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = normalsBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(normals.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(Float3Array::value_type) * normals.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, normals.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    normalsBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the vertex tangent buffer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kTangent:</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* tangentBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (tangentBuffer)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> Float3Array&amp; tangents = fMesh-&gt;getTangents();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = tangentBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(tangents.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(Float3Array::value_type) * tangents.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, tangents.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    tangentBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the vertex bitangent buffer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kBitangent:</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* tangentBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (tangentBuffer)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> Float3Array&amp; tangents = fMesh-&gt;getBiTangents();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = tangentBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(tangents.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(Float3Array::value_type) * tangents.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, tangents.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    tangentBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the vertex texture coords buffer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kTexture:</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* vertexBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (vertexBuffer)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> Float2Array&amp; texCoords = fMesh-&gt;getTexCoords();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* vertexBufferData = vertexBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(texCoords.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (vertexBufferData)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(Float2Array::value_type) * texCoords.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(vertexBufferData, texCoords.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    vertexBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(vertexBufferData);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kColor:</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kTangentWithSign:</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kInvalidSemantic:   <span class="comment">// avoid compiling error</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// In this example, we don't need to used those vertex informantions.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">//   Update indexing data for all appropriate render items</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">const</span> <span class="keywordtype">int</span> numItems = renderItems.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numItems; i++)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* item = renderItems.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(i);</div>
<div class="line"> <span class="keywordflow">if</span> (!item)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (item-&gt;<a name="a114"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#af3ddb45109547883d06426f0530ddf0c">primitive</a>() == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1eaa2c70dd76c8172a9298334473c914304">MHWRender::MGeometry::kTriangles</a> ||</div>
<div class="line">            item-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#af3ddb45109547883d06426f0530ddf0c">primitive</a>() == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea9808e481c6346dfc333afb4c52890ac9">MHWRender::MGeometry::kLines</a>)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the index buffer used to render triangles</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a name="_a115"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>* indexBuffer = data.<a name="a116"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a649d0f008cdfbd368a4157dcd47ede67">createIndexBuffer</a>(<a name="a117"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6aa93f90f58b3077bdbedeb9506e0143fd">MHWRender::MGeometry::kUnsignedInt32</a>);</div>
<div class="line"> <span class="keywordflow">if</span> (indexBuffer)</div>
<div class="line">            {</div>
<div class="line">                IndexList indices = fMesh-&gt;getIndices();</div>
<div class="line"> <span class="keywordtype">void</span>* buffer = indexBuffer-&gt;<a name="a118"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(indices.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(IndexList::value_type) * indices.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, indices.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    indexBuffer-&gt;<a name="a119"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Associate index buffer with render item</span></div>
<div class="line">                    item-&gt;<a name="a120"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a7d0f067f76206a54f4f716f63bcb6b19">associateWithIndexBuffer</a>(indexBuffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              initialize / uninitialize plugin</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> sDrawDbClassification(<span class="stringliteral">"drawdb/geometry/geometryOverrideHighPerformance"</span>);</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> sDrawRegistrantId(<span class="stringliteral">"geometryOverrideHighPerformancePlugin"</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> initializePlugin(<a class="code" href="./class_m_object.html">MObject</a> obj)</div>
<div class="line">{</div>
<div class="line"> <a name="_a121"></a><a class="code" href="./class_m_fn_plugin.html">MFnPlugin</a> plugin(obj, PLUGIN_COMPANY, <span class="stringliteral">"1.0"</span>, <span class="stringliteral">"Any"</span>);</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"></div>
<div class="line">    status = plugin.registerShape(<span class="stringliteral">"geometryOverrideHighPerformance_shape"</span>,              <span class="comment">// the name of the new type of user defined shape node</span></div>
<div class="line">                                GeometryOverrideHighPerformance_shape::fsId,            <span class="comment">// a unique id that identifies this node</span></div>
<div class="line">                                &amp;GeometryOverrideHighPerformance_shape::creator,        <span class="comment">// function that will return a pointer to a new instance of the class </span></div>
<div class="line"> <span class="comment">// (derived from MPxSurfaceNode) that implements the new shape node type</span></div>
<div class="line">                                &amp;GeometryOverrideHighPerformance_shape::initialize,     <span class="comment">// function that will initialize all the attributes of the new shape node type</span></div>
<div class="line"> <span class="keyword">nullptr</span>,</div>
<div class="line">                                &amp;sDrawDbClassification);</div>
<div class="line"> <span class="keywordflow">if</span> (!status)</div>
<div class="line">    {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"Failed to register geometryOverrideHighPerformance_shape."</span> &lt;&lt; std::endl;</div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    status = <a name="a122"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_registry.html#a36f6ac92077e5064d897187608c9e548">MHWRender::MDrawRegistry::registerGeometryOverrideCreator</a>(sDrawDbClassification,</div>
<div class="line">                                                                        sDrawRegistrantId,</div>
<div class="line">                                                                        GeometryOverrideHighPerformance::Creator);</div>
<div class="line"> <span class="keywordflow">if</span> (!status)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Failed to register Viewport 2.0 geometry override."</span> &lt;&lt; std::endl;</div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> uninitializePlugin(<a class="code" href="./class_m_object.html">MObject</a> obj)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_fn_plugin.html">MFnPlugin</a> plugin(obj);</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"></div>
<div class="line">    status = <a name="a123"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_registry.html#a24f600902d1e1a22ccd8985f9eee39a1">MHWRender::MDrawRegistry::deregisterGeometryOverrideCreator</a>(sDrawDbClassification, sDrawRegistrantId);</div>
<div class="line"> <span class="keywordflow">if</span> (!status)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Failed to deregister geometry override."</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    status = plugin.deregisterNode(GeometryOverrideHighPerformance_shape::fsId);</div>
<div class="line"> <span class="keywordflow">if</span> (!status) </div>
<div class="line">    {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"Failed to deregister GeometryOverrideHighPerformance_shape."</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>
