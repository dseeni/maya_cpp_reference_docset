<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../../../style/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../../../../scripts/prettify.js"></script><script src="../../../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="pandoc" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><script type="text/javascript" src="../../../../scripts/utils/adsk.redirect.js"></script>
      <title>Example: Bounding Box Deformer</title>
   </head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Example: Bounding Box Deformer</h1>
         </div>

<div class='section'><a id="example-bounding-box-deformer"></a></div>
<div class='section'><a id="example-bounding-box-deformer-1"></a><h2 id="example-bounding-box-deformer-1">Example: Bounding Box Deformer</h2></div>
<p><strong>Filename:</strong> <span class='code'>boundingBoxDeformer.py</span></p>
<p><strong>Sample Output:</strong> In the following output, we assigned a green phong material to the deformed sphere. By increasing the &quot;Mesh Inflation&quot; attribute, the mesh will attempt to fill its bounding box even more.</p>
<div class='figure'><img src='dev_help/images/boundingBoxDeformer_75%.png' title='' /></div>
<p><strong>Program Summary:</strong> The plug-in code below defines a new deformer whose behavior is to &quot;inflate&quot; the mesh so that it expands within the boundaries of its bounding box. The size of this bounding box can be scaled via the &quot;Bounding Box Scale&quot; attribute so that the mesh has room to expand before hitting the boundaries of the box. The mesh&#39;s inflation is controlled via the &quot;Mesh Inflation&quot; attribute. The plug-in class inherits from <span class='code'><a href="javascript:void(0)" data-symbol="MPxDeformerNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_deformer_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxDeformerNode</a></span>, and overrides the <span class='code'>MPxDeformer.deform()</span> function to specify its behavior. The following points are useful to keep in mind when creating a deformer node in Python:</p>
<ul>
<li><p><strong>Built-in Deformer Node Attributes</strong> - By inheriting from <span class='code'><a href="javascript:void(0)" data-symbol="MPxDeformerNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_deformer_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxDeformerNode</a></span>, your class will have access to the input and output mesh attributes, available via <span class='code'>OpenMayaMPx.cvar.MPxGeometryFilter_inputGeom</span> and <span class='code'>OpenMayaMPx.cvar.MPxGeometryFilter_outputGeom</span> respectively. These variables are generated by the SWIG tool during the C++ header file conversion to Python. By the same process, your deformer also has access to the built-in &quot;envelope&quot; attribute, available via <span class='code'>OpenMayaMPx.cvar.MPxGeometryFilter_envelope</span>. This envelope attribute is used to specify the amount of influence your deformer has on the mesh.</p>
<blockquote>
<p><strong>Note:</strong> This is new for Maya 2016. In versions of Maya before Maya 2016, the input and output mesh attributes were available via <span class='code'>OpenMayaMPx.cvar.MPxDeformerNode_inputGeom</span> and <span class='code'>OpenMayaMPx.cvar.MPxDeformerNode_outputGeom</span> respectively, and the envelop via <span class='code'>OpenMayaMPx.cvar.MPxDeformerNode_envelope</span> .</p>
</blockquote></li>
<li><p><strong>Obtaining the Input Geometry in deform()</strong> - The geometry iterator (<span class='code'><a href="javascript:void(0)" data-symbol="MItGeometry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_it_geometry.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_it_geometry.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MItGeometry</a></span>) passed into the <span class='code'>deform()</span> function only provides you with the position of each vertex in the mesh. To obtain the normals of each vertex, you will require a reference to the actual mesh object. We define a helper function called <span class='code'>getDeformerInputGeometry()</span> which returns the input mesh object. The returned mesh can thereafter be used with the <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_mesh.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnMesh</a></span> <em>function set</em> to retrieve the list of vertex normals, via <span class='code'>MFnMesh.getVertexNormals()</span>.</p></li>
</ul>
<p>Python API 2.0: This example is not available, as <span class='code'><a href="javascript:void(0)" data-symbol="MPxDeformerNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_deformer_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxDeformerNode</a></span> is not yet exposed in this API.</p>
<p>Python API 1.0 (for versions earlier than Maya 2016):</p>
<div class="codeBlock"><pre class="prettyprint"># boundingBoxDeformer.py

import sys
import maya.OpenMayaMPx as OpenMayaMPx
import maya.OpenMaya as OpenMaya

# Plug-in information:
kPluginNodeName = &#39;boundingBoxDeformer&#39;     # The name of the node.
kPluginNodeId = OpenMaya.MTypeId( 0xBEEF8 ) # A unique ID associated to this node type.

# This determines how fast the vertices of the mesh will &quot;expand&quot; towards the boundary of the bounding box.
vertexIncrement = 0.1

##########################################################
# Plug-in 
##########################################################
class MyDeformerNode(OpenMayaMPx.MPxDeformerNode):
    
    # Static variable(s) which will later be replaced by the node&#39;s attribute(s).
    boundingBoxScaleAttribute = OpenMaya.MObject()
    meshInflationAttribute    = OpenMaya.MObject()
    
    
    def __init__(self):
        &#39;&#39;&#39; Constructor. &#39;&#39;&#39;
        # (!) Make sure you call the base class&#39;s constructor.
        OpenMayaMPx.MPxDeformerNode.__init__(self)
        
    
    def deform(self, pDataBlock, pGeometryIterator, pLocalToWorldMatrix, pGeometryIndex):
        &#39;&#39;&#39; Deform each vertex using the geometry iterator. &#39;&#39;&#39;
        
        # The envelope determines the overall weight of the deformer on the mesh.
        # The envelope is obtained via the OpenMayaMPx.cvar.MPxDeformerNode_envelope variable.
        # This variable and others like it are generated by SWIG to expose variables or constants declared in C++ header files. 
        envelopeAttribute = OpenMayaMPx.cvar.MPxDeformerNode_envelope
        envelopeValue = pDataBlock.inputValue( envelopeAttribute ).asFloat()
        
        # Get the value of the mesh inflation node attribute.
        meshInflationHandle = pDataBlock.inputValue( MyDeformerNode.meshInflationAttribute )
        meshInflation = meshInflationHandle.asDouble()
        
        # Get the value of the bounding box scale node attribute.
        boundingBoxScaleHandle = pDataBlock.inputValue( MyDeformerNode.boundingBoxScaleAttribute )
        boundingBoxScale = boundingBoxScaleHandle.asDouble()

        # Get the input mesh from the datablock using our getDeformerInputGeometry() helper function.     
        inputGeometryObject = self.getDeformerInputGeometry(pDataBlock, pGeometryIndex)


        # Compute the bounding box using the input the mesh.
        boundingBox = self.getBoundingBox( inputGeometryObject, boundingBoxScale )

        
        # Obtain the list of normals for each vertex in the mesh.
        normals = OpenMaya.MFloatVectorArray()
        meshFn = OpenMaya.MFnMesh( inputGeometryObject )
        meshFn.getVertexNormals( True, normals, OpenMaya.MSpace.kTransform )
        
        
        # Iterate over the vertices to move them.
        global vertexIncrement
        while not pGeometryIterator.isDone():
            
            # Obtain the vertex normal of the geometry. This normal is the vertex&#39;s averaged normal value if that
            # vertex is shared among several polygons.  
            vertexIndex = pGeometryIterator.index()
            normal = OpenMaya.MVector( normals[vertexIndex] ) # Cast the <a href="javascript:void(0)" data-symbol="MFloatVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_float_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFloatVector</a> into a simple vector.
            
            # Increment the point along the vertex normal.
            point = pGeometryIterator.position()
            newPoint = point + ( normal * vertexIncrement * meshInflation * envelopeValue )
                       
            # Clamp the new point within the bounding box.
            self.clampPointInBoundingBox( newPoint, boundingBox )
            
            # Set the position of the current vertex to the new point.
            pGeometryIterator.setPosition( newPoint )
            
            # Jump to the next vertex.
            pGeometryIterator.next()
    
    
    def getDeformerInputGeometry(self, pDataBlock, pGeometryIndex):
        &#39;&#39;&#39;
        Obtain a reference to the input mesh. This mesh will be used to compute our bounding box, and we will also require its normals.
        
        We use MDataBlock.outputArrayValue() to avoid having to recompute the mesh and propagate this recomputation throughout the 
        Dependency Graph.
        
        OpenMayaMPx.cvar.MPxDeformerNode_input and OpenMayaMPx.cvar.MPxDeformerNode_inputGeom are SWIG-generated 
        variables which respectively contain references to the deformer&#39;s &#39;input&#39; attribute and &#39;inputGeom&#39; attribute.   
        &#39;&#39;&#39;
        inputAttribute = OpenMayaMPx.cvar.MPxDeformerNode_input
        inputGeometryAttribute = OpenMayaMPx.cvar.MPxDeformerNode_inputGeom
        
        inputHandle = pDataBlock.outputArrayValue( inputAttribute )
        inputHandle.jumpToElement( pGeometryIndex )
        inputGeometryObject = inputHandle.outputValue().child( inputGeometryAttribute ).asMesh()
        
        return inputGeometryObject
    
    
    def getBoundingBox(self, pMeshObj, pBoundingBoxScale):
        &#39;&#39;&#39; Calculate a bounding box around the mesh&#39;s vertices. &#39;&#39;&#39;
        
        # Create the bounding box object we will populate with the points of the mesh.
        boundingBox = OpenMaya.MBoundingBox()
        meshFn = OpenMaya.MFnMesh( pMeshObj )
        pointArray = OpenMaya.MPointArray()
        
        # Get the points of the mesh in its local coordinate space.
        meshFn.getPoints( pointArray, OpenMaya.MSpace.kTransform )

        for i in range( 0, pointArray.length() ):
            point = pointArray[i]
            boundingBox.expand( point )
        
        # Expand the bounding box according to the scaling factor.
        newMinPoint = boundingBox.min() * pBoundingBoxScale
        newMaxPoint = boundingBox.max() * pBoundingBoxScale
        boundingBox.expand( newMinPoint )
        boundingBox.expand( newMaxPoint )
        
        return boundingBox
    
    
    def clampPointInBoundingBox(self, pPoint, pBoundingBox):
        &#39;&#39;&#39; Ensure that the given point is contained within the bounding box&#39;s min/max coordinates. &#39;&#39;&#39;
        
        # Define a quick clamping function for internal use within this method body.
        def clamp(pValue, pMin, pMax):
            return max( pMin, min( pValue, pMax ) )
        
        pPoint.x = clamp( pPoint.x, pBoundingBox.min().x, pBoundingBox.max().x )
        pPoint.y = clamp( pPoint.y, pBoundingBox.min().y, pBoundingBox.max().y )
        pPoint.z = clamp( pPoint.z, pBoundingBox.min().z, pBoundingBox.max().z )
        

##########################################################
# Plug-in initialization.
##########################################################
def nodeCreator():
    &#39;&#39;&#39; Creates an instance of our node class and delivers it to Maya as a pointer. &#39;&#39;&#39;
    return OpenMayaMPx.asMPxPtr( MyDeformerNode() )

def nodeInitializer():
    &#39;&#39;&#39; Defines the input and output attributes as static variables in our plug-in class. &#39;&#39;&#39;
    # The following <a href="javascript:void(0)" data-symbol="MFnNumericAttribute" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnNumericAttribute</a> function set will allow us to create our attributes.
    numericAttributeFn = OpenMaya.MFnNumericAttribute()
    
    #==================================
    # INPUT NODE ATTRIBUTE(S)
    #==================================
    # Define the scaling factor attribute of the bounding box around the mesh.
    MyDeformerNode.boundingBoxScaleAttribute = numericAttributeFn.create( &#39;boundingBoxScale&#39;, &#39;bs&#39;, OpenMaya.MFnNumericData.kDouble, 1.5 )
    numericAttributeFn.setMin( 1.0 )
    numericAttributeFn.setMax( 3.0 )
    numericAttributeFn.setStorable( True )
    numericAttributeFn.setWritable( True )
    numericAttributeFn.setReadable( False )
    MyDeformerNode.addAttribute( MyDeformerNode.boundingBoxScaleAttribute )
    
    # Define a mesh inflation attribute, responsible for actually moving the vertices in the direction of their normals.
    MyDeformerNode.meshInflationAttribute = numericAttributeFn.create( &#39;meshInflation&#39;, &#39;mi&#39;, OpenMaya.MFnNumericData.kDouble, 10.0 )
    numericAttributeFn.setMin( 1.0 )
    numericAttributeFn.setMax( 50.0 )
    numericAttributeFn.setStorable( True )
    numericAttributeFn.setWritable( True )
    numericAttributeFn.setReadable( False )
    MyDeformerNode.addAttribute( MyDeformerNode.meshInflationAttribute )
    
    &#39;&#39;&#39; The input geometry node attribute is already declared in OpenMayaMPx.cvar.MPxDeformerNode_inputGeom &#39;&#39;&#39;

    #==================================
    # OUTPUT NODE ATTRIBUTE(S)
    #==================================
    
    &#39;&#39;&#39; The output geometry node attribute is already declared in OpenMayaMPx.cvar.MPxDeformerNode_outputGeom &#39;&#39;&#39;
    
    #==================================
    # NODE ATTRIBUTE DEPENDENCIES
    #==================================
    # If any of the inputs change, the output mesh will be recomputed.
    MyDeformerNode.attributeAffects( MyDeformerNode.boundingBoxScaleAttribute, OpenMayaMPx.cvar.MPxDeformerNode_outputGeom )
    MyDeformerNode.attributeAffects( MyDeformerNode.meshInflationAttribute, OpenMayaMPx.cvar.MPxDeformerNode_outputGeom )
    
    
def initializePlugin( mobject ):
    &#39;&#39;&#39; Initialize the plug-in &#39;&#39;&#39;
    mplugin = OpenMayaMPx.MFnPlugin( mobject )
    try:
        mplugin.registerNode( kPluginNodeName, kPluginNodeId, nodeCreator,
                              nodeInitializer, OpenMayaMPx.MPxNode.kDeformerNode )
    except:
        sys.stderr.write( &#39;Failed to register node: &#39; + kPluginNodeName )
        raise
    
def uninitializePlugin( mobject ):
    &#39;&#39;&#39; Uninitializes the plug-in &#39;&#39;&#39;
    mplugin = OpenMayaMPx.MFnPlugin( mobject )
    try:
        mplugin.deregisterNode( kPluginNodeId )
    except:
        sys.stderr.write( &#39;Failed to deregister node: &#39; + kPluginNodeName )
        raise

##########################################################
# Sample usage.
##########################################################
&#39;&#39;&#39; 
# Copy the following lines and run them in Maya&#39;s Python Script Editor:

import maya.cmds as cmds
cmds.loadPlugin( &#39;boundingBoxDeformer.py&#39; )
cmds.polySphere()
cmds.deformer( type=&#39;boundingBoxDeformer&#39; )

&#39;&#39;&#39;
</pre></div><p>Python API 1.0 (valid as of Maya 2016):</p>
<div class="codeBlock"><pre class="prettyprint"># boundingBoxDeformer.py

import sys
import maya.OpenMayaMPx as OpenMayaMPx
import maya.OpenMaya as OpenMaya

# Plug-in information:
kPluginNodeName = &#39;boundingBoxDeformer&#39;     # The name of the node.
kPluginNodeId = OpenMaya.MTypeId( 0xBEEF8 ) # A unique ID associated to this node type.

# This determines how fast the vertices of the mesh will &quot;expand&quot; towards the boundary of the bounding box.
vertexIncrement = 0.1

# Some global variables were moved from <a href="javascript:void(0)" data-symbol="MPxDeformerNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_deformer_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxDeformerNode</a> to MPxGeometryFilter. 
# Set some constants to the proper C++ cvars based on the API version.
import maya.cmds as cmds
kApiVersion = cmds.about(apiVersion=True)
if kApiVersion &lt; 201600:
        kInput = OpenMayaMPx.cvar.MPxDeformerNode_input
        kInputGeom = OpenMayaMPx.cvar.MPxDeformerNode_inputGeom
        kOutputGeom = OpenMayaMPx.cvar.MPxDeformerNode_outputGeom
        kEnvelope = OpenMayaMPx.cvar.MPxDeformerNode_envelope
else:
        kInput = OpenMayaMPx.cvar.MPxGeometryFilter_input
        kInputGeom = OpenMayaMPx.cvar.MPxGeometryFilter_inputGeom
        kOutputGeom = OpenMayaMPx.cvar.MPxGeometryFilter_outputGeom
        kEnvelope = OpenMayaMPx.cvar.MPxGeometryFilter_envelope


##########################################################
# Plug-in 
##########################################################
class MyDeformerNode(OpenMayaMPx.MPxDeformerNode):
    
    # Static variable(s) which will later be replaced by the node&#39;s attribute(s).
    boundingBoxScaleAttribute = OpenMaya.MObject()
    meshInflationAttribute    = OpenMaya.MObject()
    
    
    def __init__(self):
        &#39;&#39;&#39; Constructor. &#39;&#39;&#39;
        # (!) Make sure you call the base class&#39;s constructor.
        OpenMayaMPx.MPxDeformerNode.__init__(self)
        
    
    def deform(self, pDataBlock, pGeometryIterator, pLocalToWorldMatrix, pGeometryIndex):
        &#39;&#39;&#39; Deform each vertex using the geometry iterator. &#39;&#39;&#39;
        
        # The envelope determines the overall weight of the deformer on the mesh.
        # The envelope is obtained via the OpenMayaMPx.cvar.MPxDeformerNode_envelope (pre Maya 2016) or
        # OpenMayaMPx.cvar.MPxGeometryFilter_envelope (Maya 2016) variable.
        # This variable and others like it are generated by SWIG to expose variables or constants declared in C++ header files. 
        envelopeAttribute = kEnvelope
        envelopeValue = pDataBlock.inputValue( envelopeAttribute ).asFloat()
        
        # Get the value of the mesh inflation node attribute.
        meshInflationHandle = pDataBlock.inputValue( MyDeformerNode.meshInflationAttribute )
        meshInflation = meshInflationHandle.asDouble()
        
        # Get the value of the bounding box scale node attribute.
        boundingBoxScaleHandle = pDataBlock.inputValue( MyDeformerNode.boundingBoxScaleAttribute )
        boundingBoxScale = boundingBoxScaleHandle.asDouble()

        # Get the input mesh from the datablock using our getDeformerInputGeometry() helper function.     
        inputGeometryObject = self.getDeformerInputGeometry(pDataBlock, pGeometryIndex)


        # Compute the bounding box using the input the mesh.
        boundingBox = self.getBoundingBox( inputGeometryObject, boundingBoxScale )

        
        # Obtain the list of normals for each vertex in the mesh.
        normals = OpenMaya.MFloatVectorArray()
        meshFn = OpenMaya.MFnMesh( inputGeometryObject )
        meshFn.getVertexNormals( True, normals, OpenMaya.MSpace.kTransform )
        
        
        # Iterate over the vertices to move them.
        global vertexIncrement
        while not pGeometryIterator.isDone():
            
            # Obtain the vertex normal of the geometry. This normal is the vertex&#39;s averaged normal value if that
            # vertex is shared among several polygons.  
            vertexIndex = pGeometryIterator.index()
            normal = OpenMaya.MVector( normals[vertexIndex] ) # Cast the <a href="javascript:void(0)" data-symbol="MFloatVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_float_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFloatVector</a> into a simple vector.
            
            # Increment the point along the vertex normal.
            point = pGeometryIterator.position()
            newPoint = point + ( normal * vertexIncrement * meshInflation * envelopeValue )
                       
            # Clamp the new point within the bounding box.
            self.clampPointInBoundingBox( newPoint, boundingBox )
            
            # Set the position of the current vertex to the new point.
            pGeometryIterator.setPosition( newPoint )
            
            # Jump to the next vertex.
            pGeometryIterator.next()
    
    
    def getDeformerInputGeometry(self, pDataBlock, pGeometryIndex):
        &#39;&#39;&#39;
        Obtain a reference to the input mesh. This mesh will be used to compute our bounding box, and we will also require its normals.
        
        We use MDataBlock.outputArrayValue() to avoid having to recompute the mesh and propagate this recomputation throughout the 
        Dependency Graph.
        
        OpenMayaMPx.cvar.MPxDeformerNode_input and OpenMayaMPx.cvar.MPxDeformerNode_inputGeom (for pre Maya 2016) and 
        OpenMayaMPx.cvar.MPxGeometryFilter_input and OpenMayaMPx.cvar.MPxGeometryFilter_inputGeom (Maya 2016) are SWIG-generated 
        variables which respectively contain references to the deformer&#39;s &#39;input&#39; attribute and &#39;inputGeom&#39; attribute.   
        &#39;&#39;&#39;
        inputAttribute = OpenMayaMPx.cvar.MPxGeometryFilter_input
        inputGeometryAttribute = OpenMayaMPx.cvar.MPxGeometryFilter_inputGeom
        
        inputHandle = pDataBlock.outputArrayValue( inputAttribute )
        inputHandle.jumpToElement( pGeometryIndex )
        inputGeometryObject = inputHandle.outputValue().child( inputGeometryAttribute ).asMesh()
        
        return inputGeometryObject
    
    
    def getBoundingBox(self, pMeshObj, pBoundingBoxScale):
        &#39;&#39;&#39; Calculate a bounding box around the mesh&#39;s vertices. &#39;&#39;&#39;
        
        # Create the bounding box object we will populate with the points of the mesh.
        boundingBox = OpenMaya.MBoundingBox()
        meshFn = OpenMaya.MFnMesh( pMeshObj )
        pointArray = OpenMaya.MPointArray()
        
        # Get the points of the mesh in its local coordinate space.
        meshFn.getPoints( pointArray, OpenMaya.MSpace.kTransform )

        for i in range( 0, pointArray.length() ):
            point = pointArray[i]
            boundingBox.expand( point )
        
        # Expand the bounding box according to the scaling factor.
        newMinPoint = boundingBox.min() * pBoundingBoxScale
        newMaxPoint = boundingBox.max() * pBoundingBoxScale
        boundingBox.expand( newMinPoint )
        boundingBox.expand( newMaxPoint )
        
        return boundingBox
    
    
    def clampPointInBoundingBox(self, pPoint, pBoundingBox):
        &#39;&#39;&#39; Ensure that the given point is contained within the bounding box&#39;s min/max coordinates. &#39;&#39;&#39;
        
        # Define a quick clamping function for internal use within this method body.
        def clamp(pValue, pMin, pMax):
            return max( pMin, min( pValue, pMax ) )
        
        pPoint.x = clamp( pPoint.x, pBoundingBox.min().x, pBoundingBox.max().x )
        pPoint.y = clamp( pPoint.y, pBoundingBox.min().y, pBoundingBox.max().y )
        pPoint.z = clamp( pPoint.z, pBoundingBox.min().z, pBoundingBox.max().z )
        

##########################################################
# Plug-in initialization.
##########################################################
def nodeCreator():
    &#39;&#39;&#39; Creates an instance of our node class and delivers it to Maya as a pointer. &#39;&#39;&#39;
    return OpenMayaMPx.asMPxPtr( MyDeformerNode() )

def nodeInitializer():
    &#39;&#39;&#39; Defines the input and output attributes as static variables in our plug-in class. &#39;&#39;&#39;
    # The following <a href="javascript:void(0)" data-symbol="MFnNumericAttribute" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnNumericAttribute</a> function set will allow us to create our attributes.
    numericAttributeFn = OpenMaya.MFnNumericAttribute()
    
    #==================================
    # INPUT NODE ATTRIBUTE(S)
    #==================================
    # Define the scaling factor attribute of the bounding box around the mesh.
    MyDeformerNode.boundingBoxScaleAttribute = numericAttributeFn.create( &#39;boundingBoxScale&#39;, &#39;bs&#39;, OpenMaya.MFnNumericData.kDouble, 1.5 )
    numericAttributeFn.setMin( 1.0 )
    numericAttributeFn.setMax( 3.0 )
    numericAttributeFn.setStorable( True )
    numericAttributeFn.setWritable( True )
    numericAttributeFn.setReadable( False )
    MyDeformerNode.addAttribute( MyDeformerNode.boundingBoxScaleAttribute )
    
    # Define a mesh inflation attribute, responsible for actually moving the vertices in the direction of their normals.
    MyDeformerNode.meshInflationAttribute = numericAttributeFn.create( &#39;meshInflation&#39;, &#39;mi&#39;, OpenMaya.MFnNumericData.kDouble, 10.0 )
    numericAttributeFn.setMin( 1.0 )
    numericAttributeFn.setMax( 50.0 )
    numericAttributeFn.setStorable( True )
    numericAttributeFn.setWritable( True )
    numericAttributeFn.setReadable( False )
    MyDeformerNode.addAttribute( MyDeformerNode.meshInflationAttribute )
    
    &#39;&#39;&#39; The input geometry node attribute is already declared in OpenMayaMPx.cvar.MPxGeometryFilter_inputGeom &#39;&#39;&#39;

    #==================================
    # OUTPUT NODE ATTRIBUTE(S)
    #==================================
    
    &#39;&#39;&#39; The output geometry node attribute is already declared in OpenMayaMPx.cvar.MPxGeometryFilter_outputGeom &#39;&#39;&#39;
    
    #==================================
    # NODE ATTRIBUTE DEPENDENCIES
    #==================================
    # If any of the inputs change, the output mesh will be recomputed.
    
    print dir(OpenMayaMPx.cvar)
    
    MyDeformerNode.attributeAffects( MyDeformerNode.boundingBoxScaleAttribute, kOutputGeom )
    MyDeformerNode.attributeAffects( MyDeformerNode.meshInflationAttribute, kOutputGeom )
    
    
def initializePlugin( mobject ):
    &#39;&#39;&#39; Initialize the plug-in &#39;&#39;&#39;
    mplugin = OpenMayaMPx.MFnPlugin( mobject )
    try:
        mplugin.registerNode( kPluginNodeName, kPluginNodeId, nodeCreator,
                              nodeInitializer, OpenMayaMPx.MPxNode.kDeformerNode )
    except:
        sys.stderr.write( &#39;Failed to register node: &#39; + kPluginNodeName )
        raise
    
def uninitializePlugin( mobject ):
    &#39;&#39;&#39; Uninitializes the plug-in &#39;&#39;&#39;
    mplugin = OpenMayaMPx.MFnPlugin( mobject )
    try:
        mplugin.deregisterNode( kPluginNodeId )
    except:
        sys.stderr.write( &#39;Failed to deregister node: &#39; + kPluginNodeName )
        raise

##########################################################
# Sample usage.
##########################################################
&#39;&#39;&#39; 
# Copy the following lines and run them in Maya&#39;s Python Script Editor:

import maya.cmds as cmds
cmds.loadPlugin( &#39;boundingBoxDeformer.py&#39; )
cmds.polySphere()
cmds.deformer( type=&#39;boundingBoxDeformer&#39; )

&#39;&#39;&#39;
</pre></div>      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
