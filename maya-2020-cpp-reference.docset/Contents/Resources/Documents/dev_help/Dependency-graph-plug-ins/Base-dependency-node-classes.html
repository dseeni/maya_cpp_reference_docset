<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../style/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../../scripts/prettify.js"></script><script src="../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="pandoc" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><script type="text/javascript" src="../../scripts/utils/adsk.redirect.js"></script>
      <title>Base dependency node classes</title>
   </head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Base dependency node classes</h1>
         </div>

<div class='section'><a id="base-dependency-node-classes"></a></div>
<p>In order for you to write a custom dependency graph node, you must create a new class that derives from one of the base node classes described on this page. Depending on the purpose of the node you want to create, you can choose any of these options as your starting point.</p>
<div class='section'><a id="mpxnode"></a><h2 id="mpxnode">MPxNode</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode</a></span> is the base class for all other dependency graph nodes. It defines a generic interface that is common to all nodes, including the virtual <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode::compute()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html#a6e1aa1e50774080d5aee55f20ffa5503&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html#ae17c4b226f482e2d77c3f99375d1eea0&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode::compute()</a></span> method that you will need to implement in your own node class.</p>
<p>The Maya API offers several other base classes that derive from <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode</a></span>, but that specialize it for use in a particular functional area (described below). Each parent class predefines a set of attributes and often additional class methods. When you use an instance of your custom node class in a scene, Maya recognizes which base class it derives from. It automatically treats your custom node in the same way as it treats other built-in nodes of the same type, and automatically connects to the expected attributes and methods. For example, every kind of locator node, which derives from the <span class='code'>MPxLocator</span> class, has built-in behavior for drawing itself in different colors depending on whether or not it is selected in the viewport. The <span class='code'>compute()</span> method that you implement in your subclass can make use of these predefined attributes as desired, in addition to whatever custom attributes you choose to add for the specific purposes of your node class.</p>
<p>Note that these various sub-classes may have different sets of virtual methods that you need to implement instead of or in addition to the <span class='code'>compute()</span> method inherited from <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode</a></span>. See their class descriptions, examples and other documentation for details.</p>
<div class='section'><a id="mpxlocatornode"></a><h2 id="mpxlocatornode">MPxLocatorNode</h2></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxLocatorNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_locator_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_locator_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxLocatorNode</a></span> parent class is a DAG node which allows you to draw three dimensional graphical elements in the Maya scene. The elements are associated with a location in the scene which can be manipulated using the standard Maya manipulators.</p>
<p>This class can be used for defining entities which have a location in space but no explicit shape, such as a new type of light source, a destination point for the behavior of some other entity, or a construction location for a shape not yet created. The graphical elements drawn by the locator are not rendered. The <span class='code'>MPxLocator</span> class itself draws a default graphic, but a <span class='code'>draw()</span> method is provided which can be implemented in your subclass to perform more specialized drawing.</p>
<div class='section'><a id="mpxgeometryfilter"></a><h2 id="mpxgeometryfilter">MPxGeometryFilter</h2></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryFilter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_geometry_filter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryFilter</a></span> class allows you to take an input geometry shape and deform it. Maya requires a special protocol for performing deformations, and provides a few special methods which you implement.</p>
<p>The first is the <span class='code'>deform()</span> method. The actual deformation does not take place in the <span class='code'>compute()</span> method of deformer nodes but through an internal mechanism which calls the <span class='code'>deform()</span> method.</p>
<p>Two other methods, <span class='code'>accessoryAttribute()</span> and <span class='code'>accessoryNodeSetup()</span> are also defined by the parent class. Accessories are the geometry shapes that you select and manipulate to affect the deformation. This can be a set of wireframe lines, a set of NURBS curves, or any other geometry you desire which can intuitively convey the function of your deformer and affect useful deformations.</p>
<p>Accessories are not required by deformers. Your deformer can function solely based on the predefined input attributes of the <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryFilter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_geometry_filter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryFilter</a></span> class and/or any other attributes you define for your subclass. In this case, simply do not implement the two accessory methods.</p>
<p>See also <a href='#!/url=./dev_help/Writing-a-Deformer-Node.html' title=''>Writing a Deformer Node</a>.</p>
<div class='section'><a id="mpxdeformernode"></a><h3 id="mpxdeformernode">MPxDeformerNode</h3></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxDeformerNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_deformer_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxDeformerNode</a></span> class specializes <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryFilter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_geometry_filter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryFilter</a></span> to handle per-vertex weight lists.</p>
<div class='section'><a id="mpxblendshape"></a><h3 id="mpxblendshape">MPxBlendShape</h3></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxBlendShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_blend_shape.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxBlendShape</a></span> class specializes <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryFilter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_geometry_filter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryFilter</a></span> to handle input targets and weights. Maya treats custom nodes that you derive from this class like the built-in <em>blendShape</em> node.</p>
<div class='section'><a id="mpxskincluster"></a><h3 id="mpxskincluster">MPxSkinCluster</h3></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxSkinCluster" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_skin_cluster.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSkinCluster</a></span> class specializes <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryFilter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_geometry_filter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryFilter</a></span> to handle per-vertex skin weights. Maya treats custom nodes that you derive from this class like the built-in <em>skinCluster</em> node.</p>
<div class='section'><a id="mpxiksolvernode"></a><h2 id="mpxiksolvernode">MPxIkSolverNode</h2></div>
<p>Inverse Kinematics (IK) describes a class of algorithms for animating linkages of rigid bodies based on a set of goals and constraints placed on the linkage. An IK solver is a mathematical procedure for finding a set of rotations and offsets for the links in order to satisfy the goals and constraints.</p>
<p>Solvers can be tailored for different types of linkages or to behave a certain way, such as minimizing the motion of certain joints or keeping certain joint angles between certain ranges. Maya defines a set of solvers which can be used in different situations.</p>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxIkSolverNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_ik_solver_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxIkSolverNode</a></span> allows you to write your own solver and use it on linkages you build in Maya. As with the <span class='code'><a href="javascript:void(0)" data-symbol="MPxDeformerNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_deformer_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxDeformerNode</a></span> class, the real computation of the node is not done in the <span class='code'>compute()</span> method, but in the <span class='code'>doSolve()</span> method. There are several other methods which must be defined when subclassing a new solver. Refer to the <span class='code'><a href="javascript:void(0)" data-symbol="MPxIkSolverNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_ik_solver_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxIkSolverNode</a></span> reference for a description of these methods.</p>
<div class='section'><a id="mpxfieldnode"></a><h2 id="mpxfieldnode">MPxFieldNode</h2></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxFieldNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_field_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxFieldNode</a></span> class lets you define your own dynamic field to affect other geometry in the scene. This node follows the normal dependency graph rules of evaluation in that the work of the node is done in the <span class='code'>compute()</span> method.</p>
<div class='section'><a id="mpxemitternode"></a><h2 id="mpxemitternode">MPxEmitterNode</h2></div>
<p>Emitters are nodes which emit particles in to a Maya scene. Different emitters emit particles in different ways, such as emitting only in one direction, emitting slowly, or emitting randomly from the surface of a sphere. Once the particle is emitted, it is no longer controlled by the emitter node. The <span class='code'><a href="javascript:void(0)" data-symbol="MPxEmitterNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_emitter_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxEmitterNode</a></span> class lets you define the behavior of how particles are emitted. The node follows the normal dependency graph rules of evaluation in that the work of the node is done in the <span class='code'>compute()</span> method.</p>
<div class='section'><a id="mpxfluidemitternode"></a><h3 id="mpxfluidemitternode">MPxFluidEmitterNode</h3></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxFluidEmitterNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_fluid_emitter_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxFluidEmitterNode</a></span> derives from <span class='code'><a href="javascript:void(0)" data-symbol="MPxEmitterNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_emitter_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxEmitterNode</a></span>, and allows the creation and manipulation of dependency graph nodes representing fluid emitters. This is the top level of a hierarchy of emitter node function sets. It permits manipulation of the attributes common to all types of fluid emitters.</p>
<div class='section'><a id="mpxspringnode"></a><h2 id="mpxspringnode">MPxSpringNode</h2></div>
<p>Springs are forces which interact between two endpoints which have mass. Maya defines a default spring force which follows a traditional mathematical model of springs. You can define a new behavior for applying a force between two points in a scene by subclassing from <span class='code'><a href="javascript:void(0)" data-symbol="MPxSpringNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_spring_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSpringNode</a></span>. The predefined attributes supply all of the standard spring constants as well as the positions and masses of the endpoints. The work of the node is done through the <span class='code'>applySpringLaw()</span> method instead of the <span class='code'>compute()</span> method.</p>
<div class='section'><a id="mpxobjectset"></a><h2 id="mpxobjectset">MPxObjectSet</h2></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxObjectSet" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_object_set.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxObjectSet</a></span> class can be used to implement new kinds of sets within Maya that can have selectable/manipulatable components and behave in a similar manner to the objectSet node included in Maya.</p>
<div class='section'><a id="mpxhwshadernode"></a><h2 id="mpxhwshadernode">MPxHwShaderNode</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxHwShaderNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_hw_shader_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxHwShaderNode</a></span> allows the creation of user-defined hwShaders. A hwShader is a node which takes any number of input geometries, deforms them and places the output into the output geometry attribute. See also <a href='#!/url=./dev_help/Writing-a-Hardware-Shading-Node.html' title=''>Writing a Hardware Shading Node</a>.</p>
<div class='section'><a id="mpxtransform"></a><h2 id="mpxtransform">MPxTransform</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxTransform" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_transform.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxTransform</a></span> allows the creation of user defined transform nodes. User defined transform nodes can introduce new transform types or change the transformation order. They are designed to be an extension of the standard Maya transform node and include all of the normal transform attributes. Standard behaviors such as limit enforcement and attribute locking are managed by this class, but may be overridden in derived classes. Although it is not a node, the <span class='code'><a href="javascript:void(0)" data-symbol="MPxTransformationMatrix" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_transformation_matrix.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxTransformationMatrix</a></span> class is used in conjunction with <span class='code'><a href="javascript:void(0)" data-symbol="MPxTransform" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_transform.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxTransform</a></span> to add custom transformation matrices to Maya.</p>
<p>See also <a href='#!/url=./dev_help/Writing-a-Custom-Transform-Node.html' title=''>Writing a Custom Transform Node</a>.</p>
<div class='section'><a id="mpximageplane"></a><h2 id="mpximageplane">MPxImagePlane</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxImagePlane" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_image_plane.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxImagePlane</a></span> allows the creation of new types of image plane nodes. Non-standard image data in the image plane or behavioral changes to this node can be modified using this class.</p>
<div class='section'><a id="mpxparticleattributemappernode"></a><h2 id="mpxparticleattributemappernode">MPxParticleAttributeMapperNode</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxParticleAttributeMapperNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_particle_attribute_mapper_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxParticleAttributeMapperNode</a></span> is the parent class of all user-defined, per particle, attribute mapping nodes. This class allows a plug-in to define the behavior of a new &quot;arrayMapper&quot; node which is commonly used by particles for coloring particles from a texture node.</p>
<div class='section'><a id="mpxconstraint"></a><h2 id="mpxconstraint">MPxConstraint</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxConstraint" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_constraint.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxConstraint</a></span> is the parent class of all user defined constraint nodes. This class works with the <span class='code'><a href="javascript:void(0)" data-symbol="MPxConstraintCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_constraint_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxConstraintCommand</a></span> to provide default Maya constraint functionality.</p>
<div class='section'><a id="mpxmanipulatornode-and-mpxmanipcontainer"></a><h2 id="mpxmanipulatornode-and-mpxmanipcontainer">MPxManipulatorNode and MPxManipContainer</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxManipulatorNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manipulator_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_manipulator_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipulatorNode</a></span> is the base class for a manipulator: a type of node that draws a visual representation of itself in the Maya viewport and accepts input from a user through direct interaction within the viewport. Maya provides several built-in types of manipulators, but if you want to create a new type of manipulator, you can create a new class that derives from <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipulatorNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manipulator_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_manipulator_node.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipulatorNode</a></span> and write virtual methods that determine how the manipulator is drawn and how it reacts to mouse events.</p>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipContainer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manip_container.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_manip_container.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipContainer</a></span> class provides a base interface for an aggregator that interprets the input recorded by one or more base types of manipulator nodes, and that applies that input by changing attributes on other connected nodes. If you write a tool that needs to accept user input through a custom manipulator in the viewport, you can create a new class that derives from <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipContainer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manip_container.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_manip_container.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipContainer</a></span>.</p>
<p>For more information on setting up custom manipulators for your plug-in, see <a href='#!/url=./dev_help/Manipulators.html' title=''>Manipulators</a>.</p>
<div class='section'><a id="mpxsurfaceshape-and-mpxcomponentshape"></a><h2 id="mpxsurfaceshape-and-mpxcomponentshape">MPxSurfaceShape and MPxComponentShape</h2></div>
<p>If you need to create a new kind of shape primitive, you will need to create a new class that derives from <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_surface_shape.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSurfaceShape</a></span> or <span class='code'><a href="javascript:void(0)" data-symbol="MPxComponentShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_component_shape.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxComponentShape</a></span>, which will be used to represent instances of your geometry within the scene hierarchy and the dependency graph. There are also several other related classes that you will need to set up in order to control drawing, selection, etc. For more information on creating custom shapes, see <a href='#!/url=./dev_help/Shapes.html' title=''>Shapes</a>.</p>
<div class='section'><a id="mpxassembly"></a><h2 id="mpxassembly">MPxAssembly</h2></div>
<p>This is the base class for scene assembly nodes. You can derive a new class from <span class='code'><a href="javascript:void(0)" data-symbol="MPxAssembly" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_assembly.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxAssembly</a></span> if you need to extend Maya&#39;s scene assembly system. See the class description for details.</p>
<div class='section'><a id="mpxcameraset"></a><h2 id="mpxcameraset">MPxCameraSet</h2></div>
<p>Maya treats custom nodes that you derive from this class like the built-in <em>cameraSet</em> node. You can derive a new class from <span class='code'><a href="javascript:void(0)" data-symbol="MPxCameraSet" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_camera_set.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxCameraSet</a></span> if you need to customize the way Maya handles your camera layers for stereo viewing.</p>
<div class='section'><a id="mpxmotionpathnode"></a><h2 id="mpxmotionpathnode">MPxMotionPathNode</h2></div>
<p>Maya treats custom nodes that you derive from this class like the built-in <em>motionPath</em> node. You can derive a new class from <span class='code'><a href="javascript:void(0)" data-symbol="MPxMotionPathNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_motion_path_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxMotionPathNode</a></span> if you need to customize the way that Maya evaluates the input animation curve in order to computes and apply new position and orientation values to an animated object moving along a path. See the class description and the <span class='code'><a href="javascript:void(0)" data-symbol="motionPathNode/motionPathNode.cpp" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/motion_path_node_2motion_path_node_8cpp-example.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">motionPathNode/motionPathNode.cpp</a></span> example for details.</p>
<div class='section'><a id="mpxpolytrg"></a><h2 id="mpxpolytrg">MPxPolyTrg</h2></div>
<p>This is the base class for nodes that define a custom face triangulation algorithm for meshes. You can derive a new class from <span class='code'><a href="javascript:void(0)" data-symbol="MPxPolyTrg" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_poly_trg.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxPolyTrg</a></span> if you need to change the way that Maya generates triangles from a given mesh face. See the class description for details.</p>
<div class='section'><a id="mpxthreadeddevicenode-and-mpxclientdevicenode"></a><h2 id="mpxthreadeddevicenode-and-mpxclientdevicenode">MPxThreadedDeviceNode and MPxClientDeviceNode</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxThreadedDeviceNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_threaded_device_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxThreadedDeviceNode</a></span> is the base class for nodes that start a secondary thread at the time the node is created, and that use the secondary thread to acquire data from a device. This allows input from the device to drive a Maya plug, even when Maya is not in playback mode. For details, see the class description and the built-in <em>threadedDevice</em> abstract node.</p>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxClientDeviceNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_client_device_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxClientDeviceNode</a></span> specializes <span class='code'><a href="javascript:void(0)" data-symbol="MPxThreadedDeviceNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_threaded_device_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxThreadedDeviceNode</a></span> for interacting with network devices that act as clients, such as data coming from a TCP socket. For details, see the class description and the built-in <em>clientDevice</em> abstract node.</p>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
