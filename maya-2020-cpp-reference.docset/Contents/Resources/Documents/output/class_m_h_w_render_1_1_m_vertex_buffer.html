<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
<title>C++ API Reference: MVertexBuffer Class Reference</title>
</head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"/><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_h_w_render_1_1_m_vertex_buffer.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
<div>
<div class="head">
<h1>C++ API Reference: MVertexBuffer Class Reference</h1>
</div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>Main Page</span></a></li>
<li><a href="./pages.html"><span>Related Pages</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li class="current"><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="cpp_ref/search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="cpp_ref/search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
<div class="tabs2" id="navrow2">
<ul class="tablist">
<li><a href="./annotated.html"><span>Class List</span></a></li>
<li><a href="./classes.html"><span>Class Index</span></a></li>
<li><a href="./hierarchy.html"><span>Class Hierarchy</span></a></li>
<li><a href="./functions.html"><span>Class Members</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<!-- window showing the filter options -->
<!-- iframe showing the search results (closed by default) -->
<div class="header">
<div class="headertitle">
<div class="title">MVertexBuffer Class Reference<div class="ingroups"><a class="el" href="./group___open_maya_render.html">OpenMayaRender - API module for rendering</a></div></div> </div>
<div id="OverviewLinksDiv"><div class="dynheader closed" id="dynsection-overview" onclick="return toggleVisibility(this)" style="cursor:pointer;"><img alt="+" id="dynsection-overview-trigger" src="cpp_ref/closed.png"/> Related help topics: </div><div class="dyncontent" id="dynsection-overview-content" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Overview-of-the-Viewport-2-0-API/Data-Classes.html">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Data Classes</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/API-constructs/Geometric-Data-MGeometry-.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; API constructs &gt; Geometric Data (MGeometry)</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Geometry-Overrides.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; Geometry Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Customizing-Geometric-Data-for.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Customizing Geometric Data for Shaders</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Geometry-remapping-for-hardware.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Geometry remapping for hardware rendering</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_h_w_render_1_1_m_vertex_buffer.html#pub-methods">Public Member Functions</a> |
<a href="class_m_h_w_render_1_1_m_vertex_buffer.html#pub-static-methods">Static Public Member Functions</a> |
<a href="./class_m_h_w_render_1_1_m_vertex_buffer-members.html">List of all members</a> </div></div><!--header-->
<div class="contents">
<p>Vertex buffer for use with <a class="el" href="./class_m_h_w_render_1_1_m_geometry.html" title="Class for working with geometric structures used to draw objects. ">MGeometry</a>.  
 <a href="./class_m_h_w_render_1_1_m_vertex_buffer.html#details">More...</a></p>
<p><code>#include &lt;MHWGeometry.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06f560575e9472e94f182e7b1a8db5ec"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a06f560575e9472e94f182e7b1a8db5ec">MVertexBuffer</a> (const <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> &amp;<a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43">descriptor</a>, bool softwareStaged=true)</td></tr>
<tr class="memdesc:a06f560575e9472e94f182e7b1a8db5ec"><td class="mdescLeft"> </td><td class="mdescRight">Constructor.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a06f560575e9472e94f182e7b1a8db5ec">More...</a><br/></td></tr>
<tr class="separator:a06f560575e9472e94f182e7b1a8db5ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e8e8fbbca058243c4796cc631165a66"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a2e8e8fbbca058243c4796cc631165a66">MVertexBuffer</a> (const <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a> &amp;)</td></tr>
<tr class="memdesc:a2e8e8fbbca058243c4796cc631165a66"><td class="mdescLeft"> </td><td class="mdescRight">Copy constructor.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a2e8e8fbbca058243c4796cc631165a66">More...</a><br/></td></tr>
<tr class="separator:a2e8e8fbbca058243c4796cc631165a66"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06e0d7ea458c5cacb6cb7ee7a66ab876"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a06e0d7ea458c5cacb6cb7ee7a66ab876">~MVertexBuffer</a> ()</td></tr>
<tr class="memdesc:a06e0d7ea458c5cacb6cb7ee7a66ab876"><td class="mdescLeft"> </td><td class="mdescRight">Destructor.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a06e0d7ea458c5cacb6cb7ee7a66ab876">More...</a><br/></td></tr>
<tr class="separator:a06e0d7ea458c5cacb6cb7ee7a66ab876"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a331cfb987f5f4d632a747e7fbbbe4a43"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43">descriptor</a> () const </td></tr>
<tr class="memdesc:a331cfb987f5f4d632a747e7fbbbe4a43"><td class="mdescLeft"> </td><td class="mdescRight">Get the the buffer descriptor.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43">More...</a><br/></td></tr>
<tr class="separator:a331cfb987f5f4d632a747e7fbbbe4a43"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad7bcab0d1707ef0da22fc72ada62c40e"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e">resourceHandle</a> () const </td></tr>
<tr class="memdesc:ad7bcab0d1707ef0da22fc72ada62c40e"><td class="mdescLeft"> </td><td class="mdescRight">Gets a graphics device dependent handle to a vertex buffer.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e">More...</a><br/></td></tr>
<tr class="separator:ad7bcab0d1707ef0da22fc72ada62c40e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ade1f9567b0b118122663a0ae42424537"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#ade1f9567b0b118122663a0ae42424537">resourceHandle</a> (void *handle, unsigned int size)</td></tr>
<tr class="memdesc:ade1f9567b0b118122663a0ae42424537"><td class="mdescLeft"> </td><td class="mdescRight">Directly set the graphics-device-dependent hardware buffer resource handle.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#ade1f9567b0b118122663a0ae42424537">More...</a><br/></td></tr>
<tr class="separator:ade1f9567b0b118122663a0ae42424537"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa8d1538f7339521cd85c52d140d0bc6c"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aa8d1538f7339521cd85c52d140d0bc6c">hasCustomResourceHandle</a> () const </td></tr>
<tr class="memdesc:aa8d1538f7339521cd85c52d140d0bc6c"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if this vertex buffer is using a custom resource handle set by the plugin using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#ade1f9567b0b118122663a0ae42424537" title="Directly set the graphics-device-dependent hardware buffer resource handle. ">MVertexBuffer::resourceHandle(void*, unsigned int)</a>.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#aa8d1538f7339521cd85c52d140d0bc6c">More...</a><br/></td></tr>
<tr class="separator:aa8d1538f7339521cd85c52d140d0bc6c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf8ad9c60e845cd4fd84c171c0a63a27"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27">lockResourceHandle</a> ()</td></tr>
<tr class="memdesc:adf8ad9c60e845cd4fd84c171c0a63a27"><td class="mdescLeft"> </td><td class="mdescRight">Lock the resource handle.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27">More...</a><br/></td></tr>
<tr class="separator:adf8ad9c60e845cd4fd84c171c0a63a27"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adab064164207ef83bb764a2c57524a14"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adab064164207ef83bb764a2c57524a14">unlockResourceHandle</a> ()</td></tr>
<tr class="memdesc:adab064164207ef83bb764a2c57524a14"><td class="mdescLeft"> </td><td class="mdescRight">Unlock the resource handle.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#adab064164207ef83bb764a2c57524a14">More...</a><br/></td></tr>
<tr class="separator:adab064164207ef83bb764a2c57524a14"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aff9e3c2ed40ad0c0f0fe55668670d071"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a> (unsigned int size, bool writeOnly)</td></tr>
<tr class="memdesc:aff9e3c2ed40ad0c0f0fe55668670d071"><td class="mdescLeft"> </td><td class="mdescRight">Get a pointer to memory for the buffer.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">More...</a><br/></td></tr>
<tr class="separator:aff9e3c2ed40ad0c0f0fe55668670d071"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aafb3736206f8a73c0fc74757919cfb83"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a> (void *buffer)</td></tr>
<tr class="memdesc:aafb3736206f8a73c0fc74757919cfb83"><td class="mdescLeft"> </td><td class="mdescRight">Commit the data stored in the memory given by <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> to the buffer.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">More...</a><br/></td></tr>
<tr class="separator:aafb3736206f8a73c0fc74757919cfb83"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abc9e783c4d7826700a6a6824451f8230"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230">map</a> ()</td></tr>
<tr class="memdesc:abc9e783c4d7826700a6a6824451f8230"><td class="mdescLeft"> </td><td class="mdescRight">Get a read-only pointer to the existing content of the buffer.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230">More...</a><br/></td></tr>
<tr class="separator:abc9e783c4d7826700a6a6824451f8230"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ffeb3b5abb3d61f62b58a391816201c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a> ()</td></tr>
<tr class="memdesc:a1ffeb3b5abb3d61f62b58a391816201c"><td class="mdescLeft"> </td><td class="mdescRight">Release the data exposed by <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a>.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">More...</a><br/></td></tr>
<tr class="separator:a1ffeb3b5abb3d61f62b58a391816201c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af083045e46c6c887e538a390aaf503cc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#af083045e46c6c887e538a390aaf503cc">update</a> (const void *buffer, unsigned int destOffset, unsigned int numVerts, bool truncateIfSmaller)</td></tr>
<tr class="memdesc:af083045e46c6c887e538a390aaf503cc"><td class="mdescLeft"> </td><td class="mdescRight">Set a portion (or all) of the contents of the <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> using the data in the provided software buffer.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#af083045e46c6c887e538a390aaf503cc">More...</a><br/></td></tr>
<tr class="separator:af083045e46c6c887e538a390aaf503cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a75d84312cb36261792b879ffc61e7e16"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a75d84312cb36261792b879ffc61e7e16">unload</a> ()</td></tr>
<tr class="memdesc:a75d84312cb36261792b879ffc61e7e16"><td class="mdescLeft"> </td><td class="mdescRight">If the buffer is resident in GPU memory, calling this method will move it to system memory and free the GPU memory.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a75d84312cb36261792b879ffc61e7e16">More...</a><br/></td></tr>
<tr class="separator:a75d84312cb36261792b879ffc61e7e16"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a42db940e8d3c623487a4e2c34024751c"><td align="right" class="memItemLeft" valign="top">unsigned int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a42db940e8d3c623487a4e2c34024751c">vertexCount</a> () const </td></tr>
<tr class="memdesc:a42db940e8d3c623487a4e2c34024751c"><td class="mdescLeft"> </td><td class="mdescRight">Get the size of the vertex buffer.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a42db940e8d3c623487a4e2c34024751c">More...</a><br/></td></tr>
<tr class="separator:a42db940e8d3c623487a4e2c34024751c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3c77f256958aa1993cd985b5cf8861f1"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a3c77f256958aa1993cd985b5cf8861f1">acquire</a> (unsigned int size)</td></tr>
<tr class="memdesc:a3c77f256958aa1993cd985b5cf8861f1"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a3c77f256958aa1993cd985b5cf8861f1">More...</a><br/></td></tr>
<tr class="separator:a3c77f256958aa1993cd985b5cf8861f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4524a010960fddcc66fd97387a34cdfe"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a4524a010960fddcc66fd97387a34cdfe">getVertexBuffer</a> () const </td></tr>
<tr class="memdesc:a4524a010960fddcc66fd97387a34cdfe"><td class="mdescLeft"> </td><td class="mdescRight">Private friend class only access to the internal OGS vertex buffer.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a4524a010960fddcc66fd97387a34cdfe">More...</a><br/></td></tr>
<tr class="separator:a4524a010960fddcc66fd97387a34cdfe"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td align="right" class="memItemLeft" valign="top">static const char * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this class.  <a href="class_m_h_w_render_1_1_m_vertex_buffer.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br/></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Vertex buffer for use with <a class="el" href="./class_m_h_w_render_1_1_m_geometry.html" title="Class for working with geometric structures used to draw objects. ">MGeometry</a>. </p>
<p>This class represents a vertex buffer with attributes described by the descriptor member.</p>
<p>When retrieving a vertex buffer for binding to custom shaders (<a class="el" href="./class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a>), <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e" title="Gets a graphics device dependent handle to a vertex buffer. ">resourceHandle()</a> may be called to get the device dependent handle to the vertex buffer on the GPU.</p>
<p>When creating a vertex buffer to supply geometric data to Maya (<a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a>), <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> may be called to get a pointer to a block of memory to fill with said data. Once filled, <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83" title="Commit the data stored in the memory given by acquire() to the buffer. ">commit()</a> must be called to apply the data to the buffer.</p>
<p>When exploring the contents of an already filled vertex buffer, <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a> may be called to get a pointer to the read-only block of memory containing the data. Once done exploring, <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c" title="Release the data exposed by map(). ">unmap()</a> must be called to allow the buffer to be reused. </p>
<dl class="section"><div class="dynheader closed" id="dynsection-example0" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example0-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example0-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#_a112">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" href="./api_mesh_shape_2api_mesh_geometry_override_8h-example.html#_a19">apiMeshShape/apiMeshGeometryOverride.h</a>, <a class="el" href="./api_mesh_shape_2api_mesh_sub_scene_override_8cpp-example.html#_a99">apiMeshShape/apiMeshSubSceneOverride.cpp</a>, <a class="el" href="./api_mesh_shape_2api_mesh_sub_scene_override_8h-example.html#_a25">apiMeshShape/apiMeshSubSceneOverride.h</a>, <a class="el" href="./cg_fx_2cgfx_shader_node_8cpp-example.html#_a143">cgFx/cgfxShaderNode.cpp</a>, <a class="el" href="./custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#_a23">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" href="./dx11_shader_2crack_free_primitive_generator_8cpp-example.html#_a5">dx11Shader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./dx11_shader_2dx11_shader_8cpp-example.html#_a263">dx11Shader/dx11Shader.cpp</a>, <a class="el" href="./foot_print_node__animated_material_2foot_print_node__geometry_override__animated_material_8cpp-example.html#_a79">footPrintNode_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</a>, <a class="el" href="./foot_print_node__geometry_override_2foot_print_node__geometry_override_8cpp-example.html#_a69">footPrintNode_GeometryOverride/footPrintNode_GeometryOverride.cpp</a>, <a class="el" href="./foot_print_node__sub_scene_override_2foot_print_node__sub_scene_override_8cpp-example.html#_a47">footPrintNode_SubSceneOverride/footPrintNode_SubSceneOverride.cpp</a>, <a class="el" href="./geometry_override_example1_2geometry_override_example1_8cpp-example.html#_a31">geometryOverrideExample1/geometryOverrideExample1.cpp</a>, <a class="el" href="./geometry_override_example2_2geometry_override_example2_8cpp-example.html#_a25">geometryOverrideExample2/geometryOverrideExample2.cpp</a>, <a class="el" href="./geometry_replicator_2geometry_replicator_8cpp-example.html#_a51">geometryReplicator/geometryReplicator.cpp</a>, <a class="el" href="./glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html#_a5">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</a>, <a class="el" href="./glsl_shader_2crack_free_primitive_generator_8cpp-example.html#_a5">glslShader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./gpu_cache_2gpu_cache_cmd_8cpp-example.html#_a68">gpuCache/gpuCacheCmd.cpp</a>, <a class="el" href="./gpu_cache_2gpu_cache_sub_scene_override_8cpp-example.html#_a2">gpuCache/gpuCacheSubSceneOverride.cpp</a>, <a class="el" href="./gpu_cache_2gpu_cache_sub_scene_override_8h-example.html#_a3">gpuCache/gpuCacheSubSceneOverride.h</a>, <a class="el" href="./hw_phong_shader_2hw_phong_shader_8cpp-example.html#_a75">hwPhongShader/hwPhongShader.cpp</a>, <a class="el" href="./tessellated_quad_2_crack_free_primitive_generator_8cpp-example.html#_a5">tessellatedQuad/CrackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#_a44">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>, <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#_a12">vertexBufferGenerator/vertexBufferGenerator.cpp</a>, and <a class="el" href="./vertex_buffer_mutator_2vertex_buffer_mutator_8cpp-example.html#_a2">vertexBufferMutator/vertexBufferMutator.cpp</a>.</dd></div>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a06f560575e9472e94f182e7b1a8db5ec"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> &amp; </td>
<td class="paramname"><em>desc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>softwareStaged</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>A descriptor to define the vertex buffer attributes </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">softwareStaged</td><td>A flag defining how buffers are managed and updated. When software staged is specified the system may keep an extra copy of the buffer in system memory for fast read-back and access. Software staging is useful for cases where the buffer is written once and changes infrequently. Software staging helps to improve consolidation performance and handling under low memory conditions. For buffers that change frequently (animated) and are accessed in write only mode you may see better performance if you set this option to false. (default: true)</td></tr>
</table>
</dd>
</dl>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> the MVertexBuffers used must be software staged. </p>
</div>
</div>
<a class="anchor" id="a2e8e8fbbca058243c4796cc631165a66"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a> &amp; </td>
<td class="paramname"><em>buffer</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>
<p>Use this constructor to share buffer data across multiple render items. The underlying hardware buffer will be shared with the buffer being copied.</p>
<p>Do not use this constructor to copy buffers that are currently being edited. A debug assertion will be thrown if the buffer passed in has been acquired but not yet committed.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to share data with. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a06e0d7ea458c5cacb6cb7ee7a66ab876"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">~<a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>
<p>Note that it is an error to delete <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> objects that are owned by or in use by an <a class="el" href="./class_m_h_w_render_1_1_m_geometry.html" title="Class for working with geometric structures used to draw objects. ">MGeometry</a> object. Such actions may cause instability.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to destroy <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> objects during <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#aa4c938a24a336e5ca1c28372bc6972d7" title="Called after all other stages are completed. ">MPxGeometryOverride::cleanUp()</a> or <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with VP2 Custom Caching in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to destroy <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> objects during <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>. </p>
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a331cfb987f5f4d632a747e7fbbbe4a43"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/descriptor"></a>const <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> &amp; descriptor </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the the buffer descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer descriptor </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example1" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example1-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example1-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8cpp-example.html#a145">cgFx/cgfxShaderNode.cpp</a>, <a class="el" href="./custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#a26">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" href="./dx11_shader_2crack_free_primitive_generator_8cpp-example.html#a8">dx11Shader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./dx11_shader_2dx11_shader_8cpp-example.html#a266">dx11Shader/dx11Shader.cpp</a>, <a class="el" href="./glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html#a8">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</a>, <a class="el" href="./glsl_shader_2crack_free_primitive_generator_8cpp-example.html#a8">glslShader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./gpu_cache_2gpu_cache_sub_scene_override_8cpp-example.html#a3">gpuCache/gpuCacheSubSceneOverride.cpp</a>, <a class="el" href="./hw_phong_shader_2hw_phong_shader_8cpp-example.html#a77">hwPhongShader/hwPhongShader.cpp</a>, <a class="el" href="./tessellated_quad_2_crack_free_primitive_generator_8cpp-example.html#a8">tessellatedQuad/CrackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#a15">vertexBufferGenerator/vertexBufferGenerator.cpp</a>, and <a class="el" href="./vertex_buffer_mutator_2vertex_buffer_mutator_8cpp-example.html#a5">vertexBufferMutator/vertexBufferMutator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ad7bcab0d1707ef0da22fc72ada62c40e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void * resourceHandle </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Gets a graphics device dependent handle to a vertex buffer. </p>
<p>For OpenGL the return value is a pointer to an OpenGL identifier (GLuint) to an vertex buffer containing the data. Buffers can be set via the OpenGL API for drawing purposes. (e.g. using glBindBuffer). For DirectX11 the return value is a pointer to an ID3D11Buffer interface of the vertex buffer.</p>
<p>A NULL pointer will be returned if the graphics device dependent handle is not yet available.</p>
<p>If the pointer is not NULL, the value is only guaranteed to exist during the current draw. The value should never be cached or modified.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to access the resourceHandle of an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to device dependent vertex data </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example2" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example2-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example2-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8cpp-example.html#a146">cgFx/cgfxShaderNode.cpp</a>, and <a class="el" href="./dx11_shader_2dx11_shader_8cpp-example.html#a267">dx11Shader/dx11Shader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ade1f9567b0b118122663a0ae42424537"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void resourceHandle </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Directly set the graphics-device-dependent hardware buffer resource handle. </p>
<p>This will result in the creation of a custom user vertex buffer. Maya can render it, but the plugin owns the underlying device resource. When the Maya buffer is deleted, the actual hardware buffer will not be deleted. These buffers cannot be filled with Acquire or read-back with Map. They must be created and pre-filled, by the plugin.</p>
<p>Multiple MVertexBuffers with the same handle pointer indicate an interleaved vertex format, with the offset member of the descriptor determining the field order.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to set the resourceHandle of an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>For OpenGL, handle is a pointer to a GLuint resource identifier for a vertex buffer object. For DirectX11, handle is a pointer to an ID3D11Buffer interface. This pointer must remain valid after <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#a37c7a59c1e34ed5e0528fe0ac351b519" title="Implementations of this method should create and populate vertex and index buffers on the MGeometry i...">MPxGeometryOverride::populateGeometry()</a> returns, though not indefinitely after that. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of 4-byte words (floats) in the indicated buffer. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa8d1538f7339521cd85c52d140d0bc6c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool hasCustomResourceHandle </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns true if this vertex buffer is using a custom resource handle set by the plugin using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#ade1f9567b0b118122663a0ae42424537" title="Directly set the graphics-device-dependent hardware buffer resource handle. ">MVertexBuffer::resourceHandle(void*, unsigned int)</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this vertex buffer is using a custom resource handle. </dd></dl>
</div>
</div>
<a class="anchor" id="adf8ad9c60e845cd4fd84c171c0a63a27"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void lockResourceHandle </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Lock the resource handle. </p>
<p>The pointer returned from <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e" title="Gets a graphics device dependent handle to a vertex buffer. ">resourceHandle()</a> is guaranteed to exist between <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> and <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adab064164207ef83bb764a2c57524a14" title="Unlock the resource handle. ">unlockResourceHandle()</a>.</p>
<p><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> may store data in system memory, GPU memory or both. Direct access to the GPU representation of the data is possible through the buffer's <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e" title="Gets a graphics device dependent handle to a vertex buffer. ">resourceHandle()</a>. If the GPU representation of the data is to be directly modified using an external graphics or compute API, then <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> must be called on the <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> once, before any modifications to the buffer are made.</p>
<p>While a resource handle is locked, any external modifications to the GPU buffer will be recognized by Maya.</p>
<p>While a resource handle is locked, consolidated world will take longer to consolidate the corresponding object. After unlocking a resource handle, consolidated world will take longer to consolidate the corresponding object one more time, the first time the unlocked resource handle is consolidated.</p>
<p>Calling <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> and <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adab064164207ef83bb764a2c57524a14" title="Unlock the resource handle. ">unlockResourceHandle()</a> on a custom resource handle has no effect.</p>
<p>Reallocating or deleting the GPU representation of the data between <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> and <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adab064164207ef83bb764a2c57524a14" title="Unlock the resource handle. ">unlockResourceHandle()</a> will result in undefined behavior. <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a>, <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83" title="Commit the data stored in the memory given by acquire() to the buffer. ">commit()</a> and <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#af083045e46c6c887e538a390aaf503cc" title="Set a portion (or all) of the contents of the MVertexBuffer using the data in the provided software b...">update()</a> may reallocate the GPU representation. <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a75d84312cb36261792b879ffc61e7e16" title="If the buffer is resident in GPU memory, calling this method will move it to system memory and free t...">unload()</a> may delete the GPU representation.</p>
<p><a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a> and <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c" title="Release the data exposed by map(). ">unmap()</a> will work if they are called between <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> and <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adab064164207ef83bb764a2c57524a14" title="Unlock the resource handle. ">unlockResourceHandle()</a>. They operate on the GPU representation.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to access the GPU representation of the buffer. Therefore, calling <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a>, or calling <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a>, <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83" title="Commit the data stored in the memory given by acquire() to the buffer. ">commit()</a>, <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#af083045e46c6c887e538a390aaf503cc" title="Set a portion (or all) of the contents of the MVertexBuffer using the data in the provided software b...">update()</a>, <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a> or <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c" title="Release the data exposed by map(). ">unmap()</a> on a locked resource handle is only safe during <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#aa4c938a24a336e5ca1c28372bc6972d7" title="Called after all other stages are completed. ">MPxGeometryOverride::cleanUp()</a> or <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride</a>.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with VP2 Custom Caching in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to access the GPU representation of the buffer during <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>. </p>
</div>
</div>
<a class="anchor" id="adab064164207ef83bb764a2c57524a14"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void unlockResourceHandle </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Unlock the resource handle. </p>
<p>The pointer returned from resourceHandle is not guaranteed to exist any more.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to unlockResourceHande() an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a>.</p>
<p>See <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> for more details. </p>
</div>
</div>
<a class="anchor" id="aff9e3c2ed40ad0c0f0fe55668670d071"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void * acquire </td>
<td>(</td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>writeOnly</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to memory for the buffer. </p>
<p>This method is meant to be used in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#a37c7a59c1e34ed5e0528fe0ac351b519" title="Implementations of this method should create and populate vertex and index buffers on the MGeometry i...">MPxGeometryOverride::populateGeometry()</a> in order to provide data to Maya for drawing the associated object. The size of the buffer returned will be (size * descriptor.dataTypeSize() * descriptor.dimension()) bytes. The memory for the buffer is managed internally.</p>
<p>Note that not all vertex buffer descriptors can be used to create vertex buffers as not all combinations of data types, dimensions and semantics are currently supported. If the descriptor for this buffer is not supported this method will return NULL.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer to acquire. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">writeOnly</td><td>Specified if the returned memory should be uninitialized or filled with actual buffer content. When the current buffer content is not needed, it is preferable to set the writeOnly flag to true for better performance.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to memory for the buffer, or NULL on failure </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example3" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example3-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example3-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#a119">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" href="./custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#a30">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" href="./foot_print_node__animated_material_2foot_print_node__geometry_override__animated_material_8cpp-example.html#a87">footPrintNode_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</a>, <a class="el" href="./foot_print_node__geometry_override_2foot_print_node__geometry_override_8cpp-example.html#a77">footPrintNode_GeometryOverride/footPrintNode_GeometryOverride.cpp</a>, <a class="el" href="./geometry_override_example1_2geometry_override_example1_8cpp-example.html#a33">geometryOverrideExample1/geometryOverrideExample1.cpp</a>, <a class="el" href="./geometry_override_example2_2geometry_override_example2_8cpp-example.html#a27">geometryOverrideExample2/geometryOverrideExample2.cpp</a>, <a class="el" href="./geometry_replicator_2geometry_replicator_8cpp-example.html#a54">geometryReplicator/geometryReplicator.cpp</a>, <a class="el" href="./tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a52">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>, <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#a20">vertexBufferGenerator/vertexBufferGenerator.cpp</a>, and <a class="el" href="./vertex_buffer_mutator_2vertex_buffer_mutator_8cpp-example.html#a12">vertexBufferMutator/vertexBufferMutator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aafb3736206f8a73c0fc74757919cfb83"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void commit </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>buffer</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Commit the data stored in the memory given by <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> to the buffer. </p>
<p>If this method is not called, the acquired buffer will not be used in drawing. The pointer must be the same pointer returned from <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a>.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83" title="Commit the data stored in the memory given by acquire() to the buffer. ">commit()</a> an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the data. </td></tr>
</table>
</dd>
</dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example4" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example4-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example4-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#a123">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" href="./custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#a35">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" href="./foot_print_node__animated_material_2foot_print_node__geometry_override__animated_material_8cpp-example.html#a88">footPrintNode_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</a>, <a class="el" href="./foot_print_node__geometry_override_2foot_print_node__geometry_override_8cpp-example.html#a78">footPrintNode_GeometryOverride/footPrintNode_GeometryOverride.cpp</a>, <a class="el" href="./geometry_override_example1_2geometry_override_example1_8cpp-example.html#a34">geometryOverrideExample1/geometryOverrideExample1.cpp</a>, <a class="el" href="./geometry_override_example2_2geometry_override_example2_8cpp-example.html#a28">geometryOverrideExample2/geometryOverrideExample2.cpp</a>, <a class="el" href="./geometry_replicator_2geometry_replicator_8cpp-example.html#a55">geometryReplicator/geometryReplicator.cpp</a>, <a class="el" href="./tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a53">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>, <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#a21">vertexBufferGenerator/vertexBufferGenerator.cpp</a>, and <a class="el" href="./vertex_buffer_mutator_2vertex_buffer_mutator_8cpp-example.html#a13">vertexBufferMutator/vertexBufferMutator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="abc9e783c4d7826700a6a6824451f8230"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void * map </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get a read-only pointer to the existing content of the buffer. </p>
<p>Writing new content in this memory block is not supported and can lead to unexpected behavior.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a> an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to memory for the buffer, or NULL on failure </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example5" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example5-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example5-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#a120">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" href="./dx11_shader_2crack_free_primitive_generator_8cpp-example.html#a10">dx11Shader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./dx11_shader_2dx11_shader_8cpp-example.html#a273">dx11Shader/dx11Shader.cpp</a>, <a class="el" href="./glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html#a10">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</a>, <a class="el" href="./glsl_shader_2crack_free_primitive_generator_8cpp-example.html#a10">glslShader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./hw_phong_shader_2hw_phong_shader_8cpp-example.html#a80">hwPhongShader/hwPhongShader.cpp</a>, <a class="el" href="./tessellated_quad_2_crack_free_primitive_generator_8cpp-example.html#a10">tessellatedQuad/CrackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a63">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>, and <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#a26">vertexBufferGenerator/vertexBufferGenerator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a1ffeb3b5abb3d61f62b58a391816201c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void unmap </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Release the data exposed by <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a>. </p>
<p>If this method is not called, the buffer will not be recycled.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c" title="Release the data exposed by map(). ">unmap()</a> an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a>.</p>
<p>In OpenGL mode, this will leave the ARRAY_BUFFER and ELEMENT_ARRAY_BUFFER bindings to 0. </p>
<dl class="section"><div class="dynheader closed" id="dynsection-example6" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example6-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example6-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#a124">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" href="./dx11_shader_2crack_free_primitive_generator_8cpp-example.html#a14">dx11Shader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./dx11_shader_2dx11_shader_8cpp-example.html#a274">dx11Shader/dx11Shader.cpp</a>, <a class="el" href="./glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html#a14">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</a>, <a class="el" href="./glsl_shader_2crack_free_primitive_generator_8cpp-example.html#a14">glslShader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./hw_phong_shader_2hw_phong_shader_8cpp-example.html#a82">hwPhongShader/hwPhongShader.cpp</a>, <a class="el" href="./tessellated_quad_2_crack_free_primitive_generator_8cpp-example.html#a14">tessellatedQuad/CrackFreePrimitiveGenerator.cpp</a>, <a class="el" href="./tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a65">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>, and <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#a27">vertexBufferGenerator/vertexBufferGenerator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="af083045e46c6c887e538a390aaf503cc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/update"></a><a class="el" href="./class_m_status.html">MStatus</a> update </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>buffer</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>destOffset</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>numVerts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>truncateIfSmaller</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a portion (or all) of the contents of the <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> using the data in the provided software buffer. </p>
<p>The internal hardware buffer will be allocated or reallocated to fit if required, according to the vertex size from the descriptor. The buffer size will be at least (size * descriptor.dataTypeSize() * descriptor.dimension()) bytes. If this operation requires enlarging an existing buffer and specifies an offset to update only a portion of the contents, then the old data before that offset may not be preserved.</p>
<p>Note that not all vertex buffer descriptors can be used to create vertex buffers as not all combinations of data types, dimensions and semantics are currently supported. If the descriptor for this buffer is not supported this method will return <a class="el" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MStatus::kFailure</a>.</p>
<p>If the vertex data is already available in the correct format for a simple memory copy, then this function should be more efficient than using acquire/commit or map/unmap. It should require fewer buffer copy operations.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#af083045e46c6c887e538a390aaf503cc" title="Set a portion (or all) of the contents of the MVertexBuffer using the data in the provided software b...">update()</a> an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The input data buffer, starting with the first vertex to copy. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">destOffset</td><td>The offset (in vertices) from the beginning of the buffer to start writing to. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">numVerts</td><td>The number of vertices to copy. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">truncateIfSmaller</td><td>If true and offset+numVerts is less than the pre-existing size of the buffer, then the buffer contents will be truncated to the new size. Truncating the buffer size will not cause a reallocation and will not lose data before the destOffset.</td></tr>
</table>
</dd>
</dl>
<ul>
<li><b><a class="el" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1" title="The operation was successful. ">MStatus::kSuccess</a></b> The method was successful </li>
<li><b><a class="el" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af8c5f748892ec74b32719c8fba7767e1" title="An invalid parameter was provided. ">MStatus::kInvalidParameter</a></b> Buffer was nullptr or numVerts was 0. </li>
<li><b><a class="el" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MStatus::kFailure</a></b> The descriptor was not valid or there was an error while allocating or updating the hardware buffer. </li>
</ul>
</div>
</div>
<a class="anchor" id="a75d84312cb36261792b879ffc61e7e16"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void unload </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>If the buffer is resident in GPU memory, calling this method will move it to system memory and free the GPU memory. </p>
<p>The buffer will be automatically reloaded into GPU memory the next time it is needed to draw an object. This method may be used to help manage GPU memory when working with extremely large sets of data.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a75d84312cb36261792b879ffc61e7e16" title="If the buffer is resident in GPU memory, calling this method will move it to system memory and free t...">unload()</a> an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> object during <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#aa4c938a24a336e5ca1c28372bc6972d7" title="Called after all other stages are completed. ">MPxGeometryOverride::cleanUp()</a> or <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with VP2 Custom Caching in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a75d84312cb36261792b879ffc61e7e16" title="If the buffer is resident in GPU memory, calling this method will move it to system memory and free t...">unload()</a> an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> buffer during <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>. </p>
</div>
</div>
<a class="anchor" id="a42db940e8d3c623487a4e2c34024751c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">unsigned int vertexCount </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the size of the vertex buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the vertex buffer. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example7" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example7-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example7-content" style="display:none;"><dd><a class="el" href="./dx11_shader_2dx11_shader_8cpp-example.html#a265">dx11Shader/dx11Shader.cpp</a>, <a class="el" href="./geometry_replicator_2geometry_replicator_8cpp-example.html#a53">geometryReplicator/geometryReplicator.cpp</a>, <a class="el" href="./gpu_cache_2gpu_cache_sub_scene_override_8cpp-example.html#a5">gpuCache/gpuCacheSubSceneOverride.cpp</a>, <a class="el" href="./hw_phong_shader_2hw_phong_shader_8cpp-example.html#a81">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" href="./vertex_buffer_mutator_2vertex_buffer_mutator_8cpp-example.html#a11">vertexBufferMutator/vertexBufferMutator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const char * className </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class. </dd></dl>
</div>
</div>
<a class="anchor" id="a3c77f256958aa1993cd985b5cf8861f1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void * acquire </td>
<td>(</td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>size</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is obsolete. </p>
<p>[From Maya 2019] </p><dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000242">Deprecated:</a></b></dt><dd>Use void* <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire(unsigned int size, bool writeOnly)</a> instead </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000239">Deprecated:</a></b></dt><dd>Please use <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire(unsigned int size, bool writeOnly)</a> instead.</dd></dl>
<p>Get a pointer to memory for the buffer. This method is meant to be used in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html#a37c7a59c1e34ed5e0528fe0ac351b519" title="Implementations of this method should create and populate vertex and index buffers on the MGeometry i...">MPxGeometryOverride::populateGeometry()</a> in order to provide data to Maya for drawing the associated object. The size of the buffer returned will be (size * descriptor.dataTypeSize() * descriptor.dimension()) bytes. The memory for the buffer is managed internally.</p>
<p>Note that not all vertex buffer descriptors can be used to create vertex buffers as not all combinations of data types, dimensions and semantics are currently supported. If the descriptor for this buffer is not supported this method will return NULL.</p>
<p>When using <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" href="./class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> an <a class="el" href="./class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer to acquire.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to memory for the buffer, or NULL on failure </dd></dl>
</div>
</div>
<a class="anchor" id="a4524a010960fddcc66fd97387a34cdfe"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void * getVertexBuffer </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Private friend class only access to the internal OGS vertex buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The OGS::Devices::AVertexBuffer* as a void*. </dd></dl>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>MHWGeometry.h</li>
<li>MHWGeometry.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>
