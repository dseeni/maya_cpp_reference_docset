<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
<title>C++ API Reference: MPxHwShaderNode Class Reference</title>
</head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"/><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_px_hw_shader_node.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
<div>
<div class="head">
<h1>C++ API Reference: MPxHwShaderNode Class Reference</h1>
</div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>Main Page</span></a></li>
<li><a href="./pages.html"><span>Related Pages</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li class="current"><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="cpp_ref/search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="cpp_ref/search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
<div class="tabs2" id="navrow2">
<ul class="tablist">
<li><a href="./annotated.html"><span>Class List</span></a></li>
<li><a href="./classes.html"><span>Class Index</span></a></li>
<li><a href="./hierarchy.html"><span>Class Hierarchy</span></a></li>
<li><a href="./functions.html"><span>Class Members</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<!-- window showing the filter options -->
<!-- iframe showing the search results (closed by default) -->
<div class="header">
<div class="headertitle">
<div class="title">MPxHwShaderNode Class Reference<div class="ingroups"><a class="el" href="./group___open_maya_u_i.html">OpenMayaUI - API module for user interface</a> | <a class="el" href="./group___m_px.html">Proxy classes</a></div></div> </div>
<div id="OverviewLinksDiv"><div class="dynheader closed" id="dynsection-overview" onclick="return toggleVisibility(this)" style="cursor:pointer;"><img alt="+" id="dynsection-overview-trigger" src="cpp_ref/closed.png"/> Related help topics: </div><div class="dyncontent" id="dynsection-overview-content" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./dev_help/Dependency-graph-plug-ins/Base-dependency-node-classes.html">Dependency graph plug-ins &gt; Base dependency node classes</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Writing-a-Hardware-Shading-Node/Implementing-a-hardware-shading.html">Writing a Hardware Shading Node &gt; Implementing a hardware shading node plug-in</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Writing-a-Hardware-Shading-Node/Improving-the-performance-of.html">Writing a Hardware Shading Node &gt; Improving the performance of hardware shaders</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Overview-of-the-Viewport-2-0-API/Scene-Overrides.html">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Scene Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Overview-of-the-Viewport-2-0-API/Transition-Guide.html">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Transition Guide</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Overview-of-the-Viewport-2-0-API/Developer-Kit-Samples.html">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Developer Kit Samples</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/API-constructs/Shader-Instances.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; API constructs &gt; Shader Instances</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Effect-Overrides.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; Effect Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Geometry-remapping-for-hardware.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Geometry remapping for hardware rendering</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Maya-Python-API/Maya-Python-Plug-in-Learning/Dependency-Graph-Plug-in-Basics.html">Maya Python API &gt; Maya Python Plug-in Learning Path &gt; Dependency Graph Plug-in Basics</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Maya-NET-API/Removal-of-MStatus-return-codes.html">Maya .NET API &gt; Removal of MStatus return codes from .NET API</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_px_hw_shader_node.html#nested-classes">Classes</a> |
<a href="class_m_px_hw_shader_node.html#pub-methods">Public Member Functions</a> |
<a href="class_m_px_hw_shader_node.html#pub-static-methods">Static Public Member Functions</a> |
<a href="class_m_px_hw_shader_node.html#pub-static-attribs">Static Public Attributes</a> |
<a href="./class_m_px_hw_shader_node-members.html">List of all members</a> </div></div><!--header-->
<div class="contents">
<p>Base class for user defined hardware shaders.  
 <a href="./class_m_px_hw_shader_node.html#details">More...</a></p>
<p><code>#include &lt;MPxHwShaderNode.h&gt;</code></p>
<div class="dynheader closed" id="dynsection-0" onclick="return toggleVisibility(this)" style="cursor:pointer;">
<img alt="+" id="dynsection-0-trigger" src="cpp_ref/closed.png"/> Inheritance diagram for MPxHwShaderNode:</div>
<div class="dynsummary" id="dynsection-0-summary" style="display:block;">
</div>
<div class="dyncontent" id="dynsection-0-content" style="display:none;">
<div class="center">
<img alt="" src="cpp_ref/class_m_px_hw_shader_node.png" usemap="#MPxHwShaderNode_map"/>
<map id="MPxHwShaderNode_map" name="MPxHwShaderNode_map">
<area alt="MPxNode" coords="0,0,126,24" href="class_m_px_node.html" shape="rect" title="Base class for user defined dependency nodes. "/>
</map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="./struct_m_px_hw_shader_node_1_1_render_parameters.html">RenderParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Provides information on how to render the image.  <a href="./struct_m_px_hw_shader_node_1_1_render_parameters.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a914d22d5dc1e1142541109f5be8038b8"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a914d22d5dc1e1142541109f5be8038b8">OPENMAYA_ENUM</a> (Writeable, kWriteNone=0x0000, kWriteVertexArray=0x0001, kWriteNormalArray=0x0002, kWriteColorArrays=0x0004, kWriteTexCoordArrays=0x0008, kWriteAll=0x000f)</td></tr>
<tr class="memdesc:a914d22d5dc1e1142541109f5be8038b8"><td class="mdescLeft"> </td><td class="mdescRight">Bit masks used in conjuction with the 'writeable' parameter passed to the <a class="el" href="./class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3" title="This method is obsolete. ">geometry()</a> method to determine which arrays the shader is allowed to write to.  <a href="class_m_px_hw_shader_node.html#a914d22d5dc1e1142541109f5be8038b8">More...</a><br/></td></tr>
<tr class="separator:a914d22d5dc1e1142541109f5be8038b8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a25d4c0456e517dcc3badcbd56de097ea"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a25d4c0456e517dcc3badcbd56de097ea">OPENMAYA_ENUM</a> (DirtyMask, kDirtyNone=0x0000, kDirtyVertexArray=0x0001, kDirtyNormalArray=0x0002, kDirtyColorArrays=0x0004, kDirtyTexCoordArrays=0x0008, kDirtyAll=0x000f)</td></tr>
<tr class="memdesc:a25d4c0456e517dcc3badcbd56de097ea"><td class="mdescLeft"> </td><td class="mdescRight">Bit masks used in combination with the return value of the <a class="el" href="./class_m_px_hw_shader_node.html#a54512792bc37d6cfc7771a580b497d2f" title='This method returns a "dirty" mask that indicates which geometry items have changed from the last inv...'>dirtyMask()</a> method to determine which portions of the geometry are dirty.  <a href="class_m_px_hw_shader_node.html#a25d4c0456e517dcc3badcbd56de097ea">More...</a><br/></td></tr>
<tr class="separator:a25d4c0456e517dcc3badcbd56de097ea"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa725337cd17aca747baafbaa8660c90c"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#aa725337cd17aca747baafbaa8660c90c">OPENMAYA_ENUM</a> (TransparencyOptions, kIsTransparent=0x0001, kNoTransparencyFrontBackCull=0x0002, kNoTransparencyPolygonSort=0x0004)</td></tr>
<tr class="memdesc:aa725337cd17aca747baafbaa8660c90c"><td class="mdescLeft"> </td><td class="mdescRight">Bit masks to be returned by the shader's <a class="el" href="./class_m_px_hw_shader_node.html#abf43698ad6309b49f5790bcd11c21239" title="This method returns transparency options for usage as hints for Maya's internal draw during a given r...">transparencyOptions()</a> method.  <a href="class_m_px_hw_shader_node.html#aa725337cd17aca747baafbaa8660c90c">More...</a><br/></td></tr>
<tr class="separator:aa725337cd17aca747baafbaa8660c90c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9fa1f63491dd3de87ef609386b7918df"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9fa1f63491dd3de87ef609386b7918df"></a>
 </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a9fa1f63491dd3de87ef609386b7918df">MPxHwShaderNode</a> ()</td></tr>
<tr class="memdesc:a9fa1f63491dd3de87ef609386b7918df"><td class="mdescLeft"> </td><td class="mdescRight">Class constructor. <br/></td></tr>
<tr class="separator:a9fa1f63491dd3de87ef609386b7918df"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a45ecb6a056a33e88cfade430b2fdc9df"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a45ecb6a056a33e88cfade430b2fdc9df"></a>
virtual </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a45ecb6a056a33e88cfade430b2fdc9df">~MPxHwShaderNode</a> ()</td></tr>
<tr class="memdesc:a45ecb6a056a33e88cfade430b2fdc9df"><td class="mdescLeft"> </td><td class="mdescRight">Class destructor. <br/></td></tr>
<tr class="separator:a45ecb6a056a33e88cfade430b2fdc9df"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71bae20f7cb1d030904cf421f1c5eba2"><td align="right" class="memItemLeft" valign="top">virtual MPxNode::Type </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a71bae20f7cb1d030904cf421f1c5eba2">type</a> () const </td></tr>
<tr class="memdesc:a71bae20f7cb1d030904cf421f1c5eba2"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the type of the node.  <a href="class_m_px_hw_shader_node.html#a71bae20f7cb1d030904cf421f1c5eba2">More...</a><br/></td></tr>
<tr class="separator:a71bae20f7cb1d030904cf421f1c5eba2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b373289ba4ef6bf66387e2b540cdc05"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05">bind</a> (const <a class="el" href="./class_m_draw_request.html">MDrawRequest</a> &amp;request, <a class="el" href="./class_m3d_view.html">M3dView</a> &amp;view)</td></tr>
<tr class="memdesc:a4b373289ba4ef6bf66387e2b540cdc05"><td class="mdescLeft"> </td><td class="mdescRight">This method is invoked for hardware rendering to Maya's 3D view.  <a href="class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05">More...</a><br/></td></tr>
<tr class="separator:a4b373289ba4ef6bf66387e2b540cdc05"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1add8314dc908073f9126b81dc187ce7"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7">unbind</a> (const <a class="el" href="./class_m_draw_request.html">MDrawRequest</a> &amp;request, <a class="el" href="./class_m3d_view.html">M3dView</a> &amp;view)</td></tr>
<tr class="memdesc:a1add8314dc908073f9126b81dc187ce7"><td class="mdescLeft"> </td><td class="mdescRight">This method is invoked for hardware rendering to Maya's 3D view.  <a href="class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7">More...</a><br/></td></tr>
<tr class="separator:a1add8314dc908073f9126b81dc187ce7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acd6773ef64b27965c09ed584830bf8f3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3">geometry</a> (const <a class="el" href="./class_m_draw_request.html">MDrawRequest</a> &amp;request, <a class="el" href="./class_m3d_view.html">M3dView</a> &amp;view, int prim, unsigned int writable, int indexCount, const unsigned int *indexArray, int vertexCount, const int *vertexIDs, const float *vertexArray, int normalCount, floatArrayPtr normalArrays, int colorCount, floatArrayPtr colorArrays, int texCoordCount, floatArrayPtr texCoordArrays)</td></tr>
<tr class="memdesc:acd6773ef64b27965c09ed584830bf8f3"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3">More...</a><br/></td></tr>
<tr class="separator:acd6773ef64b27965c09ed584830bf8f3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a929b27bcbcb4140d0228e65c97423902"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a929b27bcbcb4140d0228e65c97423902">geometry</a> (const <a class="el" href="./class_m_draw_request.html">MDrawRequest</a> &amp;request, <a class="el" href="./class_m3d_view.html">M3dView</a> &amp;view, int prim, unsigned int writable, int indexCount, const unsigned int *indexArray, int vertexCount, const int *vertexIDs, const float *vertexArray, int normalCount, floatArrayPtr normalArrays, int colorCount, floatArrayPtr colorArrays, int texCoordCount, floatArrayPtr texCoordArrays, const int *faceIDs, const float *localUVCoord)</td></tr>
<tr class="memdesc:a929b27bcbcb4140d0228e65c97423902"><td class="mdescLeft"> </td><td class="mdescRight">This method is invoked for hardware rendering to Maya's 3D view.  <a href="class_m_px_hw_shader_node.html#a929b27bcbcb4140d0228e65c97423902">More...</a><br/></td></tr>
<tr class="separator:a929b27bcbcb4140d0228e65c97423902"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa39f824f610a30172f5bb7a130c35069"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#aa39f824f610a30172f5bb7a130c35069">glBind</a> (const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp;shapePath)</td></tr>
<tr class="memdesc:aa39f824f610a30172f5bb7a130c35069"><td class="mdescLeft"> </td><td class="mdescRight">This method should only be overridden for hardware rendering.  <a href="class_m_px_hw_shader_node.html#aa39f824f610a30172f5bb7a130c35069">More...</a><br/></td></tr>
<tr class="separator:aa39f824f610a30172f5bb7a130c35069"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab94ce2a19c9ce026e7b0825b5397975e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#ab94ce2a19c9ce026e7b0825b5397975e">glUnbind</a> (const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp;shapePath)</td></tr>
<tr class="memdesc:ab94ce2a19c9ce026e7b0825b5397975e"><td class="mdescLeft"> </td><td class="mdescRight">This method should only be overridden for hardware rendering.  <a href="class_m_px_hw_shader_node.html#ab94ce2a19c9ce026e7b0825b5397975e">More...</a><br/></td></tr>
<tr class="separator:ab94ce2a19c9ce026e7b0825b5397975e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a495a60eaa1df3815d5565e79e08c90ac"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a495a60eaa1df3815d5565e79e08c90ac">glGeometry</a> (const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp;shapePath, int glPrim, unsigned int writeMask, int indexCount, const unsigned int *indexArray, int vertexCount, const int *vertexIDs, const float *vertexArray, int normalCount, floatArrayPtr normalArrays, int colorCount, floatArrayPtr colorArrays, int texCoordCount, floatArrayPtr texCoordArrays)</td></tr>
<tr class="memdesc:a495a60eaa1df3815d5565e79e08c90ac"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#a495a60eaa1df3815d5565e79e08c90ac">More...</a><br/></td></tr>
<tr class="separator:a495a60eaa1df3815d5565e79e08c90ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afc4e163f97e3cabe53c095d83ffecb7c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#afc4e163f97e3cabe53c095d83ffecb7c">glGeometry</a> (const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp;shapePath, int glPrim, unsigned int writeMask, int indexCount, const unsigned int *indexArray, int vertexCount, const int *vertexIDs, const float *vertexArray, int normalCount, floatArrayPtr normalArrays, int colorCount, floatArrayPtr colorArrays, int texCoordCount, floatArrayPtr texCoordArrays, const int *faceIDs, const float *localUVCoord)</td></tr>
<tr class="memdesc:afc4e163f97e3cabe53c095d83ffecb7c"><td class="mdescLeft"> </td><td class="mdescRight">This method should only be overridden for hardware rendering.  <a href="class_m_px_hw_shader_node.html#afc4e163f97e3cabe53c095d83ffecb7c">More...</a><br/></td></tr>
<tr class="separator:afc4e163f97e3cabe53c095d83ffecb7c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aede8bf8429fc531c462df5cdd0bd07a3"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#aede8bf8429fc531c462df5cdd0bd07a3">supportsBatching</a> () const </td></tr>
<tr class="memdesc:aede8bf8429fc531c462df5cdd0bd07a3"><td class="mdescLeft"> </td><td class="mdescRight">Specifies whether or not this shader supports batched rendering of shapes.  <a href="class_m_px_hw_shader_node.html#aede8bf8429fc531c462df5cdd0bd07a3">More...</a><br/></td></tr>
<tr class="separator:aede8bf8429fc531c462df5cdd0bd07a3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74d50823fbfb6ddfd72fa7c6b1879200"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a74d50823fbfb6ddfd72fa7c6b1879200">invertTexCoords</a> () const </td></tr>
<tr class="memdesc:a74d50823fbfb6ddfd72fa7c6b1879200"><td class="mdescLeft"> </td><td class="mdescRight">Specifies whether this shader requires inverted texture coordinates.  <a href="class_m_px_hw_shader_node.html#a74d50823fbfb6ddfd72fa7c6b1879200">More...</a><br/></td></tr>
<tr class="separator:a74d50823fbfb6ddfd72fa7c6b1879200"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca13c173921201361dcc0b25baab88f3"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#aca13c173921201361dcc0b25baab88f3">currentPath</a> () const </td></tr>
<tr class="memdesc:aca13c173921201361dcc0b25baab88f3"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a reference to the current path that the shader is invoked for.  <a href="class_m_px_hw_shader_node.html#aca13c173921201361dcc0b25baab88f3">More...</a><br/></td></tr>
<tr class="separator:aca13c173921201361dcc0b25baab88f3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a54512792bc37d6cfc7771a580b497d2f"><td align="right" class="memItemLeft" valign="top">unsigned int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a54512792bc37d6cfc7771a580b497d2f">dirtyMask</a> () const </td></tr>
<tr class="memdesc:a54512792bc37d6cfc7771a580b497d2f"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a "dirty" mask that indicates which geometry items have changed from the last invocation of the plugin to draw.  <a href="class_m_px_hw_shader_node.html#a54512792bc37d6cfc7771a580b497d2f">More...</a><br/></td></tr>
<tr class="separator:a54512792bc37d6cfc7771a580b497d2f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3550674237dc92887354c8c1aab7367"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#af3550674237dc92887354c8c1aab7367">normalsPerVertex</a> ()</td></tr>
<tr class="memdesc:af3550674237dc92887354c8c1aab7367"><td class="mdescLeft"> </td><td class="mdescRight">Specifies how many normals per vertex the HW shader would like Maya to provide.  <a href="class_m_px_hw_shader_node.html#af3550674237dc92887354c8c1aab7367">More...</a><br/></td></tr>
<tr class="separator:af3550674237dc92887354c8c1aab7367"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a636103e207bea5f6f82065a21c275072"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a636103e207bea5f6f82065a21c275072">colorsPerVertex</a> ()</td></tr>
<tr class="memdesc:a636103e207bea5f6f82065a21c275072"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the number of color values per vertex that the hw shader node would like to receive from Maya.  <a href="class_m_px_hw_shader_node.html#a636103e207bea5f6f82065a21c275072">More...</a><br/></td></tr>
<tr class="separator:a636103e207bea5f6f82065a21c275072"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0e68c77bf2d71c34164b991b33f48971"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a0e68c77bf2d71c34164b991b33f48971">getColorSetNames</a> (<a class="el" href="./class_m_string_array.html">MStringArray</a> &amp;names)</td></tr>
<tr class="memdesc:a0e68c77bf2d71c34164b991b33f48971"><td class="mdescLeft"> </td><td class="mdescRight">NO SCRIPT SUPPORT.  <a href="class_m_px_hw_shader_node.html#a0e68c77bf2d71c34164b991b33f48971">More...</a><br/></td></tr>
<tr class="separator:a0e68c77bf2d71c34164b991b33f48971"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ad8d328c883db5ee4e4141840c76394"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a4ad8d328c883db5ee4e4141840c76394">texCoordsPerVertex</a> ()</td></tr>
<tr class="memdesc:a4ad8d328c883db5ee4e4141840c76394"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the number of texture coordinate values per vertex that the hw shader node would like to receive from Maya.  <a href="class_m_px_hw_shader_node.html#a4ad8d328c883db5ee4e4141840c76394">More...</a><br/></td></tr>
<tr class="separator:a4ad8d328c883db5ee4e4141840c76394"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a113794c8b72392d371b6f7b193d80cda"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a113794c8b72392d371b6f7b193d80cda">getTexCoordSetNames</a> (<a class="el" href="./class_m_string_array.html">MStringArray</a> &amp;names)</td></tr>
<tr class="memdesc:a113794c8b72392d371b6f7b193d80cda"><td class="mdescLeft"> </td><td class="mdescRight">NO SCRIPT SUPPORT.  <a href="class_m_px_hw_shader_node.html#a113794c8b72392d371b6f7b193d80cda">More...</a><br/></td></tr>
<tr class="separator:a113794c8b72392d371b6f7b193d80cda"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a48045e919e9cafe71b7883de1c4875de"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a48045e919e9cafe71b7883de1c4875de">hasTransparency</a> ()</td></tr>
<tr class="memdesc:a48045e919e9cafe71b7883de1c4875de"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a boolean value that indicates whether the object will be drawn transparently or not.  <a href="class_m_px_hw_shader_node.html#a48045e919e9cafe71b7883de1c4875de">More...</a><br/></td></tr>
<tr class="separator:a48045e919e9cafe71b7883de1c4875de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac8569dc0556726f17320788563f034c6"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6">provideVertexIDs</a> ()</td></tr>
<tr class="memdesc:ac8569dc0556726f17320788563f034c6"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a boolean value that indicates whether a map of the vertex IDs will be provided to the geometry method.  <a href="class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6">More...</a><br/></td></tr>
<tr class="separator:ac8569dc0556726f17320788563f034c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa61effad561b9564e161fe930bd038c"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#afa61effad561b9564e161fe930bd038c">provideFaceIDs</a> ()</td></tr>
<tr class="memdesc:afa61effad561b9564e161fe930bd038c"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a boolean value that indicates whether a map of the face IDs will be provided to the geometry method.  <a href="class_m_px_hw_shader_node.html#afa61effad561b9564e161fe930bd038c">More...</a><br/></td></tr>
<tr class="separator:afa61effad561b9564e161fe930bd038c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a276892ea9def000206de6522deccc137"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a276892ea9def000206de6522deccc137">provideLocalUVCoord</a> ()</td></tr>
<tr class="memdesc:a276892ea9def000206de6522deccc137"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a boolean value that indicates whether the local uv coordinates of the subdivided face vertices will be provided to the geometry method.  <a href="class_m_px_hw_shader_node.html#a276892ea9def000206de6522deccc137">More...</a><br/></td></tr>
<tr class="separator:a276892ea9def000206de6522deccc137"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf43698ad6309b49f5790bcd11c21239"><td align="right" class="memItemLeft" valign="top">virtual unsigned int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#abf43698ad6309b49f5790bcd11c21239">transparencyOptions</a> ()</td></tr>
<tr class="memdesc:abf43698ad6309b49f5790bcd11c21239"><td class="mdescLeft"> </td><td class="mdescRight">This method returns transparency options for usage as hints for Maya's internal draw during a given rendering pass.  <a href="class_m_px_hw_shader_node.html#abf43698ad6309b49f5790bcd11c21239">More...</a><br/></td></tr>
<tr class="separator:abf43698ad6309b49f5790bcd11c21239"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7149feca551be481b5cac8cba24cd70a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a">getAvailableImages</a> (const <a class="el" href="./class_m_string.html">MString</a> &amp;uvSetName, <a class="el" href="./class_m_string_array.html">MStringArray</a> &amp;imageNames)</td></tr>
<tr class="memdesc:a7149feca551be481b5cac8cba24cd70a"><td class="mdescLeft"> </td><td class="mdescRight">NO SCRIPT SUPPORT.  <a href="class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a">More...</a><br/></td></tr>
<tr class="separator:a7149feca551be481b5cac8cba24cd70a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b406fc429c85d0cda4dfb62e1177ea5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a6b406fc429c85d0cda4dfb62e1177ea5">renderImage</a> (const <a class="el" href="./class_m_string.html">MString</a> &amp;imageName, floatRegion region, int &amp;imageWidth, int &amp;imageHeight)</td></tr>
<tr class="memdesc:a6b406fc429c85d0cda4dfb62e1177ea5"><td class="mdescLeft"> </td><td class="mdescRight">NO SCRIPT SUPPORT.  <a href="class_m_px_hw_shader_node.html#a6b406fc429c85d0cda4dfb62e1177ea5">More...</a><br/></td></tr>
<tr class="separator:a6b406fc429c85d0cda4dfb62e1177ea5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c6c731bc1af5cf3e007220689af1c55"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a7c6c731bc1af5cf3e007220689af1c55">renderImage</a> (const <a class="el" href="./class_m_string.html">MString</a> &amp;imageName, floatRegion region, const <a class="el" href="./struct_m_px_hw_shader_node_1_1_render_parameters.html">MPxHwShaderNode::RenderParameters</a> &amp;parameters, int &amp;imageWidth, int &amp;imageHeight)</td></tr>
<tr class="memdesc:a7c6c731bc1af5cf3e007220689af1c55"><td class="mdescLeft"> </td><td class="mdescRight">NO SCRIPT SUPPORT.  <a href="class_m_px_hw_shader_node.html#a7c6c731bc1af5cf3e007220689af1c55">More...</a><br/></td></tr>
<tr class="separator:a7c6c731bc1af5cf3e007220689af1c55"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab2ba397ffbcaeddb85e73a41aa2270e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#aab2ba397ffbcaeddb85e73a41aa2270e">renderImage</a> (<a class="el" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html">MHWRender::MUIDrawManager</a> &amp;uiDrawManager, const <a class="el" href="./class_m_string.html">MString</a> &amp;imageName, floatRegion region, const <a class="el" href="./struct_m_px_hw_shader_node_1_1_render_parameters.html">MPxHwShaderNode::RenderParameters</a> &amp;parameters, int &amp;imageWidth, int &amp;imageHeight)</td></tr>
<tr class="memdesc:aab2ba397ffbcaeddb85e73a41aa2270e"><td class="mdescLeft"> </td><td class="mdescRight">NO SCRIPT SUPPORT.  <a href="class_m_px_hw_shader_node.html#aab2ba397ffbcaeddb85e73a41aa2270e">More...</a><br/></td></tr>
<tr class="separator:aab2ba397ffbcaeddb85e73a41aa2270e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a765f8d7c0499e87180ff884b6967550e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a765f8d7c0499e87180ff884b6967550e">renderSwatchImage</a> (<a class="el" href="./class_m_image.html">MImage</a> &amp;image)</td></tr>
<tr class="memdesc:a765f8d7c0499e87180ff884b6967550e"><td class="mdescLeft"> </td><td class="mdescRight">If the shader specifies to override swatch rendering, then this method must be overridden in order to draw anything into a swatch.  <a href="class_m_px_hw_shader_node.html#a765f8d7c0499e87180ff884b6967550e">More...</a><br/></td></tr>
<tr class="separator:a765f8d7c0499e87180ff884b6967550e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4791f90368dbb3240b17cb341d4f084b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a4791f90368dbb3240b17cb341d4f084b">currentShadingEngine</a> () const </td></tr>
<tr class="memdesc:a4791f90368dbb3240b17cb341d4f084b"><td class="mdescLeft"> </td><td class="mdescRight">This method returns an <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> to the shading engine that is currently being rendered.  <a href="class_m_px_hw_shader_node.html#a4791f90368dbb3240b17cb341d4f084b">More...</a><br/></td></tr>
<tr class="separator:a4791f90368dbb3240b17cb341d4f084b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_class_m_px_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_px_node')"><img alt="-" src="cpp_ref/closed.png"/> Public Member Functions inherited from <a class="el" href="./class_m_px_node.html">MPxNode</a></td></tr>
<tr class="memitem:a8d91949acf0aac099d77b45a40902c44 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8d91949acf0aac099d77b45a40902c44"></a>
 </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a8d91949acf0aac099d77b45a40902c44">OPENMAYA_ENUM</a> (Type, kDependNode, kLocatorNode, kDeformerNode, kManipContainer, kSurfaceShape, kFieldNode, kEmitterNode, kSpringNode, kIkSolverNode, kHardwareShader, kHwShaderNode, kTransformNode, kObjectSet, kFluidEmitterNode, kImagePlaneNode, kParticleAttributeMapperNode, kCameraSetNode, kConstraintNode, kManipulatorNode, kMotionPathNode, kClientDeviceNode, kThreadedDeviceNode, kAssembly, kSkinCluster, kGeometryFilter, kBlendShape, kLast)</td></tr>
<tr class="memdesc:a8d91949acf0aac099d77b45a40902c44 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Defines the type of node. <br/></td></tr>
<tr class="separator:a8d91949acf0aac099d77b45a40902c44 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a48ffd6b0fe3d500d9954ccc623b3ec0e inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a48ffd6b0fe3d500d9954ccc623b3ec0e">MPxNode</a> ()</td></tr>
<tr class="memdesc:a48ffd6b0fe3d500d9954ccc623b3ec0e inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Constructor.  <a href="class_m_px_hw_shader_node.html#a48ffd6b0fe3d500d9954ccc623b3ec0e">More...</a><br/></td></tr>
<tr class="separator:a48ffd6b0fe3d500d9954ccc623b3ec0e inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a09bd20438981ff5cc2a0a69790cb3393 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a09bd20438981ff5cc2a0a69790cb3393"></a>
virtual </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a09bd20438981ff5cc2a0a69790cb3393">~MPxNode</a> ()</td></tr>
<tr class="memdesc:a09bd20438981ff5cc2a0a69790cb3393 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a09bd20438981ff5cc2a0a69790cb3393 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c13a6c88a839b5356861d1d09e820d9 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a5c13a6c88a839b5356861d1d09e820d9">postConstructor</a> ()</td></tr>
<tr class="memdesc:a5c13a6c88a839b5356861d1d09e820d9 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Post constructor.  <a href="class_m_px_hw_shader_node.html#a5c13a6c88a839b5356861d1d09e820d9">More...</a><br/></td></tr>
<tr class="separator:a5c13a6c88a839b5356861d1d09e820d9 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6e1aa1e50774080d5aee55f20ffa5503 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a6e1aa1e50774080d5aee55f20ffa5503">compute</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, <a class="el" href="./class_m_data_block.html">MDataBlock</a> &amp;)</td></tr>
<tr class="memdesc:a6e1aa1e50774080d5aee55f20ffa5503 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden in user defined nodes.  <a href="class_m_px_hw_shader_node.html#a6e1aa1e50774080d5aee55f20ffa5503">More...</a><br/></td></tr>
<tr class="separator:a6e1aa1e50774080d5aee55f20ffa5503 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa88f4dd4cfd3e964e0806d6e5b253347 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aa88f4dd4cfd3e964e0806d6e5b253347">getInternalValue</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, <a class="el" href="./class_m_data_handle.html">MDataHandle</a> &amp;)</td></tr>
<tr class="memdesc:aa88f4dd4cfd3e964e0806d6e5b253347 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that store attribute data in some internal format.  <a href="class_m_px_hw_shader_node.html#aa88f4dd4cfd3e964e0806d6e5b253347">More...</a><br/></td></tr>
<tr class="separator:aa88f4dd4cfd3e964e0806d6e5b253347 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6caab4434e836748680958883564af35 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a6caab4434e836748680958883564af35">setInternalValue</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_data_handle.html">MDataHandle</a> &amp;)</td></tr>
<tr class="memdesc:a6caab4434e836748680958883564af35 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that store attribute data in some internal format.  <a href="class_m_px_hw_shader_node.html#a6caab4434e836748680958883564af35">More...</a><br/></td></tr>
<tr class="separator:a6caab4434e836748680958883564af35 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac6bea264655616f6d6d47dec0c4ecc46 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac6bea264655616f6d6d47dec0c4ecc46">internalArrayCount</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;) const </td></tr>
<tr class="memdesc:ac6bea264655616f6d6d47dec0c4ecc46 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that have internal array attributes which are not stored in Maya's datablock.  <a href="class_m_px_hw_shader_node.html#ac6bea264655616f6d6d47dec0c4ecc46">More...</a><br/></td></tr>
<tr class="separator:ac6bea264655616f6d6d47dec0c4ecc46 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca0f48b1467c0e3dc8643a18b0b855da inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aca0f48b1467c0e3dc8643a18b0b855da">copyInternalData</a> (<a class="el" href="./class_m_px_node.html">MPxNode</a> *)</td></tr>
<tr class="memdesc:aca0f48b1467c0e3dc8643a18b0b855da inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that store attribute data in some internal format.  <a href="class_m_px_hw_shader_node.html#aca0f48b1467c0e3dc8643a18b0b855da">More...</a><br/></td></tr>
<tr class="separator:aca0f48b1467c0e3dc8643a18b0b855da inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4a9dabb4ab821f67b0db6d2ee02b399 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ad4a9dabb4ab821f67b0db6d2ee02b399">legalConnection</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool asSrc, bool &amp;isLegal) const </td></tr>
<tr class="memdesc:ad4a9dabb4ab821f67b0db6d2ee02b399 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method allows you to check for legal connections being made to attributes of this node.  <a href="class_m_px_hw_shader_node.html#ad4a9dabb4ab821f67b0db6d2ee02b399">More...</a><br/></td></tr>
<tr class="separator:ad4a9dabb4ab821f67b0db6d2ee02b399 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ce5a410752aed82613f1cad8021d220 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a2ce5a410752aed82613f1cad8021d220">legalDisconnection</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool asSrc, bool &amp;isLegal) const </td></tr>
<tr class="memdesc:a2ce5a410752aed82613f1cad8021d220 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method allows you to check for legal disconnections being made to attributes of this node.  <a href="class_m_px_hw_shader_node.html#a2ce5a410752aed82613f1cad8021d220">More...</a><br/></td></tr>
<tr class="separator:a2ce5a410752aed82613f1cad8021d220 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abd7d1dad4e4f0b922bf5ac4fc9c0230a inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#abd7d1dad4e4f0b922bf5ac4fc9c0230a">setDependentsDirty</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;plug, <a class="el" href="./class_m_plug_array.html">MPlugArray</a> &amp;plugArray)</td></tr>
<tr class="memdesc:abd7d1dad4e4f0b922bf5ac4fc9c0230a inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method can be overridden in user defined nodes to specify which plugs should be set dirty based upon an input plug {<em>plugBeingDirtied}</em> which Maya is marking dirty.  <a href="class_m_px_hw_shader_node.html#abd7d1dad4e4f0b922bf5ac4fc9c0230a">More...</a><br/></td></tr>
<tr class="separator:abd7d1dad4e4f0b922bf5ac4fc9c0230a inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad40cff55ba4000788eda78c8b4258b3d inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ad40cff55ba4000788eda78c8b4258b3d">preEvaluation</a> (const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;context, const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;evaluationNode)</td></tr>
<tr class="memdesc:ad40cff55ba4000788eda78c8b4258b3d inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Prepare a node's internal state for threaded evaluation.  <a href="class_m_px_hw_shader_node.html#ad40cff55ba4000788eda78c8b4258b3d">More...</a><br/></td></tr>
<tr class="separator:ad40cff55ba4000788eda78c8b4258b3d inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a93e355c11a2c9a0f19f8d7cfa887af2b inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a93e355c11a2c9a0f19f8d7cfa887af2b">postEvaluation</a> (const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;context, const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;evaluationNode, PostEvaluationType evalType)</td></tr>
<tr class="memdesc:a93e355c11a2c9a0f19f8d7cfa887af2b inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Clean up node's internal state after threaded evaluation.  <a href="class_m_px_hw_shader_node.html#a93e355c11a2c9a0f19f8d7cfa887af2b">More...</a><br/></td></tr>
<tr class="separator:a93e355c11a2c9a0f19f8d7cfa887af2b inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71ebcb2013e0847d13c63dbdbb9973aa inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a71ebcb2013e0847d13c63dbdbb9973aa">OPENMAYA_ENUM</a> (SchedulingType, kParallel, kSerial, kGloballySerial, kUntrusted, kSchedulingTypeLast, kDefaultScheduling=kSerial, kSerialize=kSerial, kGloballySerialize=kGloballySerial)</td></tr>
<tr class="memdesc:a71ebcb2013e0847d13c63dbdbb9973aa inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Defines the degree of parallelism of a node.  <a href="class_m_px_hw_shader_node.html#a71ebcb2013e0847d13c63dbdbb9973aa">More...</a><br/></td></tr>
<tr class="separator:a71ebcb2013e0847d13c63dbdbb9973aa inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c9e8bdcf0b5283a027a66a7671b7088 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual SchedulingType </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9c9e8bdcf0b5283a027a66a7671b7088">schedulingType</a> () const </td></tr>
<tr class="memdesc:a9c9e8bdcf0b5283a027a66a7671b7088 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">When overridden this method controls the degree of parallelism supported by the node during threaded evaluation.  <a href="class_m_px_hw_shader_node.html#a9c9e8bdcf0b5283a027a66a7671b7088">More...</a><br/></td></tr>
<tr class="separator:a9c9e8bdcf0b5283a027a66a7671b7088 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6f70ff175ac7ba65cb65aa3b5592f05b inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a6f70ff175ac7ba65cb65aa3b5592f05b">getCacheSetup</a> (const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;, <a class="el" href="./class_m_node_cache_disabling_info.html">MNodeCacheDisablingInfo</a> &amp;, <a class="el" href="./class_m_node_cache_setup_info.html">MNodeCacheSetupInfo</a> &amp;, <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;) const </td></tr>
<tr class="memdesc:a6f70ff175ac7ba65cb65aa3b5592f05b inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Provide node-specific setup info for the Cached Playback system.  <a href="class_m_px_hw_shader_node.html#a6f70ff175ac7ba65cb65aa3b5592f05b">More...</a><br/></td></tr>
<tr class="separator:a6f70ff175ac7ba65cb65aa3b5592f05b inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af7be6b397b65f1a96b201e899c923d12 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#af7be6b397b65f1a96b201e899c923d12">configCache</a> (const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;, <a class="el" href="./class_m_cache_schema.html">MCacheSchema</a> &amp;) const </td></tr>
<tr class="memdesc:af7be6b397b65f1a96b201e899c923d12 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Defines the node's behavior when participating in Cached Playback.  <a href="class_m_px_hw_shader_node.html#af7be6b397b65f1a96b201e899c923d12">More...</a><br/></td></tr>
<tr class="separator:af7be6b397b65f1a96b201e899c923d12 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a68b5f4da814941edd141ca207d1c7369 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_time_range.html">MTimeRange</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a68b5f4da814941edd141ca207d1c7369">transformInvalidationRange</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;source, const <a class="el" href="./class_m_time_range.html">MTimeRange</a> &amp;input) const </td></tr>
<tr class="memdesc:a68b5f4da814941edd141ca207d1c7369 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Override this method to register this node as an Invalidation-Range-Transformation kernel (IRT kernel) An IRT kernel node will change the invalidation time range for its downstream nodes For example, Dynamics-solver will transform invalidation time range [a,b] to [a,+inf) And Clip-Time-Editor will send out the invalidation range for each of the clip [a,b] to ( [t0+a,t0+b] U [t1+a,t1+b] U [t2+a,t2+b] U ...  <a href="class_m_px_hw_shader_node.html#a68b5f4da814941edd141ca207d1c7369">More...</a><br/></td></tr>
<tr class="separator:a68b5f4da814941edd141ca207d1c7369 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16261c8f144b5ff3b27057602831138e inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a16261c8f144b5ff3b27057602831138e"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a16261c8f144b5ff3b27057602831138e">hasInvalidationRangeTransformation</a> () const </td></tr>
<tr class="memdesc:a16261c8f144b5ff3b27057602831138e inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Checks if this <a class="el" href="./class_m_px_node.html" title="Base class for user defined dependency nodes. ">MPxNode</a> derived node overrides the <a class="el" href="./class_m_px_node.html#a68b5f4da814941edd141ca207d1c7369" title="Override this method to register this node as an Invalidation-Range-Transformation kernel (IRT kernel...">MPxNode::transformInvalidationRange</a> method. <br/></td></tr>
<tr class="separator:a16261c8f144b5ff3b27057602831138e inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a82d0d0e95d46b8f41c4fd4bea409c1b3 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a82d0d0e95d46b8f41c4fd4bea409c1b3">connectionMade</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool asSrc)</td></tr>
<tr class="memdesc:a82d0d0e95d46b8f41c4fd4bea409c1b3 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method gets called when connections are made to attributes of this node.  <a href="class_m_px_hw_shader_node.html#a82d0d0e95d46b8f41c4fd4bea409c1b3">More...</a><br/></td></tr>
<tr class="separator:a82d0d0e95d46b8f41c4fd4bea409c1b3 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2493af8700f32f6bc164414ac2b906d inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac2493af8700f32f6bc164414ac2b906d">connectionBroken</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool asSrc)</td></tr>
<tr class="memdesc:ac2493af8700f32f6bc164414ac2b906d inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method gets called when connections are broken with attributes of this node.  <a href="class_m_px_hw_shader_node.html#ac2493af8700f32f6bc164414ac2b906d">More...</a><br/></td></tr>
<tr class="separator:ac2493af8700f32f6bc164414ac2b906d inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9af8c4dfe96f9f03b7edd22be9dcd79a inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9af8c4dfe96f9f03b7edd22be9dcd79a">dependsOn</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool &amp;depends) const </td></tr>
<tr class="memdesc:a9af8c4dfe96f9f03b7edd22be9dcd79a inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method may be overridden by the user defined node.  <a href="class_m_px_hw_shader_node.html#a9af8c4dfe96f9f03b7edd22be9dcd79a">More...</a><br/></td></tr>
<tr class="separator:a9af8c4dfe96f9f03b7edd22be9dcd79a inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac24fcf77203181163ad3e581645f5d3b inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac24fcf77203181163ad3e581645f5d3b">isPassiveOutput</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;) const </td></tr>
<tr class="memdesc:ac24fcf77203181163ad3e581645f5d3b inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method may be overridden by the user defined node if it wants to provide output attributes which do not prevent value modifications to the destination attribute.  <a href="class_m_px_hw_shader_node.html#ac24fcf77203181163ad3e581645f5d3b">More...</a><br/></td></tr>
<tr class="separator:ac24fcf77203181163ad3e581645f5d3b inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac354fc704a7e79728b99e0570b4b51bf inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac354fc704a7e79728b99e0570b4b51bf">shouldSave</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool &amp;isSaving)</td></tr>
<tr class="memdesc:ac354fc704a7e79728b99e0570b4b51bf inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method may be overridden by the user defined node.  <a href="class_m_px_hw_shader_node.html#ac354fc704a7e79728b99e0570b4b51bf">More...</a><br/></td></tr>
<tr class="separator:ac354fc704a7e79728b99e0570b4b51bf inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adad125b5b4aadf8f7f9819fc590a78a6 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_plug.html">MPlug</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#adad125b5b4aadf8f7f9819fc590a78a6">passThroughToOne</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;) const </td></tr>
<tr class="memdesc:adad125b5b4aadf8f7f9819fc590a78a6 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method may be overridden by nodes that have a one-to-one relationship between an input attribute and a corresponding output attribute.  <a href="class_m_px_hw_shader_node.html#adad125b5b4aadf8f7f9819fc590a78a6">More...</a><br/></td></tr>
<tr class="separator:adad125b5b4aadf8f7f9819fc590a78a6 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aae65db50f0b2f6aae1d1bf99ed962362 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aae65db50f0b2f6aae1d1bf99ed962362">passThroughToMany</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, <a class="el" href="./class_m_plug_array.html">MPlugArray</a> &amp;) const </td></tr>
<tr class="memdesc:aae65db50f0b2f6aae1d1bf99ed962362 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that want to control the traversal behavior of some Maya search algorithms which traverse the history/future of shape nodes looking for directly related nodes.  <a href="class_m_px_hw_shader_node.html#aae65db50f0b2f6aae1d1bf99ed962362">More...</a><br/></td></tr>
<tr class="separator:aae65db50f0b2f6aae1d1bf99ed962362 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf966a89078baf354c95638086e19d7a inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#abf966a89078baf354c95638086e19d7a">isAbstractClass</a> () const </td></tr>
<tr class="memdesc:abf966a89078baf354c95638086e19d7a inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Override this class to return true if this node is an abstract node.  <a href="class_m_px_hw_shader_node.html#abf966a89078baf354c95638086e19d7a">More...</a><br/></td></tr>
<tr class="separator:abf966a89078baf354c95638086e19d7a inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9e054d22b4addd21d5b92c969a7a1ee6 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9e054d22b4addd21d5b92c969a7a1ee6">isTrackingTopology</a> () const </td></tr>
<tr class="memdesc:a9e054d22b4addd21d5b92c969a7a1ee6 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Override this class to return true if this node wants to track topology.  <a href="class_m_px_hw_shader_node.html#a9e054d22b4addd21d5b92c969a7a1ee6">More...</a><br/></td></tr>
<tr class="separator:a9e054d22b4addd21d5b92c969a7a1ee6 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aae473f13648099a8046a067e45d35a2d inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_string_array.html">MStringArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aae473f13648099a8046a067e45d35a2d">getFilesToArchive</a> (bool shortName=false, bool unresolvedName=false, bool markCouldBeImageSequence=false) const </td></tr>
<tr class="memdesc:aae473f13648099a8046a067e45d35a2d inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Use this method to return all external files used by this node.  <a href="class_m_px_hw_shader_node.html#aae473f13648099a8046a067e45d35a2d">More...</a><br/></td></tr>
<tr class="separator:aae473f13648099a8046a067e45d35a2d inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abfc494661ea0f7f957a9e437cebb2642 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#abfc494661ea0f7f957a9e437cebb2642">getExternalContent</a> (<a class="el" href="./class_m_external_content_info_table.html">MExternalContentInfoTable</a> &amp;table) const </td></tr>
<tr class="memdesc:abfc494661ea0f7f957a9e437cebb2642 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the external content (files) that this node depends on.  <a href="class_m_px_hw_shader_node.html#abfc494661ea0f7f957a9e437cebb2642">More...</a><br/></td></tr>
<tr class="separator:abfc494661ea0f7f957a9e437cebb2642 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adcdb8e347afea83dbabcde3fe81fb853 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#adcdb8e347afea83dbabcde3fe81fb853">addExternalContentForFileAttr</a> (<a class="el" href="./class_m_external_content_info_table.html">MExternalContentInfoTable</a> &amp;, const <a class="el" href="./class_m_object.html">MObject</a> &amp;attr) const </td></tr>
<tr class="memdesc:adcdb8e347afea83dbabcde3fe81fb853 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Adds content info to the specified table from a file path attribute.  <a href="class_m_px_hw_shader_node.html#adcdb8e347afea83dbabcde3fe81fb853">More...</a><br/></td></tr>
<tr class="separator:adcdb8e347afea83dbabcde3fe81fb853 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a280288002cbae6c1e42cbfc7695048 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9a280288002cbae6c1e42cbfc7695048">setExternalContentForFileAttr</a> (const <a class="el" href="./class_m_object.html">MObject</a> &amp;attr, const <a class="el" href="./class_m_external_content_location_table.html">MExternalContentLocationTable</a> &amp;)</td></tr>
<tr class="memdesc:a9a280288002cbae6c1e42cbfc7695048 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets content info in the specified attribute from the table.  <a href="class_m_px_hw_shader_node.html#a9a280288002cbae6c1e42cbfc7695048">More...</a><br/></td></tr>
<tr class="separator:a9a280288002cbae6c1e42cbfc7695048 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a389fc88c7e5236aa2b9980a1b452cc49 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a389fc88c7e5236aa2b9980a1b452cc49">setExternalContent</a> (const <a class="el" href="./class_m_external_content_location_table.html">MExternalContentLocationTable</a> &amp;)</td></tr>
<tr class="memdesc:a389fc88c7e5236aa2b9980a1b452cc49 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Changes the location of external content in batch.  <a href="class_m_px_hw_shader_node.html#a389fc88c7e5236aa2b9980a1b452cc49">More...</a><br/></td></tr>
<tr class="separator:a389fc88c7e5236aa2b9980a1b452cc49 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a842aadc96ca39565ad68e366d6b83e inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_type_id.html">MTypeId</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9a842aadc96ca39565ad68e366d6b83e">typeId</a> () const </td></tr>
<tr class="memdesc:a9a842aadc96ca39565ad68e366d6b83e inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the TYPEID of this node.  <a href="class_m_px_hw_shader_node.html#a9a842aadc96ca39565ad68e366d6b83e">More...</a><br/></td></tr>
<tr class="separator:a9a842aadc96ca39565ad68e366d6b83e inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7aa522b0c9a8205c58893dc6bfe4c91f inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_string.html">MString</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a7aa522b0c9a8205c58893dc6bfe4c91f">typeName</a> () const </td></tr>
<tr class="memdesc:a7aa522b0c9a8205c58893dc6bfe4c91f inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the type name of this node.  <a href="class_m_px_hw_shader_node.html#a7aa522b0c9a8205c58893dc6bfe4c91f">More...</a><br/></td></tr>
<tr class="separator:a7aa522b0c9a8205c58893dc6bfe4c91f inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca2cba4630391c78dcf1a828986160da inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_string.html">MString</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aca2cba4630391c78dcf1a828986160da">name</a> () const </td></tr>
<tr class="memdesc:aca2cba4630391c78dcf1a828986160da inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this particular instance of this class.  <a href="class_m_px_hw_shader_node.html#aca2cba4630391c78dcf1a828986160da">More...</a><br/></td></tr>
<tr class="separator:aca2cba4630391c78dcf1a828986160da inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16ef067edb19aa37866cbc7839dbb16e inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a16ef067edb19aa37866cbc7839dbb16e">thisMObject</a> () const </td></tr>
<tr class="memdesc:a16ef067edb19aa37866cbc7839dbb16e inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> associated with this user defined node.  <a href="class_m_px_hw_shader_node.html#a16ef067edb19aa37866cbc7839dbb16e">More...</a><br/></td></tr>
<tr class="separator:a16ef067edb19aa37866cbc7839dbb16e inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab0ec8605b36618dc7975f6615ab27535 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ab0ec8605b36618dc7975f6615ab27535">setExistWithoutInConnections</a> (bool flag)</td></tr>
<tr class="memdesc:ab0ec8605b36618dc7975f6615ab27535 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method specifies whether or not the node can exist without input connections.  <a href="class_m_px_hw_shader_node.html#ab0ec8605b36618dc7975f6615ab27535">More...</a><br/></td></tr>
<tr class="separator:ab0ec8605b36618dc7975f6615ab27535 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a869cac8317d1de1582d987093cdf2a61 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a869cac8317d1de1582d987093cdf2a61">existWithoutInConnections</a> (<a class="el" href="./class_m_status.html">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a869cac8317d1de1582d987093cdf2a61 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not this node can exist without input connections.  <a href="class_m_px_hw_shader_node.html#a869cac8317d1de1582d987093cdf2a61">More...</a><br/></td></tr>
<tr class="separator:a869cac8317d1de1582d987093cdf2a61 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a17b7814993195215e83c55646b977681 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a17b7814993195215e83c55646b977681">setExistWithoutOutConnections</a> (bool flag)</td></tr>
<tr class="memdesc:a17b7814993195215e83c55646b977681 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method specifies whether or not the node can exist without output connections.  <a href="class_m_px_hw_shader_node.html#a17b7814993195215e83c55646b977681">More...</a><br/></td></tr>
<tr class="separator:a17b7814993195215e83c55646b977681 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc771613d9e8b85f9c00673473649521 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#adc771613d9e8b85f9c00673473649521">existWithoutOutConnections</a> (<a class="el" href="./class_m_status.html">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:adc771613d9e8b85f9c00673473649521 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not this node can exist without output connections.  <a href="class_m_px_hw_shader_node.html#adc771613d9e8b85f9c00673473649521">More...</a><br/></td></tr>
<tr class="separator:adc771613d9e8b85f9c00673473649521 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8698b3c96dd363071325966d592d5e7b inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a8698b3c96dd363071325966d592d5e7b">_setMPSafe</a> (bool isMPSafe)</td></tr>
<tr class="memdesc:a8698b3c96dd363071325966d592d5e7b inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#a8698b3c96dd363071325966d592d5e7b">More...</a><br/></td></tr>
<tr class="separator:a8698b3c96dd363071325966d592d5e7b inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c932a98c4a7eca38372c8a0b84cec0f inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="./class_m_data_block.html">MDataBlock</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9c932a98c4a7eca38372c8a0b84cec0f">_forceCache</a> (const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;)</td></tr>
<tr class="memdesc:a9c932a98c4a7eca38372c8a0b84cec0f inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#a9c932a98c4a7eca38372c8a0b84cec0f">More...</a><br/></td></tr>
<tr class="separator:a9c932a98c4a7eca38372c8a0b84cec0f inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69e8d487996ce0ab41fae7ce99498764 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a69e8d487996ce0ab41fae7ce99498764">getInternalValueInContext</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, <a class="el" href="./class_m_data_handle.html">MDataHandle</a> &amp;, <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;)</td></tr>
<tr class="memdesc:a69e8d487996ce0ab41fae7ce99498764 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#a69e8d487996ce0ab41fae7ce99498764">More...</a><br/></td></tr>
<tr class="separator:a69e8d487996ce0ab41fae7ce99498764 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa5a06a44ec1a168d304be997c81e3454 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aa5a06a44ec1a168d304be997c81e3454">setInternalValueInContext</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_data_handle.html">MDataHandle</a> &amp;, <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;)</td></tr>
<tr class="memdesc:aa5a06a44ec1a168d304be997c81e3454 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#aa5a06a44ec1a168d304be997c81e3454">More...</a><br/></td></tr>
<tr class="separator:aa5a06a44ec1a168d304be997c81e3454 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1adbb259ff7f9a698ae86a51c6f621a4 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a1adbb259ff7f9a698ae86a51c6f621a4">internalArrayCount</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;) const </td></tr>
<tr class="memdesc:a1adbb259ff7f9a698ae86a51c6f621a4 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#a1adbb259ff7f9a698ae86a51c6f621a4">More...</a><br/></td></tr>
<tr class="separator:a1adbb259ff7f9a698ae86a51c6f621a4 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a49e2f0b3db50d2e4b0a916713977450d"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_px_hw_shader_node.html">MPxHwShaderNode</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a49e2f0b3db50d2e4b0a916713977450d">getHwShaderNodePtr</a> (<a class="el" href="./class_m_object.html">MObject</a> &amp;object)</td></tr>
<tr class="memdesc:a49e2f0b3db50d2e4b0a916713977450d"><td class="mdescLeft"> </td><td class="mdescRight">This is a static convenience method to be able to get an <a class="el" href="./class_m_px_hw_shader_node.html" title="Base class for user defined hardware shaders. ">MPxHwShaderNode</a> from an <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> provided by a swatch generator class (Class derived from <a class="el" href="./class_m_swatch_render_register.html" title="Manages swatch generators. ">MSwatchRenderRegister</a>).  <a href="class_m_px_hw_shader_node.html#a49e2f0b3db50d2e4b0a916713977450d">More...</a><br/></td></tr>
<tr class="separator:a49e2f0b3db50d2e4b0a916713977450d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td align="right" class="memItemLeft" valign="top">static const char * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this class.  <a href="class_m_px_hw_shader_node.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br/></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_static_methods_class_m_px_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_px_node')"><img alt="-" src="cpp_ref/closed.png"/> Static Public Member Functions inherited from <a class="el" href="./class_m_px_node.html">MPxNode</a></td></tr>
<tr class="memitem:a837094252166c0b365fafb53e4a0203b inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">addAttribute</a> (const <a class="el" href="./class_m_object.html">MObject</a> &amp;attr)</td></tr>
<tr class="memdesc:a837094252166c0b365fafb53e4a0203b inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method adds a new attribute to a user defined node type during the type's initialization.  <a href="class_m_px_hw_shader_node.html#a837094252166c0b365fafb53e4a0203b">More...</a><br/></td></tr>
<tr class="separator:a837094252166c0b365fafb53e4a0203b inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a938700a96e8c37da6027fad6e3373c04 inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a938700a96e8c37da6027fad6e3373c04">inheritAttributesFrom</a> (const <a class="el" href="./class_m_string.html">MString</a> &amp;parentClassName)</td></tr>
<tr class="memdesc:a938700a96e8c37da6027fad6e3373c04 inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method allows a class of plugin node to inherit all of the attributes of a second class of plugin node.  <a href="class_m_px_hw_shader_node.html#a938700a96e8c37da6027fad6e3373c04">More...</a><br/></td></tr>
<tr class="separator:a938700a96e8c37da6027fad6e3373c04 inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aef755adb241fbe273368fefae14047a4 inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aef755adb241fbe273368fefae14047a4">attributeAffects</a> (const <a class="el" href="./class_m_object.html">MObject</a> &amp;whenChanges, const <a class="el" href="./class_m_object.html">MObject</a> &amp;isAffected)</td></tr>
<tr class="memdesc:aef755adb241fbe273368fefae14047a4 inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method specifies that a particular input attribute affects a specific output attribute.  <a href="class_m_px_hw_shader_node.html#aef755adb241fbe273368fefae14047a4">More...</a><br/></td></tr>
<tr class="separator:aef755adb241fbe273368fefae14047a4 inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a214deb1c971a5879657c8b1de4156422 inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a214deb1c971a5879657c8b1de4156422">attributeAffects</a> (const <a class="el" href="./class_m_object.html">MObject</a> &amp;whenChanges, const <a class="el" href="./class_m_object.html">MObject</a> &amp;isAffected, bool affectsTopology)</td></tr>
<tr class="memdesc:a214deb1c971a5879657c8b1de4156422 inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is an extension to the other version of the <em>attributeAffects</em> method.  <a href="class_m_px_hw_shader_node.html#a214deb1c971a5879657c8b1de4156422">More...</a><br/></td></tr>
<tr class="separator:a214deb1c971a5879657c8b1de4156422 inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static const char * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this class.  <a href="class_m_px_hw_shader_node.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br/></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6557dbc4119bbe22dbd137ef4a2ecfbd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6557dbc4119bbe22dbd137ef4a2ecfbd"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a6557dbc4119bbe22dbd137ef4a2ecfbd">outColor</a></td></tr>
<tr class="memdesc:a6557dbc4119bbe22dbd137ef4a2ecfbd"><td class="mdescLeft"> </td><td class="mdescRight">output color value <br/></td></tr>
<tr class="separator:a6557dbc4119bbe22dbd137ef4a2ecfbd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1aab211931f616583648323bf05b92cd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1aab211931f616583648323bf05b92cd"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a1aab211931f616583648323bf05b92cd">outColorR</a></td></tr>
<tr class="memdesc:a1aab211931f616583648323bf05b92cd"><td class="mdescLeft"> </td><td class="mdescRight">output color red <br/></td></tr>
<tr class="separator:a1aab211931f616583648323bf05b92cd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb8a0c842715de056c734b7b35b77ffb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abb8a0c842715de056c734b7b35b77ffb"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#abb8a0c842715de056c734b7b35b77ffb">outColorG</a></td></tr>
<tr class="memdesc:abb8a0c842715de056c734b7b35b77ffb"><td class="mdescLeft"> </td><td class="mdescRight">output color green <br/></td></tr>
<tr class="separator:abb8a0c842715de056c734b7b35b77ffb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9df6eb33c4bb82ef95fd2e8e9e9d79b5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9df6eb33c4bb82ef95fd2e8e9e9d79b5"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a9df6eb33c4bb82ef95fd2e8e9e9d79b5">outColorB</a></td></tr>
<tr class="memdesc:a9df6eb33c4bb82ef95fd2e8e9e9d79b5"><td class="mdescLeft"> </td><td class="mdescRight">output color blue <br/></td></tr>
<tr class="separator:a9df6eb33c4bb82ef95fd2e8e9e9d79b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a35fa1b6d719d1944851f482cedd8592f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a35fa1b6d719d1944851f482cedd8592f"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a35fa1b6d719d1944851f482cedd8592f">outTransparency</a></td></tr>
<tr class="memdesc:a35fa1b6d719d1944851f482cedd8592f"><td class="mdescLeft"> </td><td class="mdescRight">output transparency value <br/></td></tr>
<tr class="separator:a35fa1b6d719d1944851f482cedd8592f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa102575e67c75dafcd45a25e120201e8"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa102575e67c75dafcd45a25e120201e8"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#aa102575e67c75dafcd45a25e120201e8">outTransparencyR</a></td></tr>
<tr class="memdesc:aa102575e67c75dafcd45a25e120201e8"><td class="mdescLeft"> </td><td class="mdescRight">output transparency red <br/></td></tr>
<tr class="separator:aa102575e67c75dafcd45a25e120201e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a760cdafbac5f927586860b27131cc055"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a760cdafbac5f927586860b27131cc055"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a760cdafbac5f927586860b27131cc055">outTransparencyG</a></td></tr>
<tr class="memdesc:a760cdafbac5f927586860b27131cc055"><td class="mdescLeft"> </td><td class="mdescRight">output transparency green <br/></td></tr>
<tr class="separator:a760cdafbac5f927586860b27131cc055"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a60999e04cdd8573397d345577247b6b4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a60999e04cdd8573397d345577247b6b4"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a60999e04cdd8573397d345577247b6b4">outTransparencyB</a></td></tr>
<tr class="memdesc:a60999e04cdd8573397d345577247b6b4"><td class="mdescLeft"> </td><td class="mdescRight">output transparency blue <br/></td></tr>
<tr class="separator:a60999e04cdd8573397d345577247b6b4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aafd35db87b20969cd6d8a1185741b4cf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aafd35db87b20969cd6d8a1185741b4cf"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#aafd35db87b20969cd6d8a1185741b4cf">outMatteOpacity</a></td></tr>
<tr class="memdesc:aafd35db87b20969cd6d8a1185741b4cf"><td class="mdescLeft"> </td><td class="mdescRight">output matte opacity value <br/></td></tr>
<tr class="separator:aafd35db87b20969cd6d8a1185741b4cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad1412be7ca560575f16f5fffb29ced3d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad1412be7ca560575f16f5fffb29ced3d"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#ad1412be7ca560575f16f5fffb29ced3d">outMatteOpacityR</a></td></tr>
<tr class="memdesc:ad1412be7ca560575f16f5fffb29ced3d"><td class="mdescLeft"> </td><td class="mdescRight">output matte opacity red <br/></td></tr>
<tr class="separator:ad1412be7ca560575f16f5fffb29ced3d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a788aa5195f0a8a4d86ca31cfa3afd0f8"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a788aa5195f0a8a4d86ca31cfa3afd0f8"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a788aa5195f0a8a4d86ca31cfa3afd0f8">outMatteOpacityG</a></td></tr>
<tr class="memdesc:a788aa5195f0a8a4d86ca31cfa3afd0f8"><td class="mdescLeft"> </td><td class="mdescRight">output matte opacity green <br/></td></tr>
<tr class="separator:a788aa5195f0a8a4d86ca31cfa3afd0f8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9345279ad5901916423f63330ad71e43"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9345279ad5901916423f63330ad71e43"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a9345279ad5901916423f63330ad71e43">outMatteOpacityB</a></td></tr>
<tr class="memdesc:a9345279ad5901916423f63330ad71e43"><td class="mdescLeft"> </td><td class="mdescRight">output matte opacity blue <br/></td></tr>
<tr class="separator:a9345279ad5901916423f63330ad71e43"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39cfc8b4aea943d6daff25690df2845d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a39cfc8b4aea943d6daff25690df2845d"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a39cfc8b4aea943d6daff25690df2845d">outGlowColor</a></td></tr>
<tr class="memdesc:a39cfc8b4aea943d6daff25690df2845d"><td class="mdescLeft"> </td><td class="mdescRight">output glow color value <br/></td></tr>
<tr class="separator:a39cfc8b4aea943d6daff25690df2845d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa54dc8de0572ce68ffff45b02f31fff"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="afa54dc8de0572ce68ffff45b02f31fff"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#afa54dc8de0572ce68ffff45b02f31fff">outGlowColorR</a></td></tr>
<tr class="memdesc:afa54dc8de0572ce68ffff45b02f31fff"><td class="mdescLeft"> </td><td class="mdescRight">output glow color red <br/></td></tr>
<tr class="separator:afa54dc8de0572ce68ffff45b02f31fff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a32c96c25ab67a4e3693a903865f6a8de"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a32c96c25ab67a4e3693a903865f6a8de"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a32c96c25ab67a4e3693a903865f6a8de">outGlowColorG</a></td></tr>
<tr class="memdesc:a32c96c25ab67a4e3693a903865f6a8de"><td class="mdescLeft"> </td><td class="mdescRight">output glow color green <br/></td></tr>
<tr class="separator:a32c96c25ab67a4e3693a903865f6a8de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4f72dfbd66579c5baa6f4b7523bc2bb4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4f72dfbd66579c5baa6f4b7523bc2bb4"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_hw_shader_node.html#a4f72dfbd66579c5baa6f4b7523bc2bb4">outGlowColorB</a></td></tr>
<tr class="memdesc:a4f72dfbd66579c5baa6f4b7523bc2bb4"><td class="mdescLeft"> </td><td class="mdescRight">output glow color blue <br/></td></tr>
<tr class="separator:a4f72dfbd66579c5baa6f4b7523bc2bb4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_static_attribs_class_m_px_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_m_px_node')"><img alt="-" src="cpp_ref/closed.png"/> Static Public Attributes inherited from <a class="el" href="./class_m_px_node.html">MPxNode</a></td></tr>
<tr class="memitem:ac4a5de65a3a8f057ea39cd749d38971e inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac4a5de65a3a8f057ea39cd749d38971e"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac4a5de65a3a8f057ea39cd749d38971e">message</a></td></tr>
<tr class="memdesc:ac4a5de65a3a8f057ea39cd749d38971e inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">message attribute <br/></td></tr>
<tr class="separator:ac4a5de65a3a8f057ea39cd749d38971e inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca1ef7f3910c1afb1766960fa2a5375d inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aca1ef7f3910c1afb1766960fa2a5375d"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aca1ef7f3910c1afb1766960fa2a5375d">isHistoricallyInteresting</a></td></tr>
<tr class="memdesc:aca1ef7f3910c1afb1766960fa2a5375d inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">is historically interesting attribute <br/></td></tr>
<tr class="separator:aca1ef7f3910c1afb1766960fa2a5375d inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2415a0b1d38a0f851f801c4a18181f91 inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2415a0b1d38a0f851f801c4a18181f91"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a2415a0b1d38a0f851f801c4a18181f91">caching</a></td></tr>
<tr class="memdesc:a2415a0b1d38a0f851f801c4a18181f91 inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">caching attribute <br/></td></tr>
<tr class="separator:a2415a0b1d38a0f851f801c4a18181f91 inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1315838f80fd570104dc41d834d8ff5 inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab1315838f80fd570104dc41d834d8ff5"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ab1315838f80fd570104dc41d834d8ff5">state</a></td></tr>
<tr class="memdesc:ab1315838f80fd570104dc41d834d8ff5 inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">state attribute <br/></td></tr>
<tr class="separator:ab1315838f80fd570104dc41d834d8ff5 inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a73c48c31ea4fca53d389e96e5aadbb8f inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a73c48c31ea4fca53d389e96e5aadbb8f"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a73c48c31ea4fca53d389e96e5aadbb8f">frozen</a></td></tr>
<tr class="memdesc:a73c48c31ea4fca53d389e96e5aadbb8f inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">frozen attribute <br/></td></tr>
<tr class="separator:a73c48c31ea4fca53d389e96e5aadbb8f inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_m_px_node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_px_node')"><img alt="-" src="cpp_ref/closed.png"/> Protected Member Functions inherited from <a class="el" href="./class_m_px_node.html">MPxNode</a></td></tr>
<tr class="memitem:af455f77823c8e3803db82c9f80f2231b inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_data_block.html">MDataBlock</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#af455f77823c8e3803db82c9f80f2231b">forceCache</a> ()</td></tr>
<tr class="memdesc:af455f77823c8e3803db82c9f80f2231b inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">USE _forceCache() IN SCRIPT.  <a href="class_m_px_hw_shader_node.html#af455f77823c8e3803db82c9f80f2231b">More...</a><br/></td></tr>
<tr class="separator:af455f77823c8e3803db82c9f80f2231b inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02d5ad99659b3a4d33135ac436fbc162 inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a02d5ad99659b3a4d33135ac436fbc162">setDoNotWrite</a> (bool flag)</td></tr>
<tr class="memdesc:a02d5ad99659b3a4d33135ac436fbc162 inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">USE _setDoNotWrite() IN SCRIPT.  <a href="class_m_px_hw_shader_node.html#a02d5ad99659b3a4d33135ac436fbc162">More...</a><br/></td></tr>
<tr class="separator:a02d5ad99659b3a4d33135ac436fbc162 inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a50cd371a9d27927032cd8dc6fd3f4710 inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a50cd371a9d27927032cd8dc6fd3f4710">doNotWrite</a> (<a class="el" href="./class_m_status.html">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a50cd371a9d27927032cd8dc6fd3f4710 inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">USE _doNotWrite() IN SCRIPT.  <a href="class_m_px_hw_shader_node.html#a50cd371a9d27927032cd8dc6fd3f4710">More...</a><br/></td></tr>
<tr class="separator:a50cd371a9d27927032cd8dc6fd3f4710 inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afc6e1f9ad83ed00627411828d91cc5cf inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#afc6e1f9ad83ed00627411828d91cc5cf">setMPSafe</a> (bool isMPSafe)</td></tr>
<tr class="memdesc:afc6e1f9ad83ed00627411828d91cc5cf inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#afc6e1f9ad83ed00627411828d91cc5cf">More...</a><br/></td></tr>
<tr class="separator:afc6e1f9ad83ed00627411828d91cc5cf inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aad11c80afa08f06d2ff9a0058b8e6152 inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_data_block.html">MDataBlock</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aad11c80afa08f06d2ff9a0058b8e6152">forceCache</a> (const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;)</td></tr>
<tr class="memdesc:aad11c80afa08f06d2ff9a0058b8e6152 inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_hw_shader_node.html#aad11c80afa08f06d2ff9a0058b8e6152">More...</a><br/></td></tr>
<tr class="separator:aad11c80afa08f06d2ff9a0058b8e6152 inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for user defined hardware shaders. </p>
<p><a class="el" href="./class_m_px_hw_shader_node.html" title="Base class for user defined hardware shaders. ">MPxHwShaderNode</a> allows the creation of user-defined hardware shaders. A hardware shader allows the plug-in writer to control the on-screen display of an object in Maya.</p>
<p>You must derive a hardware shader node from <a class="el" href="./class_m_px_hw_shader_node.html" title="Base class for user defined hardware shaders. ">MPxHwShaderNode</a> for it to have any affect on the on-screen display at all. In addition to their affect on the on-screen display of objects, hardware shaders function as surface shader nodes. This allows you to connect any shading network up to the hardware shader's outColor attribute to handle the shading during a software render.</p>
<p>To create a working hardware shader, derive from this class and override the <a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a>, <a class="el" href="./class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7" title="This method is invoked for hardware rendering to Maya's 3D view. ">unbind()</a>, and <a class="el" href="./class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3" title="This method is obsolete. ">geometry()</a> methods. If your hardware shader uses texture coordinates from Maya, you also need to override either texCoordsPerVertex or <a class="el" href="./class_m_px_hw_shader_node.html#a113794c8b72392d371b6f7b193d80cda" title="NO SCRIPT SUPPORT. ">getTexCoordSetNames()</a>. The other methods of the parent class <a class="el" href="./class_m_px_node.html" title="Base class for user defined dependency nodes. ">MPxNode</a> may also be overridden to perform dependency node capabilities.</p>
<p>NOTE: Plug-in hardware shaders are fully supported for polygonal mesh shapes. NURBS surfaces are only supported in the High Quality Interactive viewport and Hardware Renderer if the glBind/glGeometry/glUnbind methods of this class are implemented. </p>
<dl class="section"><div class="dynheader closed" id="dynsection-example0" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example0-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example0-content" style="display:none;"><dd><a class="el" href="./blind_data_shader_2blind_data_shader_8h-example.html#_a0">blindDataShader/blindDataShader.h</a>, <a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#_a0">cgFx/cgfxShaderNode.h</a>, and <a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#_a0">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a914d22d5dc1e1142541109f5be8038b8"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">OPENMAYA_ENUM </td>
<td>(</td>
<td class="paramtype">Writeable </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kWriteNone </td>
<td class="paramname"> = <code>0x0000</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kWriteVertexArray </td>
<td class="paramname"> = <code>0x0001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kWriteNormalArray </td>
<td class="paramname"> = <code>0x0002</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kWriteColorArrays </td>
<td class="paramname"> = <code>0x0004</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kWriteTexCoordArrays </td>
<td class="paramname"> = <code>0x0008</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kWriteAll </td>
<td class="paramname"> = <code>0x000f</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Bit masks used in conjuction with the 'writeable' parameter passed to the <a class="el" href="./class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3" title="This method is obsolete. ">geometry()</a> method to determine which arrays the shader is allowed to write to. </p>
</div>
</div>
<a class="anchor" id="a25d4c0456e517dcc3badcbd56de097ea"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">OPENMAYA_ENUM </td>
<td>(</td>
<td class="paramtype">DirtyMask </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kDirtyNone </td>
<td class="paramname"> = <code>0x0000</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kDirtyVertexArray </td>
<td class="paramname"> = <code>0x0001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kDirtyNormalArray </td>
<td class="paramname"> = <code>0x0002</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kDirtyColorArrays </td>
<td class="paramname"> = <code>0x0004</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kDirtyTexCoordArrays </td>
<td class="paramname"> = <code>0x0008</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kDirtyAll </td>
<td class="paramname"> = <code>0x000f</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Bit masks used in combination with the return value of the <a class="el" href="./class_m_px_hw_shader_node.html#a54512792bc37d6cfc7771a580b497d2f" title='This method returns a "dirty" mask that indicates which geometry items have changed from the last inv...'>dirtyMask()</a> method to determine which portions of the geometry are dirty. </p>
</div>
</div>
<a class="anchor" id="aa725337cd17aca747baafbaa8660c90c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">OPENMAYA_ENUM </td>
<td>(</td>
<td class="paramtype">TransparencyOptions </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kIsTransparent </td>
<td class="paramname"> = <code>0x0001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kNoTransparencyFrontBackCull </td>
<td class="paramname"> = <code>0x0002</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kNoTransparencyPolygonSort </td>
<td class="paramname"> = <code>0x0004</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Bit masks to be returned by the shader's <a class="el" href="./class_m_px_hw_shader_node.html#abf43698ad6309b49f5790bcd11c21239" title="This method returns transparency options for usage as hints for Maya's internal draw during a given r...">transparencyOptions()</a> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">kIsTransparent</td><td>Draw as a transparent object. If this bit is not set then the others are ignored. </td></tr>
<tr><td class="paramname">kNoTransparencyFrontBackCull</td><td>Do not use the two-pass front-and-back culling algorithm. </td></tr>
<tr><td class="paramname">kNoTransparencyPolygonSort</td><td>Do not use two-pass drawing of back-to-front sorted polygons. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a71bae20f7cb1d030904cf421f1c5eba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">MPxNode::Type type </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the type of the node. </p>
<p>This method should not be overridden by the user. It will return MPxNode::kHwShaderNode.</p>
<dl class="section return"><dt>Returns</dt><dd>The type of node. </dd></dl>
<p>Reimplemented from <a class="el" href="./class_m_px_node.html#a71bae20f7cb1d030904cf421f1c5eba2">MPxNode</a>.</p>
</div>
</div>
<a class="anchor" id="a4b373289ba4ef6bf66387e2b540cdc05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/bind"></a><a class="el" href="./class_m_status.html">MStatus</a> bind </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_draw_request.html">MDrawRequest</a> &amp; </td>
<td class="paramname"><em>request</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m3d_view.html">M3dView</a> &amp; </td>
<td class="paramname"><em>view</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is invoked for hardware rendering to Maya's 3D view. </p>
<p>This is the preferred method of interactive feedback and performance. the "gl" version should be used for batch hardware rendering.</p>
<p>This method is called to set up the OpenGL state. It would typically ensure that textures were bound and that any specific OpenGL extensions are enabled. A status code of MS::kSuccess should be returned unless there was a problem during the display, such as insufficient memory or required input data is missing or invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>the draw request. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">view</td><td>the view in which to draw.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a1add8314dc908073f9126b81dc187ce7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/unbind"></a><a class="el" href="./class_m_status.html">MStatus</a> unbind </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_draw_request.html">MDrawRequest</a> &amp; </td>
<td class="paramname"><em>request</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m3d_view.html">M3dView</a> &amp; </td>
<td class="paramname"><em>view</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is invoked for hardware rendering to Maya's 3D view. </p>
<p>This is the preferred method of interactive feedback and performance. the "gl" version should be used for batch hardware rendering.</p>
<p>This method is called to restore the OpenGL state. Specifically, it must disable any OpenGL extensions that the matching <a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a> method may have enabled. This is necessary to ensure that the rest of Maya's drawing code continues to work correctly. A status code of MS::kSuccess should be returned unless there was a problem such as insufficient memory or required input data is missing or invalid.</p>
<p>The arguments passed to this method are the same ones that were passed to the <a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>the draw request. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">view</td><td>the view in which to draw.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="acd6773ef64b27965c09ed584830bf8f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/geometry"></a><a class="el" href="./class_m_status.html">MStatus</a> geometry </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_draw_request.html">MDrawRequest</a> &amp; </td>
<td class="paramname"><em>request</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m3d_view.html">M3dView</a> &amp; </td>
<td class="paramname"><em>view</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>prim</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>writable</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>indexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const unsigned int * </td>
<td class="paramname"><em>indexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>vertexIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>normalCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>normalArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>colorCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>colorArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>texCoordCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>texCoordArrays</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is obsolete. </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000324">Deprecated:</a></b></dt><dd>Use the version <a class="el" href="./class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3" title="This method is obsolete. ">MPxHwShaderNode::geometry()</a> with the faceIDs argument instead</dd></dl>
<p>This method is invoked for hardware rendering to Maya's 3D view.</p>
<p>This is the preferred method of interactive feedback and performance. the "gl" version should be used for batch hardware rendering.</p>
<p>This method does all the actual OpenGL drawing. The arguments contain all the data to successfully call glDrawElements or glDrawRangeElements. It is possible that there will be multiple calls to this method surrounded by a single call to <a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a> and <a class="el" href="./class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7" title="This method is invoked for hardware rendering to Maya's 3D view. ">unbind()</a>.</p>
<p><b>Note 1.</b> The array of vertex IDs returned corresponds to each triangle's vertex. This allows access to associated blind data per vertex. The vertexIDs array allows querying of information such as color per vertex etc.</p>
<p><b>Note 2.</b> The array of array parameters passed to this method can contain sparse information. Check array positions against NULL to ensure that the array information item is valid.</p>
<p>It is necessary to use the indexArray to access information contained in the data arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>the draw request. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">view</td><td>the view in which to draw. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">prim</td><td>the type of primitive to draw. This is one of the values accepted by glBegin(). Typically it will be GL_TRIANGLES but it could be any of the others. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">writable</td><td>this is a mask which indicates which of the various array arguments can be modified in place. If a bit in writable is set then you can modify corresponding data array (after casting it to a non-const type). If the bit is not set in writable then you must <b>not</b> modify the data since it points to internal Maya storage. You can test the bits in writeable against the values defined by the enum <code>MPxHwShaderNode::Writable</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indexCount</td><td>specifies both the number of indices to draw and the size of the indexArray argument. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indexArray</td><td>the array of index values. This array is in a format suitable for passing as the indices argument to <code>glDrawElements()</code> or <code>glDrawRangeElements()</code>. See the OpenGL documentation for details on calling these routines. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>the number of elements in the vertexArray, the normalArray, each of the colorArrays, and each of the texCoordArrays. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIDs</td><td>the component IDs of the vertices in vertexArray. This array is only provided if it was requested by overriding the <a class="el" href="./class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6" title="This method returns a boolean value that indicates whether a map of the vertex IDs will be provided t...">provideVertexIDs()</a> method to return true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>the array of vertex data. Currently, this is always 3 element floating point values. This data is in a format suitable for passing to <code>glVertexPointer()</code>. See the OpenGL documentation for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalCount</td><td>the number of individual "normal" arrays that are being provided in normalArrays. See the description of normalsPerVertex method below for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalArrays</td><td>the normal (and tangent) data suitable. There may be 0, 1, 2, or 3 "normal" arrays. See the description of the normalsPerVertex method below for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorCount</td><td>the number of individual color arrays. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorArrays</td><td>the arrays of color data. The first set of color data is pointed to by colorArrays[0]. Each color array contains vertexCount color values, each of which is 4 floating point values long and represents the red, green, blue, and alph values on a 0 to 1 scale. Each individual array is suitable for passing to <code>glColorPointer()</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">texCoordCount</td><td>the number of texture coordinate arrays. Each array contains one set of UV texture coordinates. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">texCoordArrays</td><td>the arrays of texture coordinate data. The first set of texture coordinate data is pointed to by texCoordArrays[0]. Each array contains vertexCount coordinate values, each of which is 2 floating point values long. Each individual array is suitable for passing to <code>glTexCoordPointer()</code>.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a929b27bcbcb4140d0228e65c97423902"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/geometry"></a><a class="el" href="./class_m_status.html">MStatus</a> geometry </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_draw_request.html">MDrawRequest</a> &amp; </td>
<td class="paramname"><em>request</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m3d_view.html">M3dView</a> &amp; </td>
<td class="paramname"><em>view</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>prim</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>writable</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>indexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const unsigned int * </td>
<td class="paramname"><em>indexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>vertexIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>normalCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>normalArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>colorCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>colorArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>texCoordCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>texCoordArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>faceIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>localUVCoord</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is invoked for hardware rendering to Maya's 3D view. </p>
<p>This is the preferred method of interactive feedback and performance. the "gl" version should be used for batch hardware rendering.</p>
<p>This method does all the actual OpenGL drawing. The arguments contain all the data to successfully call glDrawElements or glDrawRangeElements. It is possible that there will be multiple calls to this method surrounded by a single call to <a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a> and <a class="el" href="./class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7" title="This method is invoked for hardware rendering to Maya's 3D view. ">unbind()</a>.</p>
<p><b>Note 1.</b> The array of vertex IDs passed in corresponds to each triangle's vertex. This allows access to associated blind data per vertex. The vertexIDs array allows querying of information such as color per vertex etc.</p>
<p>The array of face IDs passed in can be used to query information at a per face level.</p>
<p>The array of local uv coords passed in stores the local uv of the subdivided face vertices.</p>
<p><b>Note 2.</b> The array of array parameters passed to this method can contain sparse information. Check array positions against NULL to ensure that the array information item is valid.</p>
<p>It is necessary to use the indexArray to access information contained in the data arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>the draw request. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">view</td><td>the view in which to draw. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">prim</td><td>the type of primitive to draw. This is one of the values accepted by glBegin(). Typically it will be GL_TRIANGLES but it could be any of the others. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">writable</td><td>this is a mask which indicates which of the various array arguments can be modified in place. If a bit in writable is set then you can modify corresponding data array (after casting it to a non-const type). If the bit is not set in writable then you must <b>not</b> modify the data since it points to internal Maya storage. You can test the bits in writeable against the values defined by the enum <code>MPxHwShaderNode::Writable</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indexCount</td><td>specifies both the number of indices to draw and the size of the indexArray argument. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indexArray</td><td>the array of index values. This array is in a format suitable for passing as the indices argument to <code>glDrawElements()</code> or <code>glDrawRangeElements()</code>. See the OpenGL documentation for details on calling these routines. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>the number of elements in the vertexArray, the normalArray, each of the colorArrays, and each of the texCoordArrays, the vertexID, the faceID and the localUVCoord array. The array length is (vertexCount * the size of the type of data). e.g. vertexCount*3 for vertexArray, and vertexCount*1 for vertexID. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIDs</td><td>the component IDs of the vertices in vertexArray. This array is only provided if it was requested by overriding the <a class="el" href="./class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6" title="This method returns a boolean value that indicates whether a map of the vertex IDs will be provided t...">provideVertexIDs()</a> method to return true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>the array of vertex data. Currently, this is always 3 element floating point values. This data is in a format suitable for passing to <code>glVertexPointer()</code>. See the OpenGL documentation for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalCount</td><td>the number of individual "normal" arrays that are being provided in normalArrays. See the description of normalsPerVertex method below for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalArrays</td><td>the normal (and tangent) data suitable. There may be 0, 1, 2, or 3 "normal" arrays. See the description of the normalsPerVertex method below for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorCount</td><td>the number of individual color arrays. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorArrays</td><td>the arrays of color data. The first set of color data is pointed to by colorArrays[0]. Each color array contains vertexCount color values, each of which is 4 floating point values long and represents the red, green, blue, and alpha values on a 0 to 1 scale. Each individual array is suitable for passing to <code>glColorPointer()</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">texCoordCount</td><td>the number of texture coordinate arrays. Each array contains one set of UV texture coordinates. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">texCoordArrays</td><td>the arrays of texture coordinate data. The first set of texture coordinate data is pointed to by texCoordArrays[0]. Each array contains vertexCount coordinate values, each of which is 2 floating point values long. Each individual array is suitable for passing to <code>glTexCoordPointer()</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIDs</td><td>the component IDs of the faces in vertexArray. This array is only provided if it was requested by overriding the <a class="el" href="./class_m_px_hw_shader_node.html#afa61effad561b9564e161fe930bd038c" title="This method returns a boolean value that indicates whether a map of the face IDs will be provided to ...">provideFaceIDs()</a> method to return true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">localUVCoord</td><td>the local uv of the smooth vertices in vertexArray. This array is only provided if it was requested by overriding the <a class="el" href="./class_m_px_hw_shader_node.html#a276892ea9def000206de6522deccc137" title="This method returns a boolean value that indicates whether the local uv coordinates of the subdivided...">provideLocalUVCoord()</a> method to return true.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa39f824f610a30172f5bb7a130c35069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/glBind"></a><a class="el" href="./class_m_status.html">MStatus</a> glBind </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp; </td>
<td class="paramname"><em>shapePath</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should only be overridden for hardware rendering. </p>
<p>The implementation can assume the graphics context and model view projection matrix have already been set.</p>
<p>This method will be invoked once per frame and should be overridden to allocate any resources needed for the draw. For example, binding vertex programs, fragment programs, or allocating textures. A status code of MS::kSuccess should be returned unless there was a problem such as insufficient memory or required input data is missing or invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">shapePath</td><td>Path to the surface being drawn.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example1" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example1-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example1-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a15">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ab94ce2a19c9ce026e7b0825b5397975e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/glUnbind"></a><a class="el" href="./class_m_status.html">MStatus</a> glUnbind </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp; </td>
<td class="paramname"><em>shapePath</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should only be overridden for hardware rendering. </p>
<p>The implementation can assume the graphics context and model view projection matrix have already been set.</p>
<p>This method will be invoked once per frame and should be overridden to deallocate any resources used to draw. It's important that all resources be released when a batch hardware render has occured because the graphics context will be deleted. It may be desireable to override the other version of bind/unbind to keep track of whether the draw is for the 3D view or the batch hardware renderer. This information could then be used to better track the reuse of resources and optimize performance.</p>
<p>A status code of MS::kSuccess should be returned unless there was a problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">shapePath</td><td>Path to the surface being drawn.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example2" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example2-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example2-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a19">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a495a60eaa1df3815d5565e79e08c90ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/glGeometry"></a><a class="el" href="./class_m_status.html">MStatus</a> glGeometry </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp; </td>
<td class="paramname"><em>shapePath</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>prim</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>writable</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>indexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const unsigned int * </td>
<td class="paramname"><em>indexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>vertexIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>normalCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>normalArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>colorCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>colorArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>texCoordCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>texCoordArrays</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is obsolete. </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000325">Deprecated:</a></b></dt><dd>Use the version <a class="el" href="./class_m_px_hw_shader_node.html#a495a60eaa1df3815d5565e79e08c90ac" title="This method is obsolete. ">MPxHwShaderNode::glGeometry()</a> with the faceIDs argument instead</dd></dl>
<p>This method should only be overridden for hardware rendering.</p>
<p>The implementation can assume graphics context and model view projection matrix have already been set.</p>
<p>This method does all the actual OpenGL drawing. The arguments contain all the data to successfully call glDrawElements or glDrawRangeElements. It is possible that there will be multiple calls to this method surrounded by a single call to <a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a> and <a class="el" href="./class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7" title="This method is invoked for hardware rendering to Maya's 3D view. ">unbind()</a>.</p>
<p><b>Note 1. </b> The array of vertex IDs returned corresponds to each triangle's vertex. This allows access to associated blind data per vertex. The vertexIDs array allows querying of information such as color per vertex etc.</p>
<p><b>Note 2. </b> The array of array parameters passed to this method can contain sparse information. Check array positions against NULL to ensure that the array information item is valid.</p>
<p>It is necessary to use the indexArray to access information contained in the data arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">shapePath</td><td>Path to the surface being drawn. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">prim</td><td>the type of GL primitive is supplied as it would be used for glBegin() or glDrawElements(). Typically it will be GL_TRIANGLES or GL_TRIANGLE_STRIP for drawing polygonal or nurb surfaces respectively. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">writable</td><td>this is a mask which indicates which of the various array arguments can be modified in place. If a bit in writable is set then you can modify corresponding data array (after casting it to a non-const type). If the bit is not set in writable then you must <b>not</b> modify the data since it points to internal Maya storage. You can test the bits in writeable against the values defined by the enum <code>MPxHwShaderNode::Writable</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indexCount</td><td>specifies both the number of indices to draw and the size of the indexArray argument. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indexArray</td><td>the array of index values. This array is in a format suitable for passing as the indices argument to <code>glDrawElements()</code> or <code>glDrawRangeElements()</code>. See the OpenGL documentation for details on calling these routines. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>the number of elements in the vertexArray, the normalArray, each of the colorArrays, and each of the texCoordArrays. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIDs</td><td>the component IDs of the vertices in vertexArray. This array is only provided if it was requested by overriding the <a class="el" href="./class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6" title="This method returns a boolean value that indicates whether a map of the vertex IDs will be provided t...">provideVertexIDs()</a> method to return true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>the array of vertex data. Currently, this is always 3 element floating point values. This data is in a format suitable for passing to <code>glVertexPointer()</code>. See the OpenGL documentation for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalCount</td><td>the number of individual "normal" arrays that are being provided in normalArrays. See the description of normalsPerVertex method below for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalArrays</td><td>the normal (and tangent) data suitable. There may be 0, 1, 2, or 3 "normal" arrays. See the description of the normalsPerVertex method below for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorCount</td><td>the number of individual color arrays. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorArrays</td><td>the arrays of color data. The first set of color data is pointed to by colorArrays[0]. Each color array contains vertexCount color values, each of which is 4 floating point values long and represents the red, green, blue, and alpha values on a 0 to 1 scale. The 3D view and hardware renderer handle missing color data differently. The 3D view will create an array and pass black colors for each vertex, whereas the hardware renderer will supply a NULL pointer to indicate that color per-vertex data is unavailable. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">texCoordCount</td><td>the number of texture coordinate arrays. Each array contains one set of UV texture coordinates. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">texCoordArrays</td><td>the arrays of texture coordinate data. The first set of texture coordinate data is pointed to by texCoordArrays[0]. Each array contains vertexCount coordinate values, each of which is 2 floating point values long. Each individual array is suitable for passing to <code>glTexCoordPointer()</code>. The 3D view and hardware renderer handle missing texture coordinates differently. The 3D view will create an array of [0,0] texture coordinates for each vertex, whereas the hardware renderer will supply a NULL pointer to indicate that uv-set data is unavailable.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example3" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example3-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example3-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a20">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="afc4e163f97e3cabe53c095d83ffecb7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/glGeometry"></a><a class="el" href="./class_m_status.html">MStatus</a> glGeometry </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp; </td>
<td class="paramname"><em>shapePath</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>prim</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>writable</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>indexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const unsigned int * </td>
<td class="paramname"><em>indexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>vertexIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>normalCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>normalArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>colorCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>colorArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>texCoordCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatArrayPtr </td>
<td class="paramname"><em>texCoordArrays</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>faceIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>localUVCoord</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should only be overridden for hardware rendering. </p>
<p>The implementation can assume graphics context and model view projection matrix have already been set.</p>
<p>This method does all the actual OpenGL drawing. The arguments contain all the data to successfully call glDrawElements or glDrawRangeElements. It is possible that there will be multiple calls to this method surrounded by a single call to <a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a> and <a class="el" href="./class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7" title="This method is invoked for hardware rendering to Maya's 3D view. ">unbind()</a>.</p>
<p><b>Note 1. </b> The array of vertex IDs passed in corresponds to each triangle's vertex. This allows access to associated blind data per vertex. The vertexIDs array allows querying of information such as color per vertex etc.</p>
<p>The array of face IDs passed in can be used to query information at a per face level.</p>
<p>The array of local uv coords passed in stores the local uv of the subdivided face vertices.</p>
<p><b>Note 2. </b> The array of array parameters passed to this method can contain sparse information. Check array positions against NULL to ensure that the array information item is valid.</p>
<p>It is necessary to use the indexArray to access information contained in the data arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">shapePath</td><td>Path to the surface being drawn. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">prim</td><td>the type of GL primitive is supplied as it would be used for glBegin() or glDrawElements(). Typically it will be GL_TRIANGLES or GL_TRIANGLE_STRIP for drawing polygonal or nurb surfaces respectively. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">writable</td><td>this is a mask which indicates which of the various array arguments can be modified in place. If a bit in writable is set then you can modify corresponding data array (after casting it to a non-const type). If the bit is not set in writable then you must <b>not</b> modify the data since it points to internal Maya storage. You can test the bits in writeable against the values defined by the enum <code>MPxHwShaderNode::Writable</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indexCount</td><td>specifies both the number of indices to draw and the size of the indexArray argument. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indexArray</td><td>the array of index values. This array is in a format suitable for passing as the indices argument to <code>glDrawElements()</code> or <code>glDrawRangeElements()</code>. See the OpenGL documentation for details on calling these routines. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>the number of elements in the vertexArray, the normalArray, each of the colorArrays, each of the texCoordArrays, the vertexID, the faceID and the localUVCoord array. The array length is (vertexCount * the size of the type of data). e.g. vertexCount*3 for vertexArray, and vertexCount*1 for vertexID. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIDs</td><td>the component IDs of the vertices in vertexArray. This array is only provided if it was requested by overriding the <a class="el" href="./class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6" title="This method returns a boolean value that indicates whether a map of the vertex IDs will be provided t...">provideVertexIDs()</a> method to return true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>the array of vertex data. Currently, this is always 3 element floating point values. This data is in a format suitable for passing to <code>glVertexPointer()</code>. See the OpenGL documentation for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalCount</td><td>the number of individual "normal" arrays that are being provided in normalArrays. See the description of normalsPerVertex method below for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalArrays</td><td>the normal (and tangent) data suitable. There may be 0, 1, 2, or 3 "normal" arrays. See the description of the normalsPerVertex method below for details. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorCount</td><td>the number of individual color arrays. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorArrays</td><td>the arrays of color data. The first set of color data is pointed to by colorArrays[0]. Each color array contains vertexCount color values, each of which is 4 floating point values long and represents the red, green, blue, and alpha values on a 0 to 1 scale. The 3D view and hardware renderer handle missing color data differently. The 3D view will create an array and pass black colors for each vertex, whereas the hardware renderer will supply a NULL pointer to indicate that color per-vertex data is unavailable. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">texCoordCount</td><td>the number of texture coordinate arrays. Each array contains one set of UV texture coordinates. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">texCoordArrays</td><td>the arrays of texture coordinate data. The first set of texture coordinate data is pointed to by texCoordArrays[0]. Each array contains vertexCount coordinate values, each of which is 2 floating point values long. Each individual array is suitable for passing to <code>glTexCoordPointer()</code>. The 3D view and hardware renderer handle missing texture coordinates differently. The 3D view will create an array of [0,0] texture coordinates for each vertex, whereas the hardware renderer will supply a NULL pointer to indicate that uv-set data is unavailable. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIDs</td><td>the component IDs of the faces in vertexArray. This array is only provided if it was requested by overriding the <a class="el" href="./class_m_px_hw_shader_node.html#afa61effad561b9564e161fe930bd038c" title="This method returns a boolean value that indicates whether a map of the face IDs will be provided to ...">provideFaceIDs()</a> method to return true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">localUVCoord</td><td>the local uv of the smooth vertices in vertexArray. This array is only provided if it was requested by overriding the <a class="el" href="./class_m_px_hw_shader_node.html#a276892ea9def000206de6522deccc137" title="This method returns a boolean value that indicates whether the local uv coordinates of the subdivided...">provideLocalUVCoord()</a> method to return true.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aede8bf8429fc531c462df5cdd0bd07a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool supportsBatching </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Specifies whether or not this shader supports batched rendering of shapes. </p>
<p>In normal rendering, a shader is invoked using bind/geometry/unbind (or glBind/glGeometry/glUnbind) once for each shape being rendered. When a shader is used in batched rendering mode however, bind is called once, a series of geometry calls are made for each shape being rendered, followed by a single call to unbind (and similarly for glBind, glGeometry and glUnbind). As shader binding/unbinding can be expensive, batched rendering can significantly improve rendering performance. The more (particularly expensive) operations that can be moved out of the geometry/glGeometry methods the greater the performance improvement is. Ideally, only shape specific operations (such as binding geometry arrays and shape matrices) should be left in the geometry methods.</p>
<p>It is important to note that your shader can only use batched rendering mode if there is no shape (i.e. dag path) specific code in bind, glBind, unbind, or glUnbind. If any of these methods perform shape specific processing, this code must either be moved into geometry/glGeometry, or you must return false in this method to indicate batching should be disabled for this shader.</p>
<p>By default, this method will return false to ensure compatibility with existing shader code.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this shader supports batched rendering, false otherwise </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example4" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example4-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example4-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a11">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a74d50823fbfb6ddfd72fa7c6b1879200"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool invertTexCoords </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Specifies whether this shader requires inverted texture coordinates. </p>
<p>(i.e. where the top-left hand corner of UV space is (0,0) instead of the bottom-left corner).</p>
<p>By default, this method will return false to ensure compatibility with existing shader code.</p>
<dl class="section return"><dt>Returns</dt><dd>true if inverted texture coordinates are required, false otherwise </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example5" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example5-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example5-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a12">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aca13c173921201361dcc0b25baab88f3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/currentPath"></a>const <a class="el" href="./class_m_dag_path.html">MDagPath</a> &amp; currentPath </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a reference to the current path that the shader is invoked for. </p>
<p>The path is only valid before a call to any of the attribute specifying routines:</p>
<ul>
<li><a class="el" href="./class_m_px_hw_shader_node.html#af3550674237dc92887354c8c1aab7367" title="Specifies how many normals per vertex the HW shader would like Maya to provide. ">normalsPerVertex()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a636103e207bea5f6f82065a21c275072" title="This method returns the number of color values per vertex that the hw shader node would like to recei...">colorsPerVertex()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a0e68c77bf2d71c34164b991b33f48971" title="NO SCRIPT SUPPORT. ">getColorSetNames()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a4ad8d328c883db5ee4e4141840c76394" title="This method returns the number of texture coordinate values per vertex that the hw shader node would ...">texCoordsPerVertex()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a113794c8b72392d371b6f7b193d80cda" title="NO SCRIPT SUPPORT. ">getTexCoordSetNames()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a48045e919e9cafe71b7883de1c4875de" title="This method returns a boolean value that indicates whether the object will be drawn transparently or ...">hasTransparency()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6" title="This method returns a boolean value that indicates whether a map of the vertex IDs will be provided t...">provideVertexIDs()</a></li>
</ul>
<p>The path is not guaranteed to be valid at any other time.</p>
<p>This method allows the plugin to return attribute queries which are relative to a specific path or object.</p>
<p>For example, the plugin can retrieve the <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> from the path, then use the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. ">MFnMesh</a> class on the <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a>, assuming the object is a polygonal surface. Through <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. ">MFnMesh</a> the code can query the actual number of texture coordinate sets on the surface and return appropriate values for the <a class="el" href="./class_m_px_hw_shader_node.html#a113794c8b72392d371b6f7b193d80cda" title="NO SCRIPT SUPPORT. ">getTexCoordSetNames()</a> routine.</p>
<p>The [gl]<a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a>, [gl]<a class="el" href="./class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7" title="This method is invoked for hardware rendering to Maya's 3D view. ">unbind()</a> and [gl]<a class="el" href="./class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3" title="This method is obsolete. ">geometry()</a> routines already have access to a dag path which is the same path as the one which can be retrieved via this method.</p>
<p>For performance reasons, it is recommended that for those methods the <a class="el" href="./class_m_dag_path.html" title="DAG Path. ">MDagPath</a> passed in as an argument should be used.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="./class_m_dag_path.html" title="DAG Path. ">MDagPath</a>. Note that this path can be invalid Use <a class="el" href="./class_m_dag_path.html#a095ae34296e81703965265a42ee783ca" title="Determines if Path is valid. ">MDagPath::isValid()</a> to confirm the validity of the path. </dd></dl>
</div>
</div>
<a class="anchor" id="a54512792bc37d6cfc7771a580b497d2f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">unsigned int dirtyMask </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a "dirty" mask that indicates which geometry items have changed from the last invocation of the plugin to draw. </p>
<p>The mask is valid at the time that <a class="el" href="./class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3" title="This method is obsolete. ">geometry()</a> or <a class="el" href="./class_m_px_hw_shader_node.html#a495a60eaa1df3815d5565e79e08c90ac" title="This method is obsolete. ">glGeometry()</a> is called and at no other time.</p>
<p>Note that this mask is relative to the geometry for the current object (path) being drawn by the shader. The current path is the <a class="el" href="./class_m_dag_path.html" title="DAG Path. ">MDagPath</a> argument passed in via the geometry routines.</p>
<p>In general the mask will mark the geometry as not being dirty.</p>
<p>Scenarios where the geometry will be marked dirty include:</p>
<ul>
<li>Whenever a geometry attribute changes. For example positions or normals are modified. </li>
<li>Whenever the attributes being requested changes from the previous invocation of the shader. For example, if in the previous invocation the plugin asks for position only, and in the current invocation asks for position and normals, then the geometry attributes returned will have changed and thus be marked "dirty".</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The dirty mask which can be bit 'AND'ed against the MPxHwShaderNode::DirtyMask enum. </dd></dl>
</div>
</div>
<a class="anchor" id="af3550674237dc92887354c8c1aab7367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int normalsPerVertex </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Specifies how many normals per vertex the HW shader would like Maya to provide. </p>
<p>This can range from 0 to 3. The first normal is the surface normal. The second "normal" is the primary tangent (generally the "u" direction). The third "normal" is the secondary tangent or the binormal (generally the "v" direction). Together, the normal, tangent and binormal form an orthogonal basis frequently named "tangent space basis".</p>
<p>The tangent and binormal vectors are guaranteed to be normalized and orthogonal to the surface normal. Please note that extracting the tangent and/or binormal requires expensive calculations, that will slow down refresh time substantially. In a future version, Maya may cache the resulting tangent space basis; in the meantime, only ask for more than one normal per vertex if they are absolutely required.</p>
<p>Also note that the tangent and binormal calculation requires a uv map. Currently, they are always computed from the first available uv map; if there is no uv mapping on the surface, Maya will only provide surface normals in the geometry call, regardless of the value returned by <a class="el" href="./class_m_px_hw_shader_node.html#af3550674237dc92887354c8c1aab7367" title="Specifies how many normals per vertex the HW shader would like Maya to provide. ">normalsPerVertex()</a>.</p>
<p>If you do not override this method, Maya will provide 1 normal per vertex.</p>
<p>Maya will automatically and silently clamp the result of this function to the [0,3] range.</p>
<p>COMPATIBILITY NOTE: Automatic tangent space basis calculation is only supported starting with Maya 4.0.1. Maya 4.0 supported a different scheme that was much more complicated and no longer supported.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of normal values desired. (0 = none, 1 = surface normal only, 2 = surface normal + tangent, 3 = surface normal + tangent + binormal) </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example6" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example6-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example6-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a25">cgFx/cgfxShaderNode.h</a>, and <a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#a11">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a636103e207bea5f6f82065a21c275072"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int colorsPerVertex </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the number of color values per vertex that the hw shader node would like to receive from Maya. </p>
<p>Maya will attempt to provide all the color data that the shader would like but it will never provide more data that is actually available in the shape. The color sets returned by <a class="el" href="./class_m_px_hw_shader_node.html#a0e68c77bf2d71c34164b991b33f48971" title="NO SCRIPT SUPPORT. ">getColorSetNames()</a> will override the number of color sets specified by <a class="el" href="./class_m_px_hw_shader_node.html#a636103e207bea5f6f82065a21c275072" title="This method returns the number of color values per vertex that the hw shader node would like to recei...">colorsPerVertex()</a>. If you do not override this method or <a class="el" href="./class_m_px_hw_shader_node.html#a0e68c77bf2d71c34164b991b33f48971" title="NO SCRIPT SUPPORT. ">getColorSetNames()</a>, Maya will provide no colors per vertex.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of color values desired </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example7" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example7-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example7-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a24">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a0e68c77bf2d71c34164b991b33f48971"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int getColorSetNames </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html">MStringArray</a> &amp; </td>
<td class="paramname"><em>names</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>NO SCRIPT SUPPORT. </p>
<p>This method returns an array of color per vertex set names.</p>
<p>Maya will attempt to provide color per vertex data from these maps in the corresponding array element in the colorArrays argument to the geometry method. For example, if the names[2] is "cpv56" then colorArrays[2] will be the array of values from cpv56, or NULL if the shape being rendered does not have a color set of that name. If this method is not overridden an empty list of names will be returned, and Maya will use <a class="el" href="./class_m_px_hw_shader_node.html#a636103e207bea5f6f82065a21c275072" title="This method returns the number of color values per vertex that the hw shader node would like to recei...">colorsPerVertex()</a> to determine how many color sets to provide.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>a string array holding the names of the color per vertex sets from which color data should be extracted.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the names array. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example8" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example8-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example8-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a23">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a4ad8d328c883db5ee4e4141840c76394"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int texCoordsPerVertex </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the number of texture coordinate values per vertex that the hw shader node would like to receive from Maya. </p>
<p>Maya will attempt to provide all the texture coordinate data that the shader would like but it will never provide more data than is actually available in the shape. The uv sets returned by <a class="el" href="./class_m_px_hw_shader_node.html#a113794c8b72392d371b6f7b193d80cda" title="NO SCRIPT SUPPORT. ">getTexCoordSetNames()</a> will override the number of uv sets specified by <a class="el" href="./class_m_px_hw_shader_node.html#a4ad8d328c883db5ee4e4141840c76394" title="This method returns the number of texture coordinate values per vertex that the hw shader node would ...">texCoordsPerVertex()</a>. If you do not override this method or <a class="el" href="./class_m_px_hw_shader_node.html#a113794c8b72392d371b6f7b193d80cda" title="NO SCRIPT SUPPORT. ">getTexCoordSetNames()</a>, Maya will provide no texture coordinates per vertex.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, Maya only retains 2 dimensional texture coordinate data but this may change in a future release.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of texture coordinate values desired </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example9" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example9-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example9-content" style="display:none;"><dd><a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#a12">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a113794c8b72392d371b6f7b193d80cda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int getTexCoordSetNames </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html">MStringArray</a> &amp; </td>
<td class="paramname"><em>names</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>NO SCRIPT SUPPORT. </p>
<p>This method returns an array of texture coordinate set names.</p>
<p>Maya will attempt to provide texture coordinates from these maps in the corresponding array element in the texCoordArrays argument to the geometry method. For example, if the names[2] is "uvSet3" then texCoordArrays[2] will be the array of values from uvSet3. If this method is not overridden an empty list of names will be returned, and Maya will use <a class="el" href="./class_m_px_hw_shader_node.html#a4ad8d328c883db5ee4e4141840c76394" title="This method returns the number of texture coordinate values per vertex that the hw shader node would ...">texCoordsPerVertex()</a> to determine how many uv sets to provide.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>a string array holding the names of the uvSets from which texture coordinate data should be extracted.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the names array. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example10" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example10-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example10-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a21">cgFx/cgfxShaderNode.h</a>, and <a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#a13">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a48045e919e9cafe71b7883de1c4875de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool hasTransparency </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a boolean value that indicates whether the object will be drawn transparently or not. </p>
<p>Transparent objects must be drawn after all the opaque objects in the scene or they will not display correctly. Maya uses the return value to determine when it can draw this shape.</p>
<p>Note : The functionality in this method has been subsumed by the <a class="el" href="./class_m_px_hw_shader_node.html#abf43698ad6309b49f5790bcd11c21239" title="This method returns transparency options for usage as hints for Maya's internal draw during a given r...">transparencyOptions()</a> method. It is recommended that shader node writers use this newer method as it provides greater control over how transparency is interpreted by Maya's refresh mechanism.</p>
<p>For backward compatibility, if this method is specified and returns a "true" value, it will override the <a class="el" href="./class_m_px_hw_shader_node.html#abf43698ad6309b49f5790bcd11c21239" title="This method returns transparency options for usage as hints for Maya's internal draw during a given r...">transparencyOptions()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the object will be transparent or false if it will not. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example11" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example11-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example11-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a13">cgFx/cgfxShaderNode.h</a>, and <a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#a15">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ac8569dc0556726f17320788563f034c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool provideVertexIDs </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a boolean value that indicates whether a map of the vertex IDs will be provided to the geometry method. </p>
<dl class="section return"><dt>Returns</dt><dd>true if vertex IDs should be provided to the geometry method. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example12" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example12-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example12-content" style="display:none;"><dd><a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#a16">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="afa61effad561b9564e161fe930bd038c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool provideFaceIDs </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a boolean value that indicates whether a map of the face IDs will be provided to the geometry method. </p>
<dl class="section return"><dt>Returns</dt><dd>true if face IDs should be provided to the geometry method. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example13" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example13-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example13-content" style="display:none;"><dd><a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#a17">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a276892ea9def000206de6522deccc137"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool provideLocalUVCoord </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a boolean value that indicates whether the local uv coordinates of the subdivided face vertices will be provided to the geometry method. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the local uv coordinates should be provided to the geometry method. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example14" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example14-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example14-content" style="display:none;"><dd><a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#a18">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="abf43698ad6309b49f5790bcd11c21239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">unsigned int transparencyOptions </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns transparency options for usage as hints for Maya's internal draw during a given rendering pass. </p>
<p>Parameters are returned via an integer containing masked out bits. By default the mask is set to 0, meaning that the drawing should be treated as regular opaque object drawing. This will generally mean one call per draw pass.</p>
<p>Options to control transparency are specified by returning one or more masks specified by the TransparencyOptions enumeration :</p>
<ul>
<li>kIsTransparent : Draw as a transparent object. If no transparency overrides are specified, then control of how to draw during a given pass is determined internally by Maya's refresh algorithm, and options the user can set per modelling viewport. </li>
<li>kNoTransparencyFrontBackCull : When kisTransparent is set and this flag is set, do not perform transparency drawing using the internal 2-pass front-face + back-face culling algorithm. </li>
<li>kNoTransparencyPolygonSort : When kisTransparent is set and this flag is set, do not perform transparency drawing using the internal 2-pass drawing of back-to-front sorted triangles.</li>
</ul>
<p>Note : Setting the "hasTransparency()" method to true will override this method. This is for backward compatibility with behaviour on existing hardware shader nodes. It is recommended that shaders use the "transparencyOptions()" override, and not longer use the older "hasTransparency()" override from their shader classes.</p>
<dl class="section return"><dt>Returns</dt><dd>Integer containing the appropriate options set via masks. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example15" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example15-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example15-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a14">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a7149feca551be481b5cac8cba24cd70a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/getAvailableImages"></a><a class="el" href="./class_m_status.html">MStatus</a> getAvailableImages </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html">MString</a> &amp; </td>
<td class="paramname"><em>uvSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html">MStringArray</a> &amp; </td>
<td class="paramname"><em>imageNames</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>NO SCRIPT SUPPORT. </p>
<p>Maya will call this method to get your shader's list of images which are available for use in the UV editor for the UV set specified.</p>
<p>Typically, this list will include one entry for each texture using the specified UV set, however, your shader is free to return as many images as you wish (for example, blending between two textures, texture alpha masks, artificially shaded views of bump/normal maps, etc). Your shader's <a class="el" href="./class_m_px_hw_shader_node.html#a6b406fc429c85d0cda4dfb62e1177ea5" title="NO SCRIPT SUPPORT. ">renderImage()</a> method will be used to render the images themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvSetName</td><td>Name of a UV set the channel list should be filtered against.</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">imageNames</td><td>Array in which to return the names of the images this shader defines which are valid for the uvSetName specified.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
<li><b>MS::kNotImplemented</b> Use the default behaviour. </li>
</ul>
</dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example16" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example16-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example16-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a26">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a6b406fc429c85d0cda4dfb62e1177ea5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/renderImage"></a><a class="el" href="./class_m_status.html">MStatus</a> renderImage </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html">MString</a> &amp; </td>
<td class="paramname"><em>imageName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatRegion </td>
<td class="paramname"><em>region</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>imageWidth</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>imageHeight</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>NO SCRIPT SUPPORT. </p>
<p>This method is obsolete.</p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000326">Deprecated:</a></b></dt><dd>Use <a class="el" href="./class_m_px_hw_shader_node.html#a6b406fc429c85d0cda4dfb62e1177ea5" title="NO SCRIPT SUPPORT. ">renderImage()</a> that provides <a class="el" href="./struct_m_px_hw_shader_node_1_1_render_parameters.html" title="Provides information on how to render the image. ">RenderParameters</a> instead.</dd></dl>
<p>This method allows you to to render the background image used for this shader in the UV editor. The image requested will be one of the image names returned by your shader's <a class="el" href="./class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a" title="NO SCRIPT SUPPORT. ">getAvailableImages()</a> method.</p>
<p>The implementation must return the dimensions of the image in the 'imageWidth' and 'imageHeight' parameters so that Maya can perform pixel snapping and other resolution-dependent operations.</p>
<p>The implementation can assume OpenGL context, model view projection matrix, and texture transformations have already been set. A default color of white will be set, however you are free to change this. The magnification filter will be set to either point or bilinear based on user configuration and should not be modified. The values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T are undefined on entry, and your implementation is responsible for setting them to appropriate values (e.g. GL_REPEAT).</p>
<p>The arguments contain the name of the image to render, and the vertex and texture coordinate values to use at each corner of the rectangular image being rendered. Your implementation is responsible for restoring the original the value of any OpenGL state that is modified.</p>
<p>For example: </p><div class="fragment"><div class="line">glPushAttrib( &lt;GL bits your shader modifies&gt; );</div>
<div class="line">glPushClientAttrib( GL_CLIENT_VERTEX_ARRAY_BIT);</div>
<div class="line"></div>
<div class="line">... setup material here ...</div>
<div class="line"></div>
<div class="line">glBegin( GL_QUADS);</div>
<div class="line">glTexCoord2f(region[0][0], region[0][1]);</div>
<div class="line">glVertex2f(region[0][0], region[0][1]);</div>
<div class="line">glTexCoord2f(region[0][0], region[1][1]);</div>
<div class="line">glVertex2f(region[0][0], region[1][1]);</div>
<div class="line">glTexCoord2f(region[1][0], region[1][1]);</div>
<div class="line">glVertex2f(region[1][0], region[1][1]);</div>
<div class="line">glTexCoord2f(region[1][0], region[0][1]);</div>
<div class="line">glVertex2f(region[1][0], region[0][1]);</div>
<div class="line">glEnd();</div>
<div class="line"></div>
<div class="line">glPopAttrib();</div>
<div class="line">glPopClientAttrib();</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">imageName</td><td>Name of the image to render. This corresponds to one of the image names returned by your shader's <a class="el" href="./class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a" title="NO SCRIPT SUPPORT. ">getAvailableImages()</a> method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">region</td><td>Rectangular region to be rendered. The values of this parameter should be used to populate the vertex and texture coordinates of the rectangle being rendered. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">imageWidth</td><td>Native width (e.g. texture pixel width) of the image. This should be for the entire image, not just the portion within 'region'. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">imageHeight</td><td>Native height (e.g. texture pixel height) of the image. This should be for the entire image, not just the portion within 'region'.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example17" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example17-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example17-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a28">cgFx/cgfxShaderNode.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a7c6c731bc1af5cf3e007220689af1c55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/renderImage"></a><a class="el" href="./class_m_status.html">MStatus</a> renderImage </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html">MString</a> &amp; </td>
<td class="paramname"><em>imageName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatRegion </td>
<td class="paramname"><em>region</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./struct_m_px_hw_shader_node_1_1_render_parameters.html">MPxHwShaderNode::RenderParameters</a> &amp; </td>
<td class="paramname"><em>parameters</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>imageWidth</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>imageHeight</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>NO SCRIPT SUPPORT. </p>
<p>This method allows you to to render the background image used for this shader in the UV editor.</p>
<p>The image requested will be one of the image names returned by your shader's <a class="el" href="./class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a" title="NO SCRIPT SUPPORT. ">getAvailableImages()</a> method.</p>
<p>The implementation must return the dimensions of the image in the 'imageWidth' and 'imageHeight' parameters so that Maya can perform pixel snapping and other resolution-dependent operations.</p>
<p>The implementation can assume OpenGL context, model view projection matrix, and texture transformations have already been set. A default color of white will be set, however you are free to change this. The magnification filter will be set to either point or bilinear based on user configuration and should not be modified. The values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T are undefined on entry, and your implementation is responsible for setting them to appropriate values (e.g. GL_REPEAT).</p>
<p>The arguments contain the name of the image to render, and the vertex and texture coordinate values to use at each corner of the rectangular image being rendered. Your implementation is responsible for restoring the original the value of any OpenGL state that is modified.</p>
<p>For example: </p><div class="fragment"><div class="line">glPushAttrib( &lt;GL bits your shader modifies&gt; );</div>
<div class="line">glPushClientAttrib( GL_CLIENT_VERTEX_ARRAY_BIT);</div>
<div class="line"></div>
<div class="line">... setup material here ...</div>
<div class="line"></div>
<div class="line">glBegin( GL_QUADS);</div>
<div class="line">glTexCoord2f(region[0][0], region[0][1]);</div>
<div class="line">glVertex2f(region[0][0], region[0][1]);</div>
<div class="line">glTexCoord2f(region[0][0], region[1][1]);</div>
<div class="line">glVertex2f(region[0][0], region[1][1]);</div>
<div class="line">glTexCoord2f(region[1][0], region[1][1]);</div>
<div class="line">glVertex2f(region[1][0], region[1][1]);</div>
<div class="line">glTexCoord2f(region[1][0], region[0][1]);</div>
<div class="line">glVertex2f(region[1][0], region[0][1]);</div>
<div class="line">glEnd();</div>
<div class="line"></div>
<div class="line">glPopAttrib();</div>
<div class="line">glPopClientAttrib();</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">imageName</td><td>Name of the image to render. This corresponds to one of the image names returned by your shader's <a class="el" href="./class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a" title="NO SCRIPT SUPPORT. ">getAvailableImages()</a> method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">region</td><td>Rectangular region to be rendered. The values of this parameter should be used to populate the vertex and texture coordinates of the rectangle being rendered. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>Additional parameters on how to render the image. The values reflect the image settings of the UV editor. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">imageWidth</td><td>Native width (e.g. texture pixel width) of the image. This should be for the entire image, not just the portion within 'region'. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">imageHeight</td><td>Native height (e.g. texture pixel height) of the image. This should be for the entire image, not just the portion within 'region'.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aab2ba397ffbcaeddb85e73a41aa2270e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/renderImage"></a><a class="el" href="./class_m_status.html">MStatus</a> renderImage </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html">MHWRender::MUIDrawManager</a> &amp; </td>
<td class="paramname"><em>uiDrawManager</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html">MString</a> &amp; </td>
<td class="paramname"><em>imageName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">floatRegion </td>
<td class="paramname"><em>region</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./struct_m_px_hw_shader_node_1_1_render_parameters.html">MPxHwShaderNode::RenderParameters</a> &amp; </td>
<td class="paramname"><em>parameters</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>imageWidth</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>imageHeight</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>NO SCRIPT SUPPORT. </p>
<p>This method allows you to to render the background image used for this shader in the UV editor in viewport 2.0.</p>
<p>The image requested will be one of the image names returned by your shader's <a class="el" href="./class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a" title="NO SCRIPT SUPPORT. ">getAvailableImages()</a> method.</p>
<p>The implementation must return the dimensions of the image in the 'imageWidth' and 'imageHeight' parameters so that Maya can perform pixel snapping and other resolution-dependent operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uiDrawManager</td><td>The UI draw manager, it can be used to draw some simple geometry </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">imageName</td><td>Name of the image to render. This corresponds to one of the image names returned by your shader's <a class="el" href="./class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a" title="NO SCRIPT SUPPORT. ">getAvailableImages()</a> method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">region</td><td>Rectangular region to be rendered. The values of this parameter should be used to populate the vertex and texture coordinates of the rectangle being rendered. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>Additional parameters on how to render the image. The values reflect the image settings of the UV editor. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">imageWidth</td><td>Native width (e.g. texture pixel width) of the image. This should be for the entire image, not just the portion within 'region'. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">imageHeight</td><td>Native height (e.g. texture pixel height) of the image. This should be for the entire image, not just the portion within 'region'.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a765f8d7c0499e87180ff884b6967550e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/renderSwatchImage"></a><a class="el" href="./class_m_status.html">MStatus</a> renderSwatchImage </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_image.html">MImage</a> &amp; </td>
<td class="paramname"><em>image</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>If the shader specifies to override swatch rendering, then this method must be overridden in order to draw anything into a swatch. </p>
<p>The shader will only draw a swatch if it has been registered to do so, by providing a valid classification during <a class="el" href="./class_m_fn_plugin.html#aaae14c466b57bba85f52b96e2f73a9db" title="Register a new dependency node with Maya. ">MFnPlugin::registerNode()</a>. The shader should provide a classification that defines a swatch rendering node such as : "shader/surface/utility/:drawdb/shader/surface/myCustomShader:swatch/myCustomShaderSwatchGenerator" and have "myCustomShaderSwatchGenerator" registered has a swatch renderer : <a class="el" href="./class_m_swatch_render_register.html#a0eb6fd347dae82b48e1ff1f1da9c18a6" title="registers a new swatch generator creation function by name. ">MSwatchRenderRegister::registerSwatchRender</a>("myCustomShaderSwatchGenerator", <a class="el" href="./class_m_h_w_shader_swatch_generator.html#a8746980d47cbb5d20f7cafc6f3996e5c" title="Class constructor. ">MHWShaderSwatchGenerator::createObj</a> );</p>
<p>The default implementation is to draw nothing. The basic logic to draw a swatch is as follows:</p>
<ul>
<li>Determine the size of the swatch required. This is the dimensions of the <a class="el" href="./class_m_image.html" title="Image manipulation. ">MImage</a> passed in as an argument. The pixels for the <a class="el" href="./class_m_image.html" title="Image manipulation. ">MImage</a> will have been pre-allocated. The format of the pixels is 32-bit R,G,B,A, with 8-bits per channel. </li>
<li>Either use an offscreen "swatch context" provided to you or use your own offscreen context. The provided context is available via the <a class="el" href="./class_m_hardware_renderer.html" title="Static hardware renderer interface class. ">MHardwareRenderer</a> class method <b>makeSwatchContextCurrent()</b>. Note that the swatch context may be smaller than the desired image size. In this case the rendering dimensions will be clamped. </li>
<li>Either use swatch geometry provided to you, or use your own swatch geometry. The provided geometry is available via the method <a class="el" href="./class_m_hardware_renderer.html#afb2b5a9604dd4332eab2b9be053b446e" title="This method is obsolete. ">MHardwareRenderer::referenceDefaultGeometry()</a>. The possible "default" geometries are either a sphere, cube or plane. </li>
<li>Either use the provided "default" light and "default" camera or set up your own. Use the methods (getSwatchOrthoCameraSetting(), getSwatchLightDirection()) on <a class="el" href="./class_m_hardware_renderer.html" title="Static hardware renderer interface class. ">MHardwareRenderer</a> to get these defaults. </li>
<li>Read back the swatch context into the provided <a class="el" href="./class_m_image.html" title="Image manipulation. ">MImage</a>. The convenience method <a class="el" href="./class_m_hardware_renderer.html#ae2bc38072d14c1b8e1988e1f2ae73066" title="Read the contents of the swatch context into an MImage. ">MHardwareRenderer::readSwatchContextPixels()</a> can be used. By default the format of the <a class="el" href="./class_m_image.html" title="Image manipulation. ">MImage</a> and the swatch context are the same, so the user does not need to worry about this. The context will read into the pre-allocated <a class="el" href="./class_m_image.html" title="Image manipulation. ">MImage</a> pixels. </li>
<li>Unreference any swatch geometry used for rendering using <a class="el" href="./class_m_hardware_renderer.html#a7038dec27e316897f0daf376faefc2c1" title="This method is obsolete. ">MHardwareRenderer::dereferenceGeometry()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in,out]</td><td class="paramname">image</td><td>Image object to which this method must write the rendered swatch. On input the image's dimensions are already set and pixel storage already allocated.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kNotImplemented</b> : No rendering will occur. </li>
</ul>
</dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example18" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example18-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example18-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8h-example.html#a17">cgFx/cgfxShaderNode.h</a>, and <a class="el" href="./hw_phong_shader_2hw_phong_shader_8h-example.html#a9">hwPhongShader/hwPhongShader.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a49e2f0b3db50d2e4b0a916713977450d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/getHwShaderNodePtr"></a><a class="el" href="./class_m_px_hw_shader_node.html">MPxHwShaderNode</a> * getHwShaderNodePtr </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_object.html">MObject</a> &amp; </td>
<td class="paramname"><em>object</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This is a static convenience method to be able to get an <a class="el" href="./class_m_px_hw_shader_node.html" title="Base class for user defined hardware shaders. ">MPxHwShaderNode</a> from an <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> provided by a swatch generator class (Class derived from <a class="el" href="./class_m_swatch_render_register.html" title="Manages swatch generators. ">MSwatchRenderRegister</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object to examine.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an <a class="el" href="./class_m_px_hw_shader_node.html" title="Base class for user defined hardware shaders. ">MPxHwShaderNode</a>. If the method failed for any reason then a 0 (null) will be returned. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example19" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example19-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example19-content" style="display:none;"><dd><a class="el" href="./cg_fx_2cgfx_shader_node_8cpp-example.html#a5">cgFx/cgfxShaderNode.cpp</a>, and <a class="el" href="./hw_phong_shader_2hw_phong_shader_8cpp-example.html#a21">hwPhongShader/hwPhongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a4791f90368dbb3240b17cb341d4f084b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/currentShadingEngine"></a><a class="el" href="./class_m_object.html">MObject</a> currentShadingEngine </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns an <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> to the shading engine that is currently being rendered. </p>
<p>This method will only return a valid <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> during the following calls:</p>
<ul>
<li><a class="el" href="./class_m_px_hw_shader_node.html#af3550674237dc92887354c8c1aab7367" title="Specifies how many normals per vertex the HW shader would like Maya to provide. ">normalsPerVertex()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a636103e207bea5f6f82065a21c275072" title="This method returns the number of color values per vertex that the hw shader node would like to recei...">colorsPerVertex()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a0e68c77bf2d71c34164b991b33f48971" title="NO SCRIPT SUPPORT. ">getColorSetNames()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a4ad8d328c883db5ee4e4141840c76394" title="This method returns the number of texture coordinate values per vertex that the hw shader node would ...">texCoordsPerVertex()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a113794c8b72392d371b6f7b193d80cda" title="NO SCRIPT SUPPORT. ">getTexCoordSetNames()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a48045e919e9cafe71b7883de1c4875de" title="This method returns a boolean value that indicates whether the object will be drawn transparently or ...">hasTransparency()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#ac8569dc0556726f17320788563f034c6" title="This method returns a boolean value that indicates whether a map of the vertex IDs will be provided t...">provideVertexIDs()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a7149feca551be481b5cac8cba24cd70a" title="NO SCRIPT SUPPORT. ">getAvailableImages()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a4b373289ba4ef6bf66387e2b540cdc05" title="This method is invoked for hardware rendering to Maya's 3D view. ">bind()</a>, <a class="el" href="./class_m_px_hw_shader_node.html#aa39f824f610a30172f5bb7a130c35069" title="This method should only be overridden for hardware rendering. ">glBind()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#acd6773ef64b27965c09ed584830bf8f3" title="This method is obsolete. ">geometry()</a>, <a class="el" href="./class_m_px_hw_shader_node.html#a495a60eaa1df3815d5565e79e08c90ac" title="This method is obsolete. ">glGeometry()</a> </li>
<li><a class="el" href="./class_m_px_hw_shader_node.html#a1add8314dc908073f9126b81dc187ce7" title="This method is invoked for hardware rendering to Maya's 3D view. ">unbind()</a>, <a class="el" href="./class_m_px_hw_shader_node.html#ab94ce2a19c9ce026e7b0825b5397975e" title="This method should only be overridden for hardware rendering. ">glUnbind()</a></li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The shading engine currently being rendered. </dd></dl>
</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const char * className </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class. </dd></dl>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>MPxHwShaderNode.h</li>
<li>MPxHwShaderNode.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>
