<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="MAYAUL" name="product"><meta content="2018" name="release"><meta content="Developer" name="book"><meta content="2017-06-22" name="created"><meta content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887" name="topicid"><meta content="concept" name="topic-type">
<title>MFnMesh Class Reference</title>
<meta content="C++" name="topic-subtype"/></meta></meta></meta></meta></meta></meta></meta></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_fn_mesh.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>MFnMesh Class Reference</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>Main Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li class="current"><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
<div class="tabs2" id="navrow2">
<ul class="tablist">
<li><a href="./annotated.html"><span>Class List</span></a></li>
<li><a href="./classes.html"><span>Class Index</span></a></li>
<li><a href="./hierarchy.html"><span>Class Hierarchy</span></a></li>
<li><a href="./functions.html"><span>Class Members</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">MFnMesh Class Reference<div class="ingroups"><a class="el" href="./group___open_maya.html" translate="no">OpenMaya - API module for common classes</a> | <a class="el" href="./group___m_fn.html" translate="no">FunctionSet classes</a></div></div> </div>
<div id="OverviewLinksDiv"><div class="dynheader closed" id="dynsection-overview" onclick="return toggleVisibility(this)" style="cursor:pointer;"><img alt="+" id="dynsection-overview-trigger" src="cpp_ref/closed.png"> Related help topics: </img></div><div class="dyncontent" id="dynsection-overview-content" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./files/GUID-D2AD2487-5845-48A2-A07F-C9315C8629E9.htm">What's New / What's Changed? &gt; What's New in Maya API in 2018 &gt; What's New in the General and Modeling API</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-20D778B6-325A-4B06-B4A8-AE60D8DAB43D.htm">What's New / What's Changed? &gt; What's New in API in Maya 2017 Update 3</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-653104AC-D0E8-490F-AF00-71DEB76139A4.htm">What's New / What's Changed? &gt; What's New in API in Maya 2016 Extension 2</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-6644CF46-6648-45B8-A3D8-76EDD7712571.htm">What's New / What's Changed? &gt; What's New in API in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-1BB599DB-D637-4D95-AD35-9F85AA5A35ED.htm">What's New / What's Changed? &gt; What's New in API in Maya 2016 &gt; C++ API Changes in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-DBDCB848-B0A5-4256-912C-6FCE25D12984.htm">What's New / What's Changed? &gt; Autodesk Maya 2015</a></li>
<li class="overviewLink"><a href="#!/url=./files/Dependency_graph_plugins_Data_blocks.htm">Dependency graph plug-ins &gt; Working with data blocks</a></li>
<li class="overviewLink"><a href="#!/url=./files/Writing_a_Hardware_Shading_Node_Implementing_a_hardware_shading_node_plugin.htm">Writing a Hardware Shading Node &gt; Implementing a hardware shading node plug-in</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-052EC6C3-BFF1-42E3-B4A5-1725700E3428.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Geometry remapping for hardware rendering</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-2BEF58D3-6162-4235-A6CE-3D8B0742A0AE.htm">Multithreading plug-ins &gt; Threading and Maya</a></li>
<li class="overviewLink"><a href="#!/url=./files/Polygon_API_The_five_basic_polygonal_API_classes.htm">Polygon API &gt; The five basic polygonal API classes</a></li>
<li class="overviewLink"><a href="#!/url=./files/Polygon_API_splitUVCmd_example.htm">Polygon API &gt; splitUVCmd example</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-D92830AD-7CB7-4FDD-B008-2AF1F11F0CD6.htm">Maya Python API &gt; Maya Python Plug-in Learning Path &gt; Command Plug-in Basics &gt; Example: Creating a Scene</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-767D6572-552D-4D94-90E2-AE626F276D37.htm">Maya Python API &gt; Maya Python Plug-in Learning Path &gt; Dependency Graph Plug-in Basics &gt; Example: Voxelizer Node</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-10CE99A6-2C32-49E1-85ED-2E2F6782CF23.htm">Maya Python API &gt; Maya Python Plug-in Learning Path &gt; Dependency Graph Plug-in Basics &gt; Example: Bounding Box Deformer</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-5F3F9272-0968-4AAD-8F0E-A54230E664A3.htm">Maya .NET API &gt; Using IEnumerable and LINQ with the Maya .NET API</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_fn_mesh.html#pub-types">Public Types</a> |
<a href="class_m_fn_mesh.html#pub-methods">Public Member Functions</a> |
<a href="class_m_fn_mesh.html#pub-static-methods">Static Public Member Functions</a> |
<a href="class_m_fn_mesh.html#pro-methods">Protected Member Functions</a> </div></div><!--header-->
<div class="contents">
<p><code>#include &lt;MFnMesh.h&gt;</code></p>
<a id="details" name="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><p>Polygonal surface function set. </p>
<p><b>Note on Terminology: </b> The following terms are used interchangeably:</p>
<ul>
<li>mesh and object, </li>
<li>polygon and face, </li>
<li>object-relative indices and global/mesh-relative indices, </li>
<li>face-relative indices and local indices</li>
</ul>
<p><b>object-relative indices </b> - they range between 0..(<a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" title="Returns the number of vertices in the vertex list for this mesh. " translate="no">numVertices()</a>-1)</p>
<p><b>face-relative indices </b> - they range between 0..(polygonVertexCount(faceId)-1)</p>
<p>This function set provides access to polygonal meshes. Objects of type <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62" title="  " translate="no">MFn::kMesh</a>, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a46e09f8c13b769e11b364b4d09d895c9" title="  " translate="no">MFn::kMeshData</a>, and <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a261666ef558bdbb3bf570c2abadb917d" title="  " translate="no">MFn::kMeshGeom</a> are supported. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62" title="  " translate="no">MFn::kMesh</a> objects are shapes in the DAG, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a261666ef558bdbb3bf570c2abadb917d" title="  " translate="no">MFn::kMeshGeom</a> objects are the raw geometry that the shapes use, and <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a46e09f8c13b769e11b364b4d09d895c9" title="  " translate="no">MFn::kMeshData</a> objects are the data that is passed through dependency graph connections.</p>
<p>NOTE: If the function set has been initialized with a <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62" title="  " translate="no">MFn::kMesh</a> object then it must have geometry attached.</p>
<p><b>Mesh Construction</b> Meshes are created by specifying a vertex list, a list of vertex counts per-polygon, and a list of vertices that make up the polygons. Edge data is also maintained for the mesh and can be returned to the caller. The following lists are used by the create method to construct a mesh:</p>
<ul>
<li><b>vertex list</b> All of the vertices for the mesh are stored in a master vertex list which is an array indexed from 0 to <a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" title="Returns the number of vertices in the vertex list for this mesh. " translate="no">numVertices()</a>-1. Vertices in this list can be shared among polygons.</li>
</ul>
<ul>
<li><b>polygon count list</b> This is a list containing the number of vertices for each polygon. Each polygon in the mesh would have an entry in this list containing its number of vertices.</li>
</ul>
<ul>
<li><b>vertex connection list</b> This is a list of the vertex id's for each polygon. Since polygons can have different numbers of vertices, the polygon count list is used to determine which polygons are represented by the various sections of this list.</li>
</ul>
<p>There are several cases in which the create method will alter the data passed in:</p>
<ul>
<li>If the data for the mesh is provided in such a way that the verticies for some polygons are specified in a clockwise direction, and others in a counter-clockwise direction, the edges between neighboring polygons with reversed orderings will be duplicated. In this context, "duplicating an edge" means that copies will be made of the edge's vertices and the index list for the adjoining polygons will be redefined to</li>
</ul>
<p>use the appropriate vertices.</p>
<ul>
<li>If the <em>vertex connection list</em> for a polygon specifies an edge with the same start and end verticies, those edges will be removed. (ie. a polygon specified as 1 2 2 3 4 will be transformed into 1 2 3 4).</li>
</ul>
<ul>
<li>If the same vertex appears in the <em>vertex connection list</em> for a polygon more than once, another vertex will be created at the same location, and the list will be altered to use the copy. (ie. a polygon specified as 1 2 3 1 4 will be transformed into 1 2 3 5 4, where 5 is in the same location as 1).</li>
</ul>
<p><b>Texture Coordinates (UV's)</b> You can optionally specify texture (uv) coordinates. UV coordinates are 2-d coordinates used for mapping textures to the polygons of a mesh. All of the uv coordinates are stored in one or more named UV sets. The default mesh uv list stores uv coordinates in an array indexed from 0 to <a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" title="Returns the number of texture (uv) coordinates for this mesh. " translate="no">numUVs()</a>-1. UV's are referenced on a per-polygon per-vertex basis, so for a polygon with 4 vertices there would be 4 uv's. The uv values for a polygon are set by specifying the index of the uv for each vertex of the polygon. This index is the uv's position in the master uv array. UV's are optional so polygons do not have to have uv values associated with them. There may be only 1 or 2 polygons in a mesh that have uv coordinates set, or all of the polygons may have uv's. UV's can also be shared so several different polygons may reference the same uv's. If you are creating a UV for the first time or changing the order of the UV then you need to set the UV using one of the setUV methods and then assign new indices using one of the assignUV methods. It is not necessary to call assignUV if editing the position of an existing UV.</p>
<p><b>Color per vertex</b> You can optionally specify color per vertex information using this class. It is possible to create and manipulate color per vertex information using the methods available. Many of the color per vertex methods have a default parameter: colorSet. If unspecified, the method will operate on the current color set.</p>
<p><b>Normals</b> Some of the Normals in Maya are now user-settable. If the vertex normals are not set or locked, they are computed by maya when the mesh changes. If set or locked, the normals remain frozen relative to the object, unless the user unlocks them. There are 3 types of normals for a mesh:</p>
<ul>
<li><b>Per-vertex per-polygon</b> Polygonal objects store a list of per-vertex per-polygon normals (similar to the vertex list) This list is what is returned by <a class="el" href="./class_m_fn_mesh.html#a638962fd4d516c8b1141be76b7405bc8" title="This method copies the normal list for this mesh into the given array. " translate="no">MFnMesh::getNormals</a> and MItMeshPolygon::getNormal(index, normal). As well, MItMeshPolygon::normalIndex( vertexIndex ) returns the index into the normal list for a particular vertex of the polygon.</li>
</ul>
<p>For a cube, the list would contain 24 normals (4 vertices * 6 polygons) since the edges for a cube are hard and the per-vertex per-polygon normals cannot be shared. For a sphere or torus, which has smooth edges, the normals can be shared, and thus the normal list contains the same number of normals as vertices.</p>
<ul>
<li><b>Per-polygon normals</b> Polygonal objects store a normal for each polygon. These normals can be accessed via MItMeshPolygon::getNormal(normal) or <a class="el" href="./class_m_fn_mesh.html#a44aeccc5c93ffd991475c333a2b8e4d7" title="Return the normal at the given polygon. " translate="no">MFnMesh::getPolygonNormal</a>. So, a cube, which is comprised of 6 polygons would contain 6 such normals.</li>
</ul>
<ul>
<li><b>Per-vertex</b> You can also access a normal for each vertex of the mesh, independent of any polygons. Such normals are not stored in the object, but instead are calculated by Maya upon request as the average of all the per-polygon normals for the polygons adjacent to the vertex. These normals are what is returned by <a class="el" href="./class_m_fn_mesh.html#afa4040e2d8b5dd180e3a87e39ff70011" title="This method is obsolete. " translate="no">MFnMesh::getVertexNormal</a> or <a class="el" href="./class_m_it_mesh_vertex.html#a160d912ad4ec50d455ef45e9034afc92" title="Return the normal or averaged normal if unshared of the current vertex. " translate="no">MItMeshVertex::getNormal</a>.</li>
</ul>
<p><b>Blind Data</b> <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> allows you to create Blind Data types, and to create and access mesh component level blind data, but not object level blind data. Object level data may be assigned through the polyBlindData command or the Blind Data Editor. However, object level blind data is just an ordinary compound dynamic attribute directly on the object. The parent attribute name is BlindDataNNNN where NNNN is the blind data typeID. e.g. if your typeId is 1001 your object will have a compound dynamic attr called BlindData1001.</p>
<p><b>Handling Components</b> There are also three iterator classes which provide more specific control over the vertices, edges, and polygons of a mesh and are useful when dealing with components. See <a class="el" href="./class_m_it_mesh_polygon.html" title="Polygon iterator. " translate="no">MItMeshPolygon</a>, <a class="el" href="./class_m_it_mesh_edge.html" title="Polygon edge iterator. " translate="no">MItMeshEdge</a>, and <a class="el" href="./class_m_it_mesh_vertex.html" title="Polygon vertex iterator. " translate="no">MItMeshVertex</a>. </p>
<dl class="section "><div class="dynheader closed" id="dynsection-example0" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example0-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example0-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_abc_write_job_8cpp-example.html#_a50" translate="no">AbcExport/AbcWriteJob.cpp</a>, <a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#_a0" translate="no">AbcExport/MayaMeshWriter.cpp</a>, <a class="el" href="./_abc_import_2_alembic_node_8cpp-example.html#_a93" translate="no">AbcImport/AlembicNode.cpp</a>, <a class="el" href="./_abc_import_2_create_scene_helper_8cpp-example.html#_a28" translate="no">AbcImport/CreateSceneHelper.cpp</a>, <a class="el" href="./_abc_import_2_create_scene_helper_8h-example.html#_a4" translate="no">AbcImport/CreateSceneHelper.h</a>, <a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#_a3" translate="no">AbcImport/MeshHelper.cpp</a>, <a class="el" href="./_abc_import_2_mesh_helper_8h-example.html#_a0" translate="no">AbcImport/MeshHelper.h</a>, <a class="el" href="./_abc_import_2_node_iterator_visitor_helper_8cpp-example.html#_a105" translate="no">AbcImport/NodeIteratorVisitorHelper.cpp</a>, <a class="el" href="./anim_cube_node_2anim_cube_node_8cpp-example.html#_a20" translate="no">animCubeNode/animCubeNode.cpp</a>, <a class="el" href="./api_mesh_shape_2api_mesh_creator_8cpp-example.html#_a24" translate="no">apiMeshShape/apiMeshCreator.cpp</a>, <a class="el" href="./blind_data_shader_2blind_data_mesh_8cpp-example.html#_a15" translate="no">blindDataShader/blindDataMesh.cpp</a>, <a class="el" href="./blind_data_shader_2blind_data_shader_8cpp-example.html#_a19" translate="no">blindDataShader/blindDataShader.cpp</a>, <a class="el" href="./clean_per_face_assignment_2clean_per_face_assignment_cmd_8cpp-example.html#_a13" translate="no">cleanPerFaceAssignment/cleanPerFaceAssignmentCmd.cpp</a>, <a class="el" href="./custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#_a3" translate="no">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" href="./cv_color_shader_2cv_color_shader_8cpp-example.html#_a50" translate="no">cvColorShader/cvColorShader.cpp</a>, <a class="el" href="./_d3_d_viewport_renderer_2_d3_d_geometry_item_8cpp-example.html#_a1" translate="no">D3DViewportRenderer/D3DGeometryItem.cpp</a>, <a class="el" href="./_d3_d_viewport_renderer_2_d3_d_viewport_renderer_8cpp-example.html#_a43" translate="no">D3DViewportRenderer/D3DViewportRenderer.cpp</a>, <a class="el" href="./_d_x11_viewport_renderer_2_d_x11_geometry_item_8cpp-example.html#_a1" translate="no">DX11ViewportRenderer/DX11GeometryItem.cpp</a>, <a class="el" href="./_d_x11_viewport_renderer_2_d_x11_viewport_renderer_8cpp-example.html#_a35" translate="no">DX11ViewportRenderer/DX11ViewportRenderer.cpp</a>, <a class="el" href="./find_textures_per_polygon_cmd_2find_textures_per_polygon_cmd_8cpp-example.html#_a19" translate="no">findTexturesPerPolygonCmd/findTexturesPerPolygonCmd.cpp</a>, <a class="el" href="./flip_u_v_cmd_2flip_u_v_cmd_8cpp-example.html#_a13" translate="no">flipUVCmd/flipUVCmd.cpp</a>, <a class="el" href="./gpu_cache_2_cache_reader_alembic_8h-example.html#_a6" translate="no">gpuCache/CacheReaderAlembic.h</a>, <a class="el" href="./gpu_cache_2_cache_writer_8cpp-example.html#_a7" translate="no">gpuCache/CacheWriter.cpp</a>, <a class="el" href="./gpu_cache_2_cache_writer_8h-example.html#_a5" translate="no">gpuCache/CacheWriter.h</a>, <a class="el" href="./gpu_cache_2gpu_cache_cmd_8cpp-example.html#_a49" translate="no">gpuCache/gpuCacheCmd.cpp</a>, <a class="el" href="./gpu_cache_2gpu_cache_util_8h-example.html#_a30" translate="no">gpuCache/gpuCacheUtil.h</a>, <a class="el" href="./grab_u_v_main_8cpp-example.html#_a27" translate="no">grabUVMain.cpp</a>, <a class="el" href="./hair_collision_solver_2hair_collision_solver_8cpp-example.html#_a9" translate="no">hairCollisionSolver/hairCollisionSolver.cpp</a>, <a class="el" href="./hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#_a74" translate="no">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>, <a class="el" href="./intersect_cmd_2intersect_cmd_8cpp-example.html#_a16" translate="no">intersectCmd/intersectCmd.cpp</a>, <a class="el" href="./list_poly_holes_cmd_2list_poly_holes_cmd_8cpp-example.html#_a12" translate="no">listPolyHolesCmd/listPolyHolesCmd.cpp</a>, <a class="el" href="./mesh_op_cmd_2mesh_op_fty_8h-example.html#_a3" translate="no">meshOpCmd/meshOpFty.h</a>, <a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#_a1" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>, <a class="el" href="./_metadata_sample_2create_metadata_cmd_8cpp-example.html#_a27" translate="no">MetadataSample/createMetadataCmd.cpp</a>, <a class="el" href="./_metadata_sample_2tweak_metadata_node_8cpp-example.html#_a19" translate="no">MetadataSample/tweakMetadataNode.cpp</a>, <a class="el" href="./obj_export_2obj_export_8cpp-example.html#_a13" translate="no">objExport/objExport.cpp</a>, <a class="el" href="./_open_g_l_viewport_renderer_2_open_g_l_viewport_renderer_8cpp-example.html#_a19" translate="no">OpenGLViewportRenderer/OpenGLViewportRenderer.cpp</a>, <a class="el" href="./particle_attr_node_2particle_attr_node_8cpp-example.html#_a38" translate="no">particleAttrNode/particleAttrNode.cpp</a>, <a class="el" href="./point_on_mesh_info_2get_point_and_normal_8cpp-example.html#_a13" translate="no">pointOnMeshInfo/getPointAndNormal.cpp</a>, <a class="el" href="./poly_primitive_cmd_2poly_primitive_cmd_8cpp-example.html#_a19" translate="no">polyPrimitiveCmd/polyPrimitiveCmd.cpp</a>, <a class="el" href="./poly_raw_exporter_2poly_writer_8cpp-example.html#_a2" translate="no">polyRawExporter/polyWriter.cpp</a>, <a class="el" href="./poly_raw_exporter_2poly_writer_8h-example.html#_a8" translate="no">polyRawExporter/polyWriter.h</a>, <a class="el" href="./poly_x3_d_exporter_2poly_writer_8cpp-example.html#_a2" translate="no">polyX3DExporter/polyWriter.cpp</a>, <a class="el" href="./poly_x3_d_exporter_2poly_writer_8h-example.html#_a8" translate="no">polyX3DExporter/polyWriter.h</a>, <a class="el" href="./shell_node_2shell_node_8cpp-example.html#_a20" translate="no">shellNode/shellNode.cpp</a>, <a class="el" href="./splat_deformer_2splat_deformer_8cpp-example.html#_a32" translate="no">splatDeformer/splatDeformer.cpp</a>, <a class="el" href="./split_u_v_cmd_2split_u_v_cmd_8cpp-example.html#_a19" translate="no">splitUVCmd/splitUVCmd.cpp</a>, <a class="el" href="./split_u_v_cmd_2split_u_v_fty_action_8cpp-example.html#_a3" translate="no">splitUVCmd/splitUVFtyAction.cpp</a>, <a class="el" href="./sse_deformer_2sse_deformer_8cpp-example.html#_a28" translate="no">sseDeformer/sseDeformer.cpp</a>, <a class="el" href="./test_nobject_node_2test_nobject_node_8cpp-example.html#_a9" translate="no">testNobjectNode/testNobjectNode.cpp</a>, <a class="el" href="./test_npassive_node_2test_npassive_node_8cpp-example.html#_a8" translate="no">testNpassiveNode/testNpassiveNode.cpp</a>, <a class="el" href="./threaded_bounding_box_2threaded_bounding_box_8cpp-example.html#_a17" translate="no">threadedBoundingBox/threadedBoundingBox.cpp</a>, <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#_a4" translate="no">vertexBufferGenerator/vertexBufferGenerator.cpp</a>, and <a class="el" href="./vertex_buffer_mutator_2vertex_buffer_mutator_8cpp-example.html#_a12" translate="no">vertexBufferMutator/vertexBufferMutator.cpp</a>.</dd></div>
</dl></div><div class="dynheader closed" id="dynsection-0" onclick="return toggleVisibility(this)" style="cursor:pointer;">
<img alt="+" id="dynsection-0-trigger" src="cpp_ref/closed.png"> Inheritance diagram for MFnMesh:</img></div>
<div class="dynsummary" id="dynsection-0-summary" style="display:block;">
</div>
<div class="dyncontent" id="dynsection-0-content" style="display:none;">
<div class="center">
<img alt="" src="cpp_ref/class_m_fn_mesh.png" usemap="#MFnMesh_map">
<map id="MFnMesh_map" name="MFnMesh_map">
<area alt="MFnDagNode" coords="0,112,140,136" href="class_m_fn_dag_node.html" shape="rect" title="DAG Node Function Set. ">
<area alt="MFnDependencyNode" coords="0,56,140,80" href="class_m_fn_dependency_node.html" shape="rect" title="Dependency node function set. ">
<area alt="MFnBase" coords="0,0,140,24" href="class_m_fn_base.html" shape="rect" title="Function Set Base Class. ">
</area></area></area></map>
</img></div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a80dc8673cdbdbb813c71dfa32e0643f2"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> { <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2a1e1554ff20f693b1e84e28330320b237" translate="no">kAlpha</a> = 1, 
<a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2a8cadb7b1406f2e3233ddf5276c8c07ed" translate="no">kRGB</a> = 3, 
<a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2a3c05b20237a36142d29e02c2141ce685" translate="no">kRGBA</a> = 4
 }<tr class="memdesc:a80dc8673cdbdbb813c71dfa32e0643f2"><td class="mdescLeft"> </td><td class="mdescRight">Specifies which color components are used by a colorSet.  <a href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2">More...</a><br/></td></tr>
<tr class="separator:a80dc8673cdbdbb813c71dfa32e0643f2"><td class="memSeparator" colspan="2"> </td></tr>
</td></tr>
<tr class="memitem:a268415a8195ca8a7471a0dc2a611d105"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a268415a8195ca8a7471a0dc2a611d105" translate="no">SplitPlacement</a> { <a class="el" href="./class_m_fn_mesh.html#a268415a8195ca8a7471a0dc2a611d105a0bfc0edc789ffe2049b71e2ea8af262b" translate="no">kOnEdge</a>, 
<a class="el" href="./class_m_fn_mesh.html#a268415a8195ca8a7471a0dc2a611d105a3ecd45a76462bc63dcc4117e6d2cc078" translate="no">kInternalPoint</a>, 
<a class="el" href="./class_m_fn_mesh.html#a268415a8195ca8a7471a0dc2a611d105a94dd08feda7b2cf0ff8262312c4fcc09" translate="no">kInvalid</a>
 }<tr class="memdesc:a268415a8195ca8a7471a0dc2a611d105"><td class="mdescLeft"> </td><td class="mdescRight">Specifies how a point along split is to be determined.  <a href="./class_m_fn_mesh.html#a268415a8195ca8a7471a0dc2a611d105">More...</a><br/></td></tr>
<tr class="separator:a268415a8195ca8a7471a0dc2a611d105"><td class="memSeparator" colspan="2"> </td></tr>
</td></tr>
<tr class="memitem:a4451c8eb916f7cae80bb690274643d8a"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8a" translate="no">BoolOperation</a> { <a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8aa6eb10237f8f0629e0a2e01771e7bda38" translate="no">kUnion</a> = 1, 
<a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8aa1fe9ba39d04b5e63e535da32eb7804ac" translate="no">kDifference</a>, 
<a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8aa2a9eac913399d5326aa7950a906b5c38" translate="no">kIntersection</a>
 }<tr class="memdesc:a4451c8eb916f7cae80bb690274643d8a"><td class="mdescLeft"> </td><td class="mdescRight">Boolean operators.  <a href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8a">More...</a><br/></td></tr>
<tr class="separator:a4451c8eb916f7cae80bb690274643d8a"><td class="memSeparator" colspan="2"> </td></tr>
</td></tr>
<tr class="inherit_header pub_types_class_m_fn_dag_node"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_m_fn_dag_node')"><img alt="-" src="cpp_ref/closed.png"> Public Types inherited from <a class="el" href="./class_m_fn_dag_node.html" translate="no">MFnDagNode</a></img></td></tr>
<tr class="memitem:a0411cd49bb5b71852cecd93bcbf0ca2d inherit pub_types_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom">{ <a class="el" href="./class_m_fn_dag_node.html#a0411cd49bb5b71852cecd93bcbf0ca2dacaa5b6082c10b02e2da670d9a0cbf13e" translate="no">kNextPos</a> = 0xff
 }<tr class="memdesc:a0411cd49bb5b71852cecd93bcbf0ca2d"><td class="mdescLeft"> </td><td class="mdescRight">Anonymous enum to store constant values.  <a href="./class_m_fn_dag_node.html#a0411cd49bb5b71852cecd93bcbf0ca2d">More...</a><br/></td></tr>
<tr class="separator:a0411cd49bb5b71852cecd93bcbf0ca2d inherit pub_types_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
</td></tr>
<tr class="memitem:a3a431d228bde7f6f439c661e3caa224d inherit pub_types_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a3a431d228bde7f6f439c661e3caa224d" translate="no">MObjectColorType</a> { <a class="el" href="./class_m_fn_dag_node.html#a3a431d228bde7f6f439c661e3caa224dae6a9ed395cbe685262af31d76a442419" translate="no">kUseDefaultColor</a> = 0, 
<a class="el" href="./class_m_fn_dag_node.html#a3a431d228bde7f6f439c661e3caa224dae506db95052139157b95e0d92acb5d5d" translate="no">kUseIndexColor</a>, 
<a class="el" href="./class_m_fn_dag_node.html#a3a431d228bde7f6f439c661e3caa224dacf9f8555f745958f25482505abce317b" translate="no">kUseRGBColor</a>
 }<tr class="memdesc:a3a431d228bde7f6f439c661e3caa224d"><td class="mdescLeft"> </td><td class="mdescRight">Enum to set how an object is colored.  <a href="./class_m_fn_dag_node.html#a3a431d228bde7f6f439c661e3caa224d">More...</a><br/></td></tr>
<tr class="separator:a3a431d228bde7f6f439c661e3caa224d inherit pub_types_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
</td></tr>
<tr class="inherit_header pub_types_class_m_fn_dependency_node"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_m_fn_dependency_node')"><img alt="-" src="cpp_ref/closed.png"> Public Types inherited from <a class="el" href="./class_m_fn_dependency_node.html" translate="no">MFnDependencyNode</a></img></td></tr>
<tr class="memitem:a02f8ee0648b8421efbc74c67d840cac0 inherit pub_types_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0" translate="no">MAttrClass</a> { <a class="el" href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0a339f6c76d4f8cc279daf52097633a9ec" translate="no">kLocalDynamicAttr</a> = 1, 
<a class="el" href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0ae88315deec9ff31ddc3b84699f479c4b" translate="no">kNormalAttr</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0a943a0f89dbc0b1e06bd7290193edfc34" translate="no">kExtensionAttr</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0a19d37bbe53c9f756cd27b425f54c916f" translate="no">kInvalidAttr</a>
 }<tr class="memdesc:a02f8ee0648b8421efbc74c67d840cac0"><td class="mdescLeft"> </td><td class="mdescRight">Specifies the scope of the attribute.  <a href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0">More...</a><br/></td></tr>
<tr class="separator:a02f8ee0648b8421efbc74c67d840cac0 inherit pub_types_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
</td></tr>
<tr class="memitem:af67ab59a5df7d4b6a4551d1b4f95a7d8 inherit pub_types_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#af67ab59a5df7d4b6a4551d1b4f95a7d8" translate="no">MdgTimerState</a> { <a class="el" href="./class_m_fn_dependency_node.html#af67ab59a5df7d4b6a4551d1b4f95a7d8a2e441237b14867ec5e40a44f4f898935" translate="no">kTimerOff</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#af67ab59a5df7d4b6a4551d1b4f95a7d8add6275366dcf7b4ff40b16f506b7d3f2" translate="no">kTimerOn</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#af67ab59a5df7d4b6a4551d1b4f95a7d8a55d944667ba77309ed8e2adc61687416" translate="no">kTimerUninitialized</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#af67ab59a5df7d4b6a4551d1b4f95a7d8ac0ddbda618b397f45c2c8d3f54714fbd" translate="no">kTimerInvalidState</a>
 }<tr class="memdesc:af67ab59a5df7d4b6a4551d1b4f95a7d8"><td class="mdescLeft"> </td><td class="mdescRight">Possible states for the node's timer.  <a href="./class_m_fn_dependency_node.html#af67ab59a5df7d4b6a4551d1b4f95a7d8">More...</a><br/></td></tr>
<tr class="separator:af67ab59a5df7d4b6a4551d1b4f95a7d8 inherit pub_types_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
</td></tr>
<tr class="memitem:a583374b4d3ddd639bd008c68d2592ae5 inherit pub_types_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5" translate="no">MdgTimerMetric</a> { <br>
  <a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5a3bdfe87cf756a0f6196ae0ef5f2222ff" translate="no">kTimerMetric_callback</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5a793851be9589aa0428fd0faa72aeeb96" translate="no">kTimerMetric_compute</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5aa805a6bb5bf2804d4efad422003c004d" translate="no">kTimerMetric_dirty</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5a50b14a7789c5b96219e744466de689e0" translate="no">kTimerMetric_draw</a>, 
<br>
  <a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5ade6f481ff1e108dbd00e5567a4354bd1" translate="no">kTimerMetric_fetch</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5aaaeda78090fa03810d2aa2f3ee83f504" translate="no">kTimerMetric_callbackViaAPI</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5aa89da97ba4780da5e5ef6fac00a942e6" translate="no">kTimerMetric_callbackNotViaAPI</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5a46dc72f1a69e81aa9138e8557a424557" translate="no">kTimerMetric_computeDuringCallback</a>, 
<br>
  <a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5af9e7d9d4efda5be614f4e064609bb600" translate="no">kTimerMetric_computeNotDuringCallback</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5a2745aa20672866459b0a6095d47052c9" translate="no">kTimerMetrics</a>
<br>
 }<tr class="memdesc:a583374b4d3ddd639bd008c68d2592ae5"><td class="mdescLeft"> </td><td class="mdescRight">The different timer metrics which can be queried.  <a href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5">More...</a><br/></td></tr>
<tr class="separator:a583374b4d3ddd639bd008c68d2592ae5 inherit pub_types_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
</br></br></br></br></td></tr>
<tr class="memitem:a12e545677c0b06b58953d5f350832ae1 inherit pub_types_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">enum  </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1" translate="no">MdgTimerType</a> { <a class="el" href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1a1ff542d3010f742e176a17b318bb756e" translate="no">kTimerType_self</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1a42b5a5639f95744fd041463281a7303d" translate="no">kTimerType_inclusive</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1a9625c9b6cd648461450d7bb1a5d90651" translate="no">kTimerType_count</a>, 
<a class="el" href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1acc2b9bc5277eb9b7b8e9b47993385333" translate="no">kTimerTypes</a>
 }<tr class="memdesc:a12e545677c0b06b58953d5f350832ae1"><td class="mdescLeft"> </td><td class="mdescRight">The types of timers which can be queried.  <a href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1">More...</a><br/></td></tr>
<tr class="separator:a12e545677c0b06b58953d5f350832ae1 inherit pub_types_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc3250674414e8a0b2f4584959c6ec4c"><td align="right" class="memItemLeft" translate="no" valign="top">virtual <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a> () const </td></tr>
<tr class="memdesc:adc3250674414e8a0b2f4584959c6ec4c"><td class="mdescLeft"> </td><td class="mdescRight">Function set type.  <a href="class_m_fn_mesh.html#adc3250674414e8a0b2f4584959c6ec4c">More...</a><br/></td></tr>
<tr class="separator:adc3250674414e8a0b2f4584959c6ec4c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad5f8a9596b2ead166fe200ccf8f03478"><td align="right" class="memItemLeft" translate="no" valign="top">virtual </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad5f8a9596b2ead166fe200ccf8f03478" translate="no">~MFnMesh</a> ()</td></tr>
<tr class="memdesc:ad5f8a9596b2ead166fe200ccf8f03478"><td class="mdescLeft"> </td><td class="mdescRight">Destructor.  <a href="class_m_fn_mesh.html#ad5f8a9596b2ead166fe200ccf8f03478">More...</a><br/></td></tr>
<tr class="separator:ad5f8a9596b2ead166fe200ccf8f03478"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a625cdfbccd93788b63c151df62a85f47"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="anchor" id="a625cdfbccd93788b63c151df62a85f47"></a>
 </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a625cdfbccd93788b63c151df62a85f47" translate="no">MFnMesh</a> ()</td></tr>
<tr class="memdesc:a625cdfbccd93788b63c151df62a85f47"><td class="mdescLeft"> </td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a625cdfbccd93788b63c151df62a85f47"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa8ebe643258224ce9f9e281f0b922684"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa8ebe643258224ce9f9e281f0b922684" translate="no">MFnMesh</a> (<a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:aa8ebe643258224ce9f9e281f0b922684"><td class="mdescLeft"> </td><td class="mdescRight">Constructor.  <a href="class_m_fn_mesh.html#aa8ebe643258224ce9f9e281f0b922684">More...</a><br/></td></tr>
<tr class="separator:aa8ebe643258224ce9f9e281f0b922684"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a45a8c2938873c91dd49861e752e1fb84"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a45a8c2938873c91dd49861e752e1fb84" translate="no">MFnMesh</a> (const <a class="el" href="./class_m_dag_path.html" translate="no">MDagPath</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ret=NULL)</td></tr>
<tr class="memdesc:a45a8c2938873c91dd49861e752e1fb84"><td class="mdescLeft"> </td><td class="mdescRight">Constructor.  <a href="class_m_fn_mesh.html#a45a8c2938873c91dd49861e752e1fb84">More...</a><br/></td></tr>
<tr class="separator:a45a8c2938873c91dd49861e752e1fb84"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af9b9e5d33d289134d567c62bad4ca3d5"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af9b9e5d33d289134d567c62bad4ca3d5" translate="no">create</a> (int <a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" translate="no">numVertices</a>, int <a class="el" href="./class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed" translate="no">numPolygons</a>, const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonCounts, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonConnects, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:af9b9e5d33d289134d567c62bad4ca3d5"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new polygonal mesh given an array of vertices and polygon connection information and sets this function set to operate on the new surface.  <a href="class_m_fn_mesh.html#af9b9e5d33d289134d567c62bad4ca3d5">More...</a><br/></td></tr>
<tr class="separator:af9b9e5d33d289134d567c62bad4ca3d5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a52ee98712c8f4460342b2fc5d91dba3b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a52ee98712c8f4460342b2fc5d91dba3b" translate="no">create</a> (int <a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" translate="no">numVertices</a>, int <a class="el" href="./class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed" translate="no">numPolygons</a>, const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonCounts, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonConnects, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a52ee98712c8f4460342b2fc5d91dba3b"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new polygonal mesh given an array of vertices and polygon connection information and sets this function set to operate on the new surface.  <a href="class_m_fn_mesh.html#a52ee98712c8f4460342b2fc5d91dba3b">More...</a><br/></td></tr>
<tr class="separator:a52ee98712c8f4460342b2fc5d91dba3b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad0eba420c55b35922afcc548f8571e90"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad0eba420c55b35922afcc548f8571e90" translate="no">create</a> (int <a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" translate="no">numVertices</a>, int <a class="el" href="./class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed" translate="no">numPolygons</a>, const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonCounts, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonConnects, bool storeDoubles, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ad0eba420c55b35922afcc548f8571e90"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new polygonal mesh given an array of vertices and polygon connection information and sets this function set to operate on the new surface.  <a href="class_m_fn_mesh.html#ad0eba420c55b35922afcc548f8571e90">More...</a><br/></td></tr>
<tr class="separator:ad0eba420c55b35922afcc548f8571e90"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a62e8586fb47fb49d10c9d36d3cf5df"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9a62e8586fb47fb49d10c9d36d3cf5df" translate="no">create</a> (int <a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" translate="no">numVertices</a>, int <a class="el" href="./class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed" translate="no">numPolygons</a>, const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonCounts, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonConnects, const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;uArray, const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;vArray, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a9a62e8586fb47fb49d10c9d36d3cf5df"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new polygonal mesh given an array of vertices, polygon connection information, UV information, and sets this function set to operate on the new surface.  <a href="class_m_fn_mesh.html#a9a62e8586fb47fb49d10c9d36d3cf5df">More...</a><br/></td></tr>
<tr class="separator:a9a62e8586fb47fb49d10c9d36d3cf5df"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7aac5894b2e8964bb2722c26fac3edb"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa7aac5894b2e8964bb2722c26fac3edb" translate="no">create</a> (int <a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" translate="no">numVertices</a>, int <a class="el" href="./class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed" translate="no">numPolygons</a>, const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonCounts, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonConnects, const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;uArray, const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;vArray, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:aa7aac5894b2e8964bb2722c26fac3edb"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new polygonal mesh given an array of vertices, polygon connection information, UV information, and sets this function set to operate on the new surface.  <a href="class_m_fn_mesh.html#aa7aac5894b2e8964bb2722c26fac3edb">More...</a><br/></td></tr>
<tr class="separator:aa7aac5894b2e8964bb2722c26fac3edb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac843310c50ba6a4d18733db383c1cb74"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ac843310c50ba6a4d18733db383c1cb74" translate="no">create</a> (const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edges, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edgeConnectsCount, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edgeFaceConnects, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edgeFaceDesc, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ac843310c50ba6a4d18733db383c1cb74"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new polygonal mesh given an array of vertices, edge information, polygon connection information, UV and sets this function set to operate on the new surface.  <a href="class_m_fn_mesh.html#ac843310c50ba6a4d18733db383c1cb74">More...</a><br/></td></tr>
<tr class="separator:ac843310c50ba6a4d18733db383c1cb74"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acb7279765ccba9c472e0845fd91e437e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#acb7279765ccba9c472e0845fd91e437e" translate="no">generateSmoothMesh</a> (<a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_mesh_smooth_options.html" translate="no">MMeshSmoothOptions</a> *options=NULL, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:acb7279765ccba9c472e0845fd91e437e"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new polygonal mesh using either the Smooth Mesh Preview attributes of this mesh or a set of options specified in an <a class="el" href="./class_m_mesh_smooth_options.html" title="Options for control of smooth mesh generation. " translate="no">MMeshSmoothOptions</a> object.  <a href="class_m_fn_mesh.html#acb7279765ccba9c472e0845fd91e437e">More...</a><br/></td></tr>
<tr class="separator:acb7279765ccba9c472e0845fd91e437e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5f8bfd632c7bbdc5bd34345699f2aa87"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5f8bfd632c7bbdc5bd34345699f2aa87" translate="no">getSmoothMeshDisplayOptions</a> (<a class="el" href="./class_m_mesh_smooth_options.html" translate="no">MMeshSmoothOptions</a> &amp;options) const </td></tr>
<tr class="memdesc:a5f8bfd632c7bbdc5bd34345699f2aa87"><td class="mdescLeft"> </td><td class="mdescRight">Retrieve the current display smoothing options for the mesh.  <a href="class_m_fn_mesh.html#a5f8bfd632c7bbdc5bd34345699f2aa87">More...</a><br/></td></tr>
<tr class="separator:a5f8bfd632c7bbdc5bd34345699f2aa87"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab4749565ad2517f28b93599b2c05c96"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aab4749565ad2517f28b93599b2c05c96" translate="no">setSmoothMeshDisplayOptions</a> (const <a class="el" href="./class_m_mesh_smooth_options.html" translate="no">MMeshSmoothOptions</a> &amp;options)</td></tr>
<tr class="memdesc:aab4749565ad2517f28b93599b2c05c96"><td class="mdescLeft"> </td><td class="mdescRight">Sets the current display smoothing options for the mesh.  <a href="class_m_fn_mesh.html#aab4749565ad2517f28b93599b2c05c96">More...</a><br/></td></tr>
<tr class="separator:aab4749565ad2517f28b93599b2c05c96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5d9b2da1ced87d07152df74788558e07"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5d9b2da1ced87d07152df74788558e07" translate="no">addPolygon</a> (const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, bool mergeVertices=true, double pointTolerance=kMFnMeshPointTolerance, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a5d9b2da1ced87d07152df74788558e07"><td class="mdescLeft"> </td><td class="mdescRight">Adds a new polygon to this polygonal mesh.  <a href="class_m_fn_mesh.html#a5d9b2da1ced87d07152df74788558e07">More...</a><br/></td></tr>
<tr class="separator:a5d9b2da1ced87d07152df74788558e07"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6c1fe3ef6d0042ebb6ffb00b68bec287"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a6c1fe3ef6d0042ebb6ffb00b68bec287" translate="no">addPolygon</a> (const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, int &amp;faceIndex, bool mergeVertices=true, double pointTolerance=kMFnMeshPointTolerance, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a6c1fe3ef6d0042ebb6ffb00b68bec287"><td class="mdescLeft"> </td><td class="mdescRight">Adds a new polygon to this polygonal mesh.  <a href="class_m_fn_mesh.html#a6c1fe3ef6d0042ebb6ffb00b68bec287">More...</a><br/></td></tr>
<tr class="separator:a6c1fe3ef6d0042ebb6ffb00b68bec287"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a90d7831027dca6a6b4e6068b2911d755"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a90d7831027dca6a6b4e6068b2911d755" translate="no">addPolygon</a> (const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;loopCounts, int &amp;faceIndex, bool mergeVertices=true, double pointTolerance=kMFnMeshPointTolerance, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a90d7831027dca6a6b4e6068b2911d755"><td class="mdescLeft"> </td><td class="mdescRight">Adds a new polygon to this polygonal mesh.  <a href="class_m_fn_mesh.html#a90d7831027dca6a6b4e6068b2911d755">More...</a><br/></td></tr>
<tr class="separator:a90d7831027dca6a6b4e6068b2911d755"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a99327cc9a37ec10d8027ff15e28e3b95"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a99327cc9a37ec10d8027ff15e28e3b95" translate="no">addHoles</a> (int faceIndex, const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;loopCounts, bool mergeVertices=true, double pointTolerance=kMFnMeshPointTolerance)</td></tr>
<tr class="memdesc:a99327cc9a37ec10d8027ff15e28e3b95"><td class="mdescLeft"> </td><td class="mdescRight">Adds holes to a mesh polygon.  <a href="class_m_fn_mesh.html#a99327cc9a37ec10d8027ff15e28e3b95">More...</a><br/></td></tr>
<tr class="separator:a99327cc9a37ec10d8027ff15e28e3b95"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3e1d9fef8e59f2a65783f4fdac434081"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a3e1d9fef8e59f2a65783f4fdac434081" translate="no">deleteFace</a> (int index, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a3e1d9fef8e59f2a65783f4fdac434081"><td class="mdescLeft"> </td><td class="mdescRight">Delete this face.  <a href="class_m_fn_mesh.html#a3e1d9fef8e59f2a65783f4fdac434081">More...</a><br/></td></tr>
<tr class="separator:a3e1d9fef8e59f2a65783f4fdac434081"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2820d9c79a27560da2c25fc0bdc46b4e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2820d9c79a27560da2c25fc0bdc46b4e" translate="no">deleteEdge</a> (int index, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a2820d9c79a27560da2c25fc0bdc46b4e"><td class="mdescLeft"> </td><td class="mdescRight">Delete this edge.  <a href="class_m_fn_mesh.html#a2820d9c79a27560da2c25fc0bdc46b4e">More...</a><br/></td></tr>
<tr class="separator:a2820d9c79a27560da2c25fc0bdc46b4e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abadea7b4f2817f8744d7353074bd38ca"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#abadea7b4f2817f8744d7353074bd38ca" translate="no">deleteVertex</a> (int index, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:abadea7b4f2817f8744d7353074bd38ca"><td class="mdescLeft"> </td><td class="mdescRight">Delete this vertex.  <a href="class_m_fn_mesh.html#abadea7b4f2817f8744d7353074bd38ca">More...</a><br/></td></tr>
<tr class="separator:abadea7b4f2817f8744d7353074bd38ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa0fab620139a3143447ead1927936248"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa0fab620139a3143447ead1927936248" translate="no">split</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;placements, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edgeList, <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;edgeFactors, <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;internalPoints)</td></tr>
<tr class="memdesc:aa0fab620139a3143447ead1927936248"><td class="mdescLeft"> </td><td class="mdescRight">This function splits a set of edges and faces in a continuous manner.  <a href="class_m_fn_mesh.html#aa0fab620139a3143447ead1927936248">More...</a><br/></td></tr>
<tr class="separator:aa0fab620139a3143447ead1927936248"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8a4e8dfe0bd906b2ac2551e2fb2690f3"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8a4e8dfe0bd906b2ac2551e2fb2690f3" translate="no">subdivideFaces</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, int divisionCount)</td></tr>
<tr class="memdesc:a8a4e8dfe0bd906b2ac2551e2fb2690f3"><td class="mdescLeft"> </td><td class="mdescRight">This function subdivides multiple faces.  <a href="class_m_fn_mesh.html#a8a4e8dfe0bd906b2ac2551e2fb2690f3">More...</a><br/></td></tr>
<tr class="separator:a8a4e8dfe0bd906b2ac2551e2fb2690f3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a25616dd654e9807fe6e74e16d84e2611"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a25616dd654e9807fe6e74e16d84e2611" translate="no">subdivideEdges</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edgeList, int divisionCount)</td></tr>
<tr class="memdesc:a25616dd654e9807fe6e74e16d84e2611"><td class="mdescLeft"> </td><td class="mdescRight">This function subdivides edges at regular intervals.  <a href="class_m_fn_mesh.html#a25616dd654e9807fe6e74e16d84e2611">More...</a><br/></td></tr>
<tr class="separator:a25616dd654e9807fe6e74e16d84e2611"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab15cb5975fdab32d083f0636266ca555"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ab15cb5975fdab32d083f0636266ca555" translate="no">extrudeFaces</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, int extrusionCount, <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> *translation, bool extrudeTogether, float thickness=0.0f, float offset=0.0f)</td></tr>
<tr class="memdesc:ab15cb5975fdab32d083f0636266ca555"><td class="mdescLeft"> </td><td class="mdescRight">This function extrudes a set of faces.  <a href="class_m_fn_mesh.html#ab15cb5975fdab32d083f0636266ca555">More...</a><br/></td></tr>
<tr class="separator:ab15cb5975fdab32d083f0636266ca555"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a35423618f98694bb2a6230e5430f4e5d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a35423618f98694bb2a6230e5430f4e5d" translate="no">extrudeEdges</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edgeList, int extrusionCount, <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> *translation, bool extrudeTogether, float thickness=0.0f, float offset=0.0f)</td></tr>
<tr class="memdesc:a35423618f98694bb2a6230e5430f4e5d"><td class="mdescLeft"> </td><td class="mdescRight">This function extrudes edges.  <a href="class_m_fn_mesh.html#a35423618f98694bb2a6230e5430f4e5d">More...</a><br/></td></tr>
<tr class="separator:a35423618f98694bb2a6230e5430f4e5d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae0c0818607c11b7d2f484a81e475fd66"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ae0c0818607c11b7d2f484a81e475fd66" translate="no">duplicateFaces</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> *translation)</td></tr>
<tr class="memdesc:ae0c0818607c11b7d2f484a81e475fd66"><td class="mdescLeft"> </td><td class="mdescRight">This function duplicates a set of faces and detaches them from the rest of the mesh.  <a href="class_m_fn_mesh.html#ae0c0818607c11b7d2f484a81e475fd66">More...</a><br/></td></tr>
<tr class="separator:ae0c0818607c11b7d2f484a81e475fd66"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8888ea2f9c68478882f0ff4c90c1d40b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8888ea2f9c68478882f0ff4c90c1d40b" translate="no">extractFaces</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> *translation)</td></tr>
<tr class="memdesc:a8888ea2f9c68478882f0ff4c90c1d40b"><td class="mdescLeft"> </td><td class="mdescRight">This function detaches a set of faces from the mesh so that the resulting mesh will contain one more independant piece of geometry and leaves a hole where the faces use to be.  <a href="class_m_fn_mesh.html#a8888ea2f9c68478882f0ff4c90c1d40b">More...</a><br/></td></tr>
<tr class="separator:a8888ea2f9c68478882f0ff4c90c1d40b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a334445a339b2f817b87ac5c87f51cdb1"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a334445a339b2f817b87ac5c87f51cdb1" translate="no">collapseFaces</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList)</td></tr>
<tr class="memdesc:a334445a339b2f817b87ac5c87f51cdb1"><td class="mdescLeft"> </td><td class="mdescRight">This function collapse faces into vertices.  <a href="class_m_fn_mesh.html#a334445a339b2f817b87ac5c87f51cdb1">More...</a><br/></td></tr>
<tr class="separator:a334445a339b2f817b87ac5c87f51cdb1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a68fec76262010b57a32acb44623cd0e9"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a68fec76262010b57a32acb44623cd0e9" translate="no">collapseEdges</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edgeList)</td></tr>
<tr class="memdesc:a68fec76262010b57a32acb44623cd0e9"><td class="mdescLeft"> </td><td class="mdescRight">This function collapse edges into vertices.  <a href="class_m_fn_mesh.html#a68fec76262010b57a32acb44623cd0e9">More...</a><br/></td></tr>
<tr class="separator:a68fec76262010b57a32acb44623cd0e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9959c49420dce143087cb0abe402923e"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" translate="no">numVertices</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a9959c49420dce143087cb0abe402923e"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of vertices in the vertex list for this mesh.  <a href="class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e">More...</a><br/></td></tr>
<tr class="separator:a9959c49420dce143087cb0abe402923e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a742ce017199905f06ad07c178375a2d8"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a742ce017199905f06ad07c178375a2d8" translate="no">numEdges</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a742ce017199905f06ad07c178375a2d8"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of edges for this mesh.  <a href="class_m_fn_mesh.html#a742ce017199905f06ad07c178375a2d8">More...</a><br/></td></tr>
<tr class="separator:a742ce017199905f06ad07c178375a2d8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a7a28cf8f6a12dd19ab6ed0a639f9ed"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed" translate="no">numPolygons</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a3a7a28cf8f6a12dd19ab6ed0a639f9ed"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of polygons for this mesh.  <a href="class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed">More...</a><br/></td></tr>
<tr class="separator:a3a7a28cf8f6a12dd19ab6ed0a639f9ed"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ade2b77f791f506aba04d9d4818c12fee"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ade2b77f791f506aba04d9d4818c12fee" translate="no">numFaceVertices</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ade2b77f791f506aba04d9d4818c12fee"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of face-vertices for this mesh.  <a href="class_m_fn_mesh.html#ade2b77f791f506aba04d9d4818c12fee">More...</a><br/></td></tr>
<tr class="separator:ade2b77f791f506aba04d9d4818c12fee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ca016a3feb28fee0b9f373f86aebced"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4ca016a3feb28fee0b9f373f86aebced" translate="no">polygonVertexCount</a> (int polygonId, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a4ca016a3feb28fee0b9f373f86aebced"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of vertices for the specified polygon.  <a href="class_m_fn_mesh.html#a4ca016a3feb28fee0b9f373f86aebced">More...</a><br/></td></tr>
<tr class="separator:a4ca016a3feb28fee0b9f373f86aebced"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8ec9383ddfdf01902e7d5c8affd0c14c"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" translate="no">numUVs</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a8ec9383ddfdf01902e7d5c8affd0c14c"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of texture (uv) coordinates for this mesh.  <a href="class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c">More...</a><br/></td></tr>
<tr class="separator:a8ec9383ddfdf01902e7d5c8affd0c14c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a88e0df23c70f998573e435cf13b7466c"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a88e0df23c70f998573e435cf13b7466c" translate="no">numUVs</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;uvSet, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a88e0df23c70f998573e435cf13b7466c"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of texture (uv) coordinates for this mesh.  <a href="class_m_fn_mesh.html#a88e0df23c70f998573e435cf13b7466c">More...</a><br/></td></tr>
<tr class="separator:a88e0df23c70f998573e435cf13b7466c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8eba9438fe4c6ab02d307cc02261193e"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" translate="no">numColors</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a8eba9438fe4c6ab02d307cc02261193e"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of (vertex) color for this mesh.  <a href="class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e">More...</a><br/></td></tr>
<tr class="separator:a8eba9438fe4c6ab02d307cc02261193e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7ff2aefcd9553395f959a9754d30bd9e"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a7ff2aefcd9553395f959a9754d30bd9e" translate="no">numColors</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSet, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a7ff2aefcd9553395f959a9754d30bd9e"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of colors (vertex data) for this mesh.  <a href="class_m_fn_mesh.html#a7ff2aefcd9553395f959a9754d30bd9e">More...</a><br/></td></tr>
<tr class="separator:a7ff2aefcd9553395f959a9754d30bd9e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7cc2855f68a882b2217f525068322e0"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ab7cc2855f68a882b2217f525068322e0" translate="no">numNormals</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ab7cc2855f68a882b2217f525068322e0"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of per-polygon per-vertex normals for this mesh.  <a href="class_m_fn_mesh.html#ab7cc2855f68a882b2217f525068322e0">More...</a><br/></td></tr>
<tr class="separator:ab7cc2855f68a882b2217f525068322e0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0e34a918fc6c4c6eb697fc029610bf97"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a0e34a918fc6c4c6eb697fc029610bf97" translate="no">hasColorChannels</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSet, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a0e34a918fc6c4c6eb697fc029610bf97"><td class="mdescLeft"> </td><td class="mdescRight">This method returns if the color set has RGB components.  <a href="class_m_fn_mesh.html#a0e34a918fc6c4c6eb697fc029610bf97">More...</a><br/></td></tr>
<tr class="separator:a0e34a918fc6c4c6eb697fc029610bf97"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a29c14970fc689e97ce67f95f19d38ea6"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a29c14970fc689e97ce67f95f19d38ea6" translate="no">hasAlphaChannels</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSet, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a29c14970fc689e97ce67f95f19d38ea6"><td class="mdescLeft"> </td><td class="mdescRight">This method returns true if the color set has Alpha component.  <a href="class_m_fn_mesh.html#a29c14970fc689e97ce67f95f19d38ea6">More...</a><br/></td></tr>
<tr class="separator:a29c14970fc689e97ce67f95f19d38ea6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af23d73f055a2654f6d2b59a4a1e13c33"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af23d73f055a2654f6d2b59a4a1e13c33" translate="no">getColorRepresentation</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSet, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:af23d73f055a2654f6d2b59a4a1e13c33"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the color representation (RGB/RGBA/A) of a color set.  <a href="class_m_fn_mesh.html#af23d73f055a2654f6d2b59a4a1e13c33">More...</a><br/></td></tr>
<tr class="separator:af23d73f055a2654f6d2b59a4a1e13c33"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a52c541ed670c56137ed1c2dabe97ef7b"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a52c541ed670c56137ed1c2dabe97ef7b" translate="no">isColorClamped</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSet, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a52c541ed670c56137ed1c2dabe97ef7b"><td class="mdescLeft"> </td><td class="mdescRight">This method returns if the color set has its R,G,B,and A components clamped in the range from 0 to 1.  <a href="class_m_fn_mesh.html#a52c541ed670c56137ed1c2dabe97ef7b">More...</a><br/></td></tr>
<tr class="separator:a52c541ed670c56137ed1c2dabe97ef7b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8b07fedf64d78eabfb2c067ac8155c5"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad8b07fedf64d78eabfb2c067ac8155c5" translate="no">setIsColorClamped</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSet, bool clamped)</td></tr>
<tr class="memdesc:ad8b07fedf64d78eabfb2c067ac8155c5"><td class="mdescLeft"> </td><td class="mdescRight">Set the color set to be clamped.  <a href="class_m_fn_mesh.html#ad8b07fedf64d78eabfb2c067ac8155c5">More...</a><br/></td></tr>
<tr class="separator:ad8b07fedf64d78eabfb2c067ac8155c5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4518ef27addc1639a4ae139fe3d75265"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4518ef27addc1639a4ae139fe3d75265" translate="no">getTriangles</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;triangleCounts, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;triangleVertices) const </td></tr>
<tr class="memdesc:a4518ef27addc1639a4ae139fe3d75265"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of triangles for every polygon face and the vertex Ids of each triangle vertex.  <a href="class_m_fn_mesh.html#a4518ef27addc1639a4ae139fe3d75265">More...</a><br/></td></tr>
<tr class="separator:a4518ef27addc1639a4ae139fe3d75265"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21f54d9e1ca3cbed6492f576f9f61215"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a21f54d9e1ca3cbed6492f576f9f61215" translate="no">getTriangleOffsets</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;triangleCounts, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;triangleIndices) const </td></tr>
<tr class="memdesc:a21f54d9e1ca3cbed6492f576f9f61215"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of triangles for every polygon face and the offset into the vertex indices array for each triangle vertex (see <a class="el" href="./class_m_fn_mesh.html#a2f2e041f01dc1ec3648002e2524fbfbc" title="This method retrieves the object-relative (mesh-relative/global) vertex indices for all polygons..." translate="no">getVertices()</a>).  <a href="class_m_fn_mesh.html#a21f54d9e1ca3cbed6492f576f9f61215">More...</a><br/></td></tr>
<tr class="separator:a21f54d9e1ca3cbed6492f576f9f61215"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64611268a18041e82d6f25ffa3c063b6"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a64611268a18041e82d6f25ffa3c063b6" translate="no">booleanOp</a> (<a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8a" translate="no">BoolOperation</a> op, <a class="el" href="./class_m_fn_mesh.html" translate="no">MFnMesh</a> &amp;mesh1, <a class="el" href="./class_m_fn_mesh.html" translate="no">MFnMesh</a> &amp;mesh2)</td></tr>
<tr class="memdesc:a64611268a18041e82d6f25ffa3c063b6"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#a64611268a18041e82d6f25ffa3c063b6">More...</a><br/></td></tr>
<tr class="separator:a64611268a18041e82d6f25ffa3c063b6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a28e288336ac402e5ceda4e8c0e35938b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a28e288336ac402e5ceda4e8c0e35938b" translate="no">booleanOps</a> (<a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8a" translate="no">BoolOperation</a> op, const <a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp;meshes, bool useLegacy=false)</td></tr>
<tr class="memdesc:a28e288336ac402e5ceda4e8c0e35938b"><td class="mdescLeft"> </td><td class="mdescRight">Computes the boolean between multiple meshes.  <a href="class_m_fn_mesh.html#a28e288336ac402e5ceda4e8c0e35938b">More...</a><br/></td></tr>
<tr class="separator:a28e288336ac402e5ceda4e8c0e35938b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afdb59391c386066b662504d4a055c103"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#afdb59391c386066b662504d4a055c103" translate="no">closestIntersection</a> (const <a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp;raySource, const <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> &amp;rayDirection, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *faceIds, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *triIds, bool idsSorted, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space, float maxParam, bool testBothDirections, <a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> *accelerator, <a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp;hitPoint, float *hitRayParam, int *hitFace, int *hitTriangle, float *hitBary1, float *hitBary2, float tolerance=1e-6, MStatus *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:afdb59391c386066b662504d4a055c103"><td class="mdescLeft"> </td><td class="mdescRight">Finds the closest intersection of a ray starting at raySource and travelling in rayDirection with the mesh.  <a href="class_m_fn_mesh.html#afdb59391c386066b662504d4a055c103">More...</a><br/></td></tr>
<tr class="separator:afdb59391c386066b662504d4a055c103"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a935fa7510dbeb972223c06ed5d83b400"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a935fa7510dbeb972223c06ed5d83b400" translate="no">anyIntersection</a> (const <a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp;raySource, const <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> &amp;rayDirection, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *faceIds, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *triIds, bool idsSorted, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space, float maxParam, bool testBothDirections, <a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> *accelerator, <a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp;hitPoint, float *hitRayParam, int *hitFace, int *hitTriangle, float *hitBary1, float *hitBary2, float tolerance=1e-6, MStatus *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a935fa7510dbeb972223c06ed5d83b400"><td class="mdescLeft"> </td><td class="mdescRight">Finds any intersection of a ray starting at raySource and travelling in rayDirection with the mesh.  <a href="class_m_fn_mesh.html#a935fa7510dbeb972223c06ed5d83b400">More...</a><br/></td></tr>
<tr class="separator:a935fa7510dbeb972223c06ed5d83b400"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa6c4717b168258664d399fb92e2cdcee"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa6c4717b168258664d399fb92e2cdcee" translate="no">allIntersections</a> (const <a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp;raySource, const <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> &amp;rayDirection, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *faceIds, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *triIds, bool idsSorted, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space, float maxParam, bool testBothDirections, <a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> *accelerator, bool sortHits, <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;hitPoints, <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> *hitRayParams, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *hitFaces, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *hitTriangles, <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> *hitBary1, <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> *hitBary2, float tolerance=1e-6, MStatus *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:aa6c4717b168258664d399fb92e2cdcee"><td class="mdescLeft"> </td><td class="mdescRight">Finds all intersections of a ray starting at raySource and travelling in rayDirection with the mesh.  <a href="class_m_fn_mesh.html#aa6c4717b168258664d399fb92e2cdcee">More...</a><br/></td></tr>
<tr class="separator:aa6c4717b168258664d399fb92e2cdcee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af90b27d0d9fc6ab7487735bdb220a76d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af90b27d0d9fc6ab7487735bdb220a76d" translate="no">sortIntersectionFaceTriIds</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *faceIds, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *triIds)</td></tr>
<tr class="memdesc:af90b27d0d9fc6ab7487735bdb220a76d"><td class="mdescLeft"> </td><td class="mdescRight">Convenience routine for sorting faceIds or face/triangle ids before passing them into the <a class="el" href="./class_m_fn_mesh.html#afdb59391c386066b662504d4a055c103" title="Finds the closest intersection of a ray starting at raySource and travelling in rayDirection with the..." translate="no">closestIntersection()</a>, <a class="el" href="./class_m_fn_mesh.html#aa6c4717b168258664d399fb92e2cdcee" title="Finds all intersections of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">allIntersections()</a>, or <a class="el" href="./class_m_fn_mesh.html#a935fa7510dbeb972223c06ed5d83b400" title="Finds any intersection of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">anyIntersection()</a> methods.  <a href="class_m_fn_mesh.html#af90b27d0d9fc6ab7487735bdb220a76d">More...</a><br/></td></tr>
<tr class="separator:af90b27d0d9fc6ab7487735bdb220a76d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9e66af440a1965abc80c0e8692c7f475"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9e66af440a1965abc80c0e8692c7f475" translate="no">freeCachedIntersectionAccelerator</a> ()</td></tr>
<tr class="memdesc:a9e66af440a1965abc80c0e8692c7f475"><td class="mdescLeft"> </td><td class="mdescRight">If the mesh has a cached accelerator structure, then this routine forces it to be deleted.  <a href="class_m_fn_mesh.html#a9e66af440a1965abc80c0e8692c7f475">More...</a><br/></td></tr>
<tr class="separator:a9e66af440a1965abc80c0e8692c7f475"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3bc71baf47c585ab81a20cda45f6dabe"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a3bc71baf47c585ab81a20cda45f6dabe" translate="no">cachedIntersectionAcceleratorInfo</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a3bc71baf47c585ab81a20cda45f6dabe"><td class="mdescLeft"> </td><td class="mdescRight">Retrieves a string that describes the intersection acceleration structure for this object, if any.  <a href="class_m_fn_mesh.html#a3bc71baf47c585ab81a20cda45f6dabe">More...</a><br/></td></tr>
<tr class="separator:a3bc71baf47c585ab81a20cda45f6dabe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a51a250da25c242a4f9280d5a1b2781"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4a51a250da25c242a4f9280d5a1b2781" translate="no">intersect</a> (const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;raySource, const <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;rayDirection, <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;points, double tolerance=kMFnMeshPointTolerance, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> *polygonIds=NULL, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a4a51a250da25c242a4f9280d5a1b2781"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether the given ray intersects this polygon and if so, returns the points of intersection.  <a href="class_m_fn_mesh.html#a4a51a250da25c242a4f9280d5a1b2781">More...</a><br/></td></tr>
<tr class="separator:a4a51a250da25c242a4f9280d5a1b2781"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad5193aa05f1daf24f9bb439d0669758a"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad5193aa05f1daf24f9bb439d0669758a" translate="no">getClosestPointAndNormal</a> (const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;toThisPoint, <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;theClosestPoint, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;theNormal, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, int *closestPolygon=NULL, <a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> *accelParams=NULL) const </td></tr>
<tr class="memdesc:ad5193aa05f1daf24f9bb439d0669758a"><td class="mdescLeft"> </td><td class="mdescRight">Returns the closest point on this surface to the given point.  <a href="class_m_fn_mesh.html#ad5193aa05f1daf24f9bb439d0669758a">More...</a><br/></td></tr>
<tr class="separator:ad5193aa05f1daf24f9bb439d0669758a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a37d285a0c9e137f7ef6aedd0b180f79d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a37d285a0c9e137f7ef6aedd0b180f79d" translate="no">getClosestPoint</a> (const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;toThisPoint, <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;theClosestPoint, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, int *closestPolygon=NULL, <a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> *accelerator=NULL) const </td></tr>
<tr class="memdesc:a37d285a0c9e137f7ef6aedd0b180f79d"><td class="mdescLeft"> </td><td class="mdescRight">Returns the closest point on this surface to the given point.  <a href="class_m_fn_mesh.html#a37d285a0c9e137f7ef6aedd0b180f79d">More...</a><br/></td></tr>
<tr class="separator:a37d285a0c9e137f7ef6aedd0b180f79d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5d70e4aa5fd6a04874fb17d3ab1ef2d3"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5d70e4aa5fd6a04874fb17d3ab1ef2d3" translate="no">getClosestNormal</a> (const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;toThisPoint, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;theNormal, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, int *closestPolygon=NULL, <a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> *accelerator=NULL) const </td></tr>
<tr class="memdesc:a5d70e4aa5fd6a04874fb17d3ab1ef2d3"><td class="mdescLeft"> </td><td class="mdescRight">Returns the closest point on this surface to the given point.  <a href="class_m_fn_mesh.html#a5d70e4aa5fd6a04874fb17d3ab1ef2d3">More...</a><br/></td></tr>
<tr class="separator:a5d70e4aa5fd6a04874fb17d3ab1ef2d3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ef7a8385f5ed8821b93bac29e934349"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a1ef7a8385f5ed8821b93bac29e934349" translate="no">getClosestUVs</a> (const float2 &amp;toThisUVPoint, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;uvIds, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a1ef7a8385f5ed8821b93bac29e934349"><td class="mdescLeft"> </td><td class="mdescRight">Returns the IDs of the UVs on this surface which are nearest in uv space to the given uv set and coordinate.  <a href="class_m_fn_mesh.html#a1ef7a8385f5ed8821b93bac29e934349">More...</a><br/></td></tr>
<tr class="separator:a1ef7a8385f5ed8821b93bac29e934349"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e7ae06b08040e5fb1e44dd354fc6a29"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2e7ae06b08040e5fb1e44dd354fc6a29" translate="no">intersectFaceAtUV</a> (const float2 &amp;toThisUVPoint, int &amp;faceId, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a2e7ae06b08040e5fb1e44dd354fc6a29"><td class="mdescLeft"> </td><td class="mdescRight">Returns ID of the intersected face at given uv set and coordinate.  <a href="class_m_fn_mesh.html#a2e7ae06b08040e5fb1e44dd354fc6a29">More...</a><br/></td></tr>
<tr class="separator:a2e7ae06b08040e5fb1e44dd354fc6a29"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8b9cfa962b307bc28598b6b4885432cc"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8b9cfa962b307bc28598b6b4885432cc" translate="no">getConnectedShaders</a> (unsigned int instanceNumber, <a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp;shaders, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;indices) const </td></tr>
<tr class="memdesc:a8b9cfa962b307bc28598b6b4885432cc"><td class="mdescLeft"> </td><td class="mdescRight">Returns all the shaders (sets) connected to the specified instance of this mesh, as well as an array of polygon/shader assignments.  <a href="class_m_fn_mesh.html#a8b9cfa962b307bc28598b6b4885432cc">More...</a><br/></td></tr>
<tr class="separator:a8b9cfa962b307bc28598b6b4885432cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6ac85fc1c06ee8de9e5a9c3a8505fbe2"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a6ac85fc1c06ee8de9e5a9c3a8505fbe2" translate="no">copy</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;source, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a6ac85fc1c06ee8de9e5a9c3a8505fbe2"><td class="mdescLeft"> </td><td class="mdescRight">This method creates a copy of a given source mesh.  <a href="class_m_fn_mesh.html#a6ac85fc1c06ee8de9e5a9c3a8505fbe2">More...</a><br/></td></tr>
<tr class="separator:a6ac85fc1c06ee8de9e5a9c3a8505fbe2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aadc717faffda37e0542fa7aae370905b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aadc717faffda37e0542fa7aae370905b" translate="no">updateSurface</a> ()</td></tr>
<tr class="memdesc:aadc717faffda37e0542fa7aae370905b"><td class="mdescLeft"> </td><td class="mdescRight">Signal that this polygonal mesh has changed and needs to redraw itself.  <a href="class_m_fn_mesh.html#aadc717faffda37e0542fa7aae370905b">More...</a><br/></td></tr>
<tr class="separator:aadc717faffda37e0542fa7aae370905b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e980be04112646bb555d4bb865581e7"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5e980be04112646bb555d4bb865581e7" translate="no">syncObject</a> ()</td></tr>
<tr class="memdesc:a5e980be04112646bb555d4bb865581e7"><td class="mdescLeft"> </td><td class="mdescRight">If a non-api operation happens that many have changed the underlying Maya object wrapped by this api object, make sure that the api object references a valid maya object.  <a href="class_m_fn_mesh.html#a5e980be04112646bb555d4bb865581e7">More...</a><br/></td></tr>
<tr class="separator:a5e980be04112646bb555d4bb865581e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a507441d17b470728c811d7ba8de26e46"><td align="right" class="memItemLeft" translate="no" valign="top">const float * </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a507441d17b470728c811d7ba8de26e46" translate="no">getRawPoints</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *) const </td></tr>
<tr class="memdesc:a507441d17b470728c811d7ba8de26e46"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a pointer to the internal vertex list for this mesh.  <a href="class_m_fn_mesh.html#a507441d17b470728c811d7ba8de26e46">More...</a><br/></td></tr>
<tr class="separator:a507441d17b470728c811d7ba8de26e46"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a331efdb89bf9c388c7825d4a898a4a41"><td align="right" class="memItemLeft" translate="no" valign="top">const double * </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a331efdb89bf9c388c7825d4a898a4a41" translate="no">getRawDoublePoints</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *) const </td></tr>
<tr class="memdesc:a331efdb89bf9c388c7825d4a898a4a41"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a pointer to the internal vertex list for this mesh.  <a href="class_m_fn_mesh.html#a331efdb89bf9c388c7825d4a898a4a41">More...</a><br/></td></tr>
<tr class="separator:a331efdb89bf9c388c7825d4a898a4a41"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a99e9b4072cdbea8e3e350243ca7dd482"><td align="right" class="memItemLeft" translate="no" valign="top">const float * </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a99e9b4072cdbea8e3e350243ca7dd482" translate="no">getRawNormals</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *) const </td></tr>
<tr class="memdesc:a99e9b4072cdbea8e3e350243ca7dd482"><td class="mdescLeft"> </td><td class="mdescRight">This method returns a pointer to the internal normal list for this mesh.  <a href="class_m_fn_mesh.html#a99e9b4072cdbea8e3e350243ca7dd482">More...</a><br/></td></tr>
<tr class="separator:a99e9b4072cdbea8e3e350243ca7dd482"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38510cd198de64ad9308fb265c7e338b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a38510cd198de64ad9308fb265c7e338b" translate="no">getPoints</a> (<a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;vertexArray, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:a38510cd198de64ad9308fb265c7e338b"><td class="mdescLeft"> </td><td class="mdescRight">This method copies the vertex list for this mesh into the given point array.  <a href="class_m_fn_mesh.html#a38510cd198de64ad9308fb265c7e338b">More...</a><br/></td></tr>
<tr class="separator:a38510cd198de64ad9308fb265c7e338b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b3f852a00f3dc096c136cbe04057733"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5b3f852a00f3dc096c136cbe04057733" translate="no">getPoints</a> (<a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:a5b3f852a00f3dc096c136cbe04057733"><td class="mdescLeft"> </td><td class="mdescRight">This method copies the vertex list for this mesh into the given point array.  <a href="class_m_fn_mesh.html#a5b3f852a00f3dc096c136cbe04057733">More...</a><br/></td></tr>
<tr class="separator:a5b3f852a00f3dc096c136cbe04057733"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a739dfbdbe4935389ac2d3e72d8c1f7dd"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a739dfbdbe4935389ac2d3e72d8c1f7dd" translate="no">setPoints</a> (<a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;vertexArray, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>)</td></tr>
<tr class="memdesc:a739dfbdbe4935389ac2d3e72d8c1f7dd"><td class="mdescLeft"> </td><td class="mdescRight">This method copies the points in the given point array to the vertices of this polygon.  <a href="class_m_fn_mesh.html#a739dfbdbe4935389ac2d3e72d8c1f7dd">More...</a><br/></td></tr>
<tr class="separator:a739dfbdbe4935389ac2d3e72d8c1f7dd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9038f53a1929f36f52e3b0e0f4658bfc"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9038f53a1929f36f52e3b0e0f4658bfc" translate="no">setPoints</a> (<a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>)</td></tr>
<tr class="memdesc:a9038f53a1929f36f52e3b0e0f4658bfc"><td class="mdescLeft"> </td><td class="mdescRight">This method copies the points in the given point array to the vertices of this mesh.  <a href="class_m_fn_mesh.html#a9038f53a1929f36f52e3b0e0f4658bfc">More...</a><br/></td></tr>
<tr class="separator:a9038f53a1929f36f52e3b0e0f4658bfc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2f2e041f01dc1ec3648002e2524fbfbc"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2f2e041f01dc1ec3648002e2524fbfbc" translate="no">getVertices</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexCount, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList) const </td></tr>
<tr class="memdesc:a2f2e041f01dc1ec3648002e2524fbfbc"><td class="mdescLeft"> </td><td class="mdescRight">This method retrieves the <b>object-relative (mesh-relative/global)</b> vertex indices for all polygons.  <a href="class_m_fn_mesh.html#a2f2e041f01dc1ec3648002e2524fbfbc">More...</a><br/></td></tr>
<tr class="separator:a2f2e041f01dc1ec3648002e2524fbfbc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a469fc8126bc4424cd00853821d78a55a"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a469fc8126bc4424cd00853821d78a55a" translate="no">getPolygonVertices</a> (int polygonId, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList) const </td></tr>
<tr class="memdesc:a469fc8126bc4424cd00853821d78a55a"><td class="mdescLeft"> </td><td class="mdescRight">This method retrieves the <b>object-relative (mesh-relative/global)</b> vertex indices for the specified polygon.  <a href="class_m_fn_mesh.html#a469fc8126bc4424cd00853821d78a55a">More...</a><br/></td></tr>
<tr class="separator:a469fc8126bc4424cd00853821d78a55a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a78c51f79565ea0c1b4708163322ddcbd"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a78c51f79565ea0c1b4708163322ddcbd" translate="no">getPolygonTriangleVertices</a> (int polygonId, int triangleId, int triangleVertices[3]) const </td></tr>
<tr class="memdesc:a78c51f79565ea0c1b4708163322ddcbd"><td class="mdescLeft"> </td><td class="mdescRight">This method retrieves the <b>object-relative (mesh-relative/global)</b> vertex indices for the specified triangle in the specified polygon.  <a href="class_m_fn_mesh.html#a78c51f79565ea0c1b4708163322ddcbd">More...</a><br/></td></tr>
<tr class="separator:a78c51f79565ea0c1b4708163322ddcbd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a930e585693bbd81b655420c8c0c9a4e5"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a930e585693bbd81b655420c8c0c9a4e5" translate="no">setPoint</a> (int vertexId, const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;pos, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>)</td></tr>
<tr class="memdesc:a930e585693bbd81b655420c8c0c9a4e5"><td class="mdescLeft"> </td><td class="mdescRight">Sets the position of specified vertex in the vertex list for this mesh.  <a href="class_m_fn_mesh.html#a930e585693bbd81b655420c8c0c9a4e5">More...</a><br/></td></tr>
<tr class="separator:a930e585693bbd81b655420c8c0c9a4e5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71f31afb68fa92a69b114dd7f3cb12fa"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a71f31afb68fa92a69b114dd7f3cb12fa" translate="no">getPoint</a> (int vertexId, <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;pos, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:a71f31afb68fa92a69b114dd7f3cb12fa"><td class="mdescLeft"> </td><td class="mdescRight">Get the position of the specified vertex in this mesh's vertex list.  <a href="class_m_fn_mesh.html#a71f31afb68fa92a69b114dd7f3cb12fa">More...</a><br/></td></tr>
<tr class="separator:a71f31afb68fa92a69b114dd7f3cb12fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a638962fd4d516c8b1141be76b7405bc8"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a638962fd4d516c8b1141be76b7405bc8" translate="no">getNormals</a> (<a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;normals, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:a638962fd4d516c8b1141be76b7405bc8"><td class="mdescLeft"> </td><td class="mdescRight">This method copies the normal list for this mesh into the given array.  <a href="class_m_fn_mesh.html#a638962fd4d516c8b1141be76b7405bc8">More...</a><br/></td></tr>
<tr class="separator:a638962fd4d516c8b1141be76b7405bc8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a23f6abaa6b22b7fbd99c4347e87237"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a7a23f6abaa6b22b7fbd99c4347e87237" translate="no">setNormals</a> (<a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;normals, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>)</td></tr>
<tr class="memdesc:a7a23f6abaa6b22b7fbd99c4347e87237"><td class="mdescLeft"> </td><td class="mdescRight">Set the normal array (user normals)  <a href="class_m_fn_mesh.html#a7a23f6abaa6b22b7fbd99c4347e87237">More...</a><br/></td></tr>
<tr class="separator:a7a23f6abaa6b22b7fbd99c4347e87237"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa8cd3b5b04d859a9e04cd5a061e70e2"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#afa8cd3b5b04d859a9e04cd5a061e70e2" translate="no">getFaceVertexNormal</a> (int faceIndex, int vertexIndex, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;normal, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:afa8cd3b5b04d859a9e04cd5a061e70e2"><td class="mdescLeft"> </td><td class="mdescRight">Return a per-vertex-per-face normal for a given face (polygon) and given vertex.  <a href="class_m_fn_mesh.html#afa8cd3b5b04d859a9e04cd5a061e70e2">More...</a><br/></td></tr>
<tr class="separator:afa8cd3b5b04d859a9e04cd5a061e70e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a52b49c9c8acf2474b7b91121d33c3646"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a52b49c9c8acf2474b7b91121d33c3646" translate="no">getFaceVertexNormals</a> (int faceIndex, <a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;normals, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:a52b49c9c8acf2474b7b91121d33c3646"><td class="mdescLeft"> </td><td class="mdescRight">Return all per-vertex-per-face normals for a given face.  <a href="class_m_fn_mesh.html#a52b49c9c8acf2474b7b91121d33c3646">More...</a><br/></td></tr>
<tr class="separator:a52b49c9c8acf2474b7b91121d33c3646"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb31da2fe90056e46874248e8cc74df6"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#abb31da2fe90056e46874248e8cc74df6" translate="no">getNormalIds</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;normalIdCounts, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;normalIds) const </td></tr>
<tr class="memdesc:abb31da2fe90056e46874248e8cc74df6"><td class="mdescLeft"> </td><td class="mdescRight">Return normal indices for all vertices for a all faces.  <a href="class_m_fn_mesh.html#abb31da2fe90056e46874248e8cc74df6">More...</a><br/></td></tr>
<tr class="separator:abb31da2fe90056e46874248e8cc74df6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a46bb663f5ad353fcc5f8064f80a4e471"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a46bb663f5ad353fcc5f8064f80a4e471" translate="no">getFaceNormalIds</a> (int faceIndex, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;normals) const </td></tr>
<tr class="memdesc:a46bb663f5ad353fcc5f8064f80a4e471"><td class="mdescLeft"> </td><td class="mdescRight">Return normal indices for all vertices for a given face.  <a href="class_m_fn_mesh.html#a46bb663f5ad353fcc5f8064f80a4e471">More...</a><br/></td></tr>
<tr class="separator:a46bb663f5ad353fcc5f8064f80a4e471"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8a8b229ef7346eb7d143afb660d1dd61"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8a8b229ef7346eb7d143afb660d1dd61" translate="no">setFaceVertexNormal</a> (<a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;normal, int faceIndex, int vertexIndex, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a8a8b229ef7346eb7d143afb660d1dd61"><td class="mdescLeft"> </td><td class="mdescRight">Set Normal for this face/vertex pair.  <a href="class_m_fn_mesh.html#a8a8b229ef7346eb7d143afb660d1dd61">More...</a><br/></td></tr>
<tr class="separator:a8a8b229ef7346eb7d143afb660d1dd61"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a504bcb234f4f8fe4133c39826258132c"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a504bcb234f4f8fe4133c39826258132c" translate="no">setVertexNormal</a> (<a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;normal, int vertexIndex, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a504bcb234f4f8fe4133c39826258132c"><td class="mdescLeft"> </td><td class="mdescRight">Set Shared Normal for this vertex.  <a href="class_m_fn_mesh.html#a504bcb234f4f8fe4133c39826258132c">More...</a><br/></td></tr>
<tr class="separator:a504bcb234f4f8fe4133c39826258132c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a793dd5effb06ae02dc67312fe03ff147"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a793dd5effb06ae02dc67312fe03ff147" translate="no">setFaceVertexNormals</a> (<a class="el" href="./class_m_vector_array.html" translate="no">MVectorArray</a> &amp;normalArray, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>)</td></tr>
<tr class="memdesc:a793dd5effb06ae02dc67312fe03ff147"><td class="mdescLeft"> </td><td class="mdescRight">Set Normals for the given face/vertex pairs.  <a href="class_m_fn_mesh.html#a793dd5effb06ae02dc67312fe03ff147">More...</a><br/></td></tr>
<tr class="separator:a793dd5effb06ae02dc67312fe03ff147"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae8a691c2b544f265d6d4f4ad7e51d9b1"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ae8a691c2b544f265d6d4f4ad7e51d9b1" translate="no">setVertexNormals</a> (<a class="el" href="./class_m_vector_array.html" translate="no">MVectorArray</a> &amp;normalArray, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>)</td></tr>
<tr class="memdesc:ae8a691c2b544f265d6d4f4ad7e51d9b1"><td class="mdescLeft"> </td><td class="mdescRight">Set Shared Normals for these vertices.  <a href="class_m_fn_mesh.html#ae8a691c2b544f265d6d4f4ad7e51d9b1">More...</a><br/></td></tr>
<tr class="separator:ae8a691c2b544f265d6d4f4ad7e51d9b1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa4040e2d8b5dd180e3a87e39ff70011"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#afa4040e2d8b5dd180e3a87e39ff70011" translate="no">getVertexNormal</a> (int vertexId, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;normal, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:afa4040e2d8b5dd180e3a87e39ff70011"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#afa4040e2d8b5dd180e3a87e39ff70011">More...</a><br/></td></tr>
<tr class="separator:afa4040e2d8b5dd180e3a87e39ff70011"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a432134393a93bf17256582487e13af67"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a432134393a93bf17256582487e13af67" translate="no">getVertexNormal</a> (int vertexId, bool angleWeighted, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;normal, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:a432134393a93bf17256582487e13af67"><td class="mdescLeft"> </td><td class="mdescRight">Return the normal at the given vertex.  <a href="class_m_fn_mesh.html#a432134393a93bf17256582487e13af67">More...</a><br/></td></tr>
<tr class="separator:a432134393a93bf17256582487e13af67"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af50bb0d3219a83cb0ce0fcf713f8b569"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af50bb0d3219a83cb0ce0fcf713f8b569" translate="no">getVertexNormals</a> (bool angleWeighted, <a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;normals, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:af50bb0d3219a83cb0ce0fcf713f8b569"><td class="mdescLeft"> </td><td class="mdescRight">Return all vertex normals.  <a href="class_m_fn_mesh.html#af50bb0d3219a83cb0ce0fcf713f8b569">More...</a><br/></td></tr>
<tr class="separator:af50bb0d3219a83cb0ce0fcf713f8b569"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44aeccc5c93ffd991475c333a2b8e4d7"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a44aeccc5c93ffd991475c333a2b8e4d7" translate="no">getPolygonNormal</a> (int polygonId, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;normal, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>) const </td></tr>
<tr class="memdesc:a44aeccc5c93ffd991475c333a2b8e4d7"><td class="mdescLeft"> </td><td class="mdescRight">Return the normal at the given polygon.  <a href="class_m_fn_mesh.html#a44aeccc5c93ffd991475c333a2b8e4d7">More...</a><br/></td></tr>
<tr class="separator:a44aeccc5c93ffd991475c333a2b8e4d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe13a3760d62c031d662a5761e6e2503"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#afe13a3760d62c031d662a5761e6e2503" translate="no">isNormalLocked</a> (int normalId, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:afe13a3760d62c031d662a5761e6e2503"><td class="mdescLeft"> </td><td class="mdescRight">Test if the normal for a face/vertex pairs is locked (user defined).  <a href="class_m_fn_mesh.html#afe13a3760d62c031d662a5761e6e2503">More...</a><br/></td></tr>
<tr class="separator:afe13a3760d62c031d662a5761e6e2503"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e1135daf5c65996f2849b81f984d455"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5e1135daf5c65996f2849b81f984d455" translate="no">lockVertexNormals</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList)</td></tr>
<tr class="memdesc:a5e1135daf5c65996f2849b81f984d455"><td class="mdescLeft"> </td><td class="mdescRight">Lock Shared Normals for these vertices.  <a href="class_m_fn_mesh.html#a5e1135daf5c65996f2849b81f984d455">More...</a><br/></td></tr>
<tr class="separator:a5e1135daf5c65996f2849b81f984d455"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4614f4ee7780b8d4af2dfa4229cbcc91"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4614f4ee7780b8d4af2dfa4229cbcc91" translate="no">lockFaceVertexNormals</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList)</td></tr>
<tr class="memdesc:a4614f4ee7780b8d4af2dfa4229cbcc91"><td class="mdescLeft"> </td><td class="mdescRight">Lock Normals for these face/vertex pairs.  <a href="class_m_fn_mesh.html#a4614f4ee7780b8d4af2dfa4229cbcc91">More...</a><br/></td></tr>
<tr class="separator:a4614f4ee7780b8d4af2dfa4229cbcc91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36af178d046a0fffc4fbffaba5288251"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a36af178d046a0fffc4fbffaba5288251" translate="no">unlockVertexNormals</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList)</td></tr>
<tr class="memdesc:a36af178d046a0fffc4fbffaba5288251"><td class="mdescLeft"> </td><td class="mdescRight">Unlock Shared Normals for these vertices.  <a href="class_m_fn_mesh.html#a36af178d046a0fffc4fbffaba5288251">More...</a><br/></td></tr>
<tr class="separator:a36af178d046a0fffc4fbffaba5288251"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1fa6951580cf45b1056fc54788652a96"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a1fa6951580cf45b1056fc54788652a96" translate="no">unlockFaceVertexNormals</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList)</td></tr>
<tr class="memdesc:a1fa6951580cf45b1056fc54788652a96"><td class="mdescLeft"> </td><td class="mdescRight">Unlock Normals for these face/vertex pairs.  <a href="class_m_fn_mesh.html#a1fa6951580cf45b1056fc54788652a96">More...</a><br/></td></tr>
<tr class="separator:a1fa6951580cf45b1056fc54788652a96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5af3ac4777497a0d4d286c8f140ad2f3"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5af3ac4777497a0d4d286c8f140ad2f3" translate="no">getTangentId</a> (int faceIndex, int vertexIndex, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a5af3ac4777497a0d4d286c8f140ad2f3"><td class="mdescLeft"> </td><td class="mdescRight">Return the tangent index for a given face vertex.  <a href="class_m_fn_mesh.html#a5af3ac4777497a0d4d286c8f140ad2f3">More...</a><br/></td></tr>
<tr class="separator:a5af3ac4777497a0d4d286c8f140ad2f3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abd8b829f396f2cb6bc039dc61ca9b770"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#abd8b829f396f2cb6bc039dc61ca9b770" translate="no">getTangents</a> (<a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;normals, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:abd8b829f396f2cb6bc039dc61ca9b770"><td class="mdescLeft"> </td><td class="mdescRight">Return the tangent vectors for all face vertices.  <a href="class_m_fn_mesh.html#abd8b829f396f2cb6bc039dc61ca9b770">More...</a><br/></td></tr>
<tr class="separator:abd8b829f396f2cb6bc039dc61ca9b770"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4846835bd50ab9b9ebcaa0e39fca7100"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4846835bd50ab9b9ebcaa0e39fca7100" translate="no">getFaceVertexTangent</a> (int faceIndex, int vertexIndex, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;tangent, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a4846835bd50ab9b9ebcaa0e39fca7100"><td class="mdescLeft"> </td><td class="mdescRight">Return the normalized tangent vector at a given face vertex.  <a href="class_m_fn_mesh.html#a4846835bd50ab9b9ebcaa0e39fca7100">More...</a><br/></td></tr>
<tr class="separator:a4846835bd50ab9b9ebcaa0e39fca7100"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5cd47815e91c12f172579e74ea5b4ecb"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5cd47815e91c12f172579e74ea5b4ecb" translate="no">getFaceVertexTangents</a> (int faceIndex, <a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;tangents, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a5cd47815e91c12f172579e74ea5b4ecb"><td class="mdescLeft"> </td><td class="mdescRight">Return all per-vertex-per-face tangents for a given face.  <a href="class_m_fn_mesh.html#a5cd47815e91c12f172579e74ea5b4ecb">More...</a><br/></td></tr>
<tr class="separator:a5cd47815e91c12f172579e74ea5b4ecb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a761e3f3f6d2b7015ea32affb71b7a0ad"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a761e3f3f6d2b7015ea32affb71b7a0ad" translate="no">getBinormals</a> (<a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;normals, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a761e3f3f6d2b7015ea32affb71b7a0ad"><td class="mdescLeft"> </td><td class="mdescRight">Return the binormal vectors for all face vertices.  <a href="class_m_fn_mesh.html#a761e3f3f6d2b7015ea32affb71b7a0ad">More...</a><br/></td></tr>
<tr class="separator:a761e3f3f6d2b7015ea32affb71b7a0ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b6701cf574eed8602a6797687c4f77b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4b6701cf574eed8602a6797687c4f77b" translate="no">getFaceVertexBinormal</a> (int faceIndex, int vertexIndex, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;normal, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a4b6701cf574eed8602a6797687c4f77b"><td class="mdescLeft"> </td><td class="mdescRight">Return the binormal vector at a given face vertex.  <a href="class_m_fn_mesh.html#a4b6701cf574eed8602a6797687c4f77b">More...</a><br/></td></tr>
<tr class="separator:a4b6701cf574eed8602a6797687c4f77b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae77bd36d18964cb1df36e1d000f180d3"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ae77bd36d18964cb1df36e1d000f180d3" translate="no">getFaceVertexBinormals</a> (int faceIndex, <a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;normals, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:ae77bd36d18964cb1df36e1d000f180d3"><td class="mdescLeft"> </td><td class="mdescRight">Return all per-vertex-per-face binormals for a given face.  <a href="class_m_fn_mesh.html#ae77bd36d18964cb1df36e1d000f180d3">More...</a><br/></td></tr>
<tr class="separator:ae77bd36d18964cb1df36e1d000f180d3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a641e327847996b0ca10de74960120270"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a641e327847996b0ca10de74960120270" translate="no">isRightHandedTangent</a> (int tangentId, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSetName=NULL, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a641e327847996b0ca10de74960120270"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if the normal, tangent and binormal form a right handed coordinate system.  <a href="class_m_fn_mesh.html#a641e327847996b0ca10de74960120270">More...</a><br/></td></tr>
<tr class="separator:a641e327847996b0ca10de74960120270"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae1a3e896586efddb2cc39fbbb023d1e2"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ae1a3e896586efddb2cc39fbbb023d1e2" translate="no">isPolygonConvex</a> (int faceIndex, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ae1a3e896586efddb2cc39fbbb023d1e2"><td class="mdescLeft"> </td><td class="mdescRight">This method determines if the specified polygon is convex.  <a href="class_m_fn_mesh.html#ae1a3e896586efddb2cc39fbbb023d1e2">More...</a><br/></td></tr>
<tr class="separator:ae1a3e896586efddb2cc39fbbb023d1e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a603d73f3637830a372ab3678d24ca6e6"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a603d73f3637830a372ab3678d24ca6e6" translate="no">getEdgeVertices</a> (int edgeId, int2 &amp;vertexList) const </td></tr>
<tr class="memdesc:a603d73f3637830a372ab3678d24ca6e6"><td class="mdescLeft"> </td><td class="mdescRight">This method retrieves the <b>object-relative (mesh-relative/global)</b> vertex indices corresponding to the specified edge.  <a href="class_m_fn_mesh.html#a603d73f3637830a372ab3678d24ca6e6">More...</a><br/></td></tr>
<tr class="separator:a603d73f3637830a372ab3678d24ca6e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa99b5c573c92207e190bfa0cd03bf99f"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa99b5c573c92207e190bfa0cd03bf99f" translate="no">isEdgeSmooth</a> (int edgeId, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aa99b5c573c92207e190bfa0cd03bf99f"><td class="mdescLeft"> </td><td class="mdescRight">This method determines if the specified edge is smooth (soft).  <a href="class_m_fn_mesh.html#aa99b5c573c92207e190bfa0cd03bf99f">More...</a><br/></td></tr>
<tr class="separator:aa99b5c573c92207e190bfa0cd03bf99f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a31c12a350511130133555671ce7bfbff"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a31c12a350511130133555671ce7bfbff" translate="no">setEdgeSmoothing</a> (int edgeId, bool smooth=true)</td></tr>
<tr class="memdesc:a31c12a350511130133555671ce7bfbff"><td class="mdescLeft"> </td><td class="mdescRight">This method sets the specified edge to be hard or smooth (soft).  <a href="class_m_fn_mesh.html#a31c12a350511130133555671ce7bfbff">More...</a><br/></td></tr>
<tr class="separator:a31c12a350511130133555671ce7bfbff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad824622a3309e93dc8771da755531deb"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad824622a3309e93dc8771da755531deb" translate="no">setEdgeSmoothings</a> (const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;edgeIds, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;smooths)</td></tr>
<tr class="memdesc:ad824622a3309e93dc8771da755531deb"><td class="mdescLeft"> </td><td class="mdescRight">This method sets the specified edges to be hard or smooth (soft).  <a href="class_m_fn_mesh.html#ad824622a3309e93dc8771da755531deb">More...</a><br/></td></tr>
<tr class="separator:ad824622a3309e93dc8771da755531deb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab9e439ab36a41ba3a19c2c32faa7fe1"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aab9e439ab36a41ba3a19c2c32faa7fe1" translate="no">cleanupEdgeSmoothing</a> ()</td></tr>
<tr class="memdesc:aab9e439ab36a41ba3a19c2c32faa7fe1"><td class="mdescLeft"> </td><td class="mdescRight">This method updates the mesh after setEdgeSmoothing has been done.  <a href="class_m_fn_mesh.html#aab9e439ab36a41ba3a19c2c32faa7fe1">More...</a><br/></td></tr>
<tr class="separator:aab9e439ab36a41ba3a19c2c32faa7fe1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c7b7ddaccaf7c04d39cc1b58b99fa0b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9c7b7ddaccaf7c04d39cc1b58b99fa0b" translate="no">getCreaseEdges</a> (<a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp;edgeIds, <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;creaseData) const </td></tr>
<tr class="memdesc:a9c7b7ddaccaf7c04d39cc1b58b99fa0b"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the crease edges of the mesh, and also the crease data associated with those edges.  <a href="class_m_fn_mesh.html#a9c7b7ddaccaf7c04d39cc1b58b99fa0b">More...</a><br/></td></tr>
<tr class="separator:a9c7b7ddaccaf7c04d39cc1b58b99fa0b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a62355f26f350f9725bccd7eaa7542df3"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a62355f26f350f9725bccd7eaa7542df3" translate="no">setCreaseEdges</a> (const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp;edgeIds, const <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;creaseData)</td></tr>
<tr class="memdesc:a62355f26f350f9725bccd7eaa7542df3"><td class="mdescLeft"> </td><td class="mdescRight">This method sets the specified edges of the mesh as crease edges.  <a href="class_m_fn_mesh.html#a62355f26f350f9725bccd7eaa7542df3">More...</a><br/></td></tr>
<tr class="separator:a62355f26f350f9725bccd7eaa7542df3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a465a9efe9747fcb28f38a43bb0b9cac5"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a465a9efe9747fcb28f38a43bb0b9cac5" translate="no">getInvisibleFaces</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a465a9efe9747fcb28f38a43bb0b9cac5"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the invisible faces of the mesh.  <a href="class_m_fn_mesh.html#a465a9efe9747fcb28f38a43bb0b9cac5">More...</a><br/></td></tr>
<tr class="separator:a465a9efe9747fcb28f38a43bb0b9cac5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5be791c0049247ab13e27cdffff5185a"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5be791c0049247ab13e27cdffff5185a" translate="no">setInvisibleFaces</a> (const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp;faceIds, bool makeVisible=false)</td></tr>
<tr class="memdesc:a5be791c0049247ab13e27cdffff5185a"><td class="mdescLeft"> </td><td class="mdescRight">This method sets the specified faces of the mesh to be visible or invisible.  <a href="class_m_fn_mesh.html#a5be791c0049247ab13e27cdffff5185a">More...</a><br/></td></tr>
<tr class="separator:a5be791c0049247ab13e27cdffff5185a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5714478da8dee923b4a3a045818c6240"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5714478da8dee923b4a3a045818c6240" translate="no">getCreaseVertices</a> (<a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp;vertexIds, <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;creaseData) const </td></tr>
<tr class="memdesc:a5714478da8dee923b4a3a045818c6240"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the crease vertices of the mesh, and also the crease data associated with those vertices.  <a href="class_m_fn_mesh.html#a5714478da8dee923b4a3a045818c6240">More...</a><br/></td></tr>
<tr class="separator:a5714478da8dee923b4a3a045818c6240"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a34be7d28408b76c1011d4122a90786ff"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a34be7d28408b76c1011d4122a90786ff" translate="no">setCreaseVertices</a> (const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp;vertexIds, const <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;creaseData)</td></tr>
<tr class="memdesc:a34be7d28408b76c1011d4122a90786ff"><td class="mdescLeft"> </td><td class="mdescRight">This method sets the specified vertices of the mesh as crease vertices.  <a href="class_m_fn_mesh.html#a34be7d28408b76c1011d4122a90786ff">More...</a><br/></td></tr>
<tr class="separator:a34be7d28408b76c1011d4122a90786ff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa8c2d263dfbaa7a187f5db2c3edd565d"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa8c2d263dfbaa7a187f5db2c3edd565d" translate="no">numUVSets</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aa8c2d263dfbaa7a187f5db2c3edd565d"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of uv sets for an object.  <a href="class_m_fn_mesh.html#aa8c2d263dfbaa7a187f5db2c3edd565d">More...</a><br/></td></tr>
<tr class="separator:aa8c2d263dfbaa7a187f5db2c3edd565d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a932b175b29c42758fe67761fca275c61"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a932b175b29c42758fe67761fca275c61" translate="no">createUVSetWithName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;uvSetName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL, const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> *instances=NULL)</td></tr>
<tr class="memdesc:a932b175b29c42758fe67761fca275c61"><td class="mdescLeft"> </td><td class="mdescRight">Create a new empty uv set for this mesh.  <a href="class_m_fn_mesh.html#a932b175b29c42758fe67761fca275c61">More...</a><br/></td></tr>
<tr class="separator:a932b175b29c42758fe67761fca275c61"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a87e9c26e64ac650050d9ab32c7136e10"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a87e9c26e64ac650050d9ab32c7136e10" translate="no">copyUVSetWithName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;fromName, const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;toName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a87e9c26e64ac650050d9ab32c7136e10"><td class="mdescLeft"> </td><td class="mdescRight">Copies a uv set from one to another for this mesh.  <a href="class_m_fn_mesh.html#a87e9c26e64ac650050d9ab32c7136e10">More...</a><br/></td></tr>
<tr class="separator:a87e9c26e64ac650050d9ab32c7136e10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4aa4f41f3117c9502db9b54fb6519a7f"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4aa4f41f3117c9502db9b54fb6519a7f" translate="no">renameUVSet</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;origName, const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;newName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a4aa4f41f3117c9502db9b54fb6519a7f"><td class="mdescLeft"> </td><td class="mdescRight">Renames a uv set from one name to another for this mesh.  <a href="class_m_fn_mesh.html#a4aa4f41f3117c9502db9b54fb6519a7f">More...</a><br/></td></tr>
<tr class="separator:a4aa4f41f3117c9502db9b54fb6519a7f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0b2cb7f416bf34a302016ec90610325d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a0b2cb7f416bf34a302016ec90610325d" translate="no">deleteUVSet</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a386bb83443e16a98e6fa10c683e76b6c" translate="no">setName</a>, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, <a class="el" href="./class_m_selection_list.html" translate="no">MSelectionList</a> *currentSelection=NULL)</td></tr>
<tr class="memdesc:a0b2cb7f416bf34a302016ec90610325d"><td class="mdescLeft"> </td><td class="mdescRight">Deletes a named uv set from the object.  <a href="class_m_fn_mesh.html#a0b2cb7f416bf34a302016ec90610325d">More...</a><br/></td></tr>
<tr class="separator:a0b2cb7f416bf34a302016ec90610325d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a880eb944dc60e145d27dad4468c9fd11"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a880eb944dc60e145d27dad4468c9fd11" translate="no">setCurrentUVSetName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a386bb83443e16a98e6fa10c683e76b6c" translate="no">setName</a>, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, <a class="el" href="./class_m_selection_list.html" translate="no">MSelectionList</a> *currentSelection=NULL)</td></tr>
<tr class="memdesc:a880eb944dc60e145d27dad4468c9fd11"><td class="mdescLeft"> </td><td class="mdescRight">Set the "current" uv set for this object.  <a href="class_m_fn_mesh.html#a880eb944dc60e145d27dad4468c9fd11">More...</a><br/></td></tr>
<tr class="separator:a880eb944dc60e145d27dad4468c9fd11"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a63648568635afc4b0935ee0c4d712565"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a63648568635afc4b0935ee0c4d712565" translate="no">currentUVSetName</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL, int instance=kMFnMeshInstanceUnspecified) const </td></tr>
<tr class="memdesc:a63648568635afc4b0935ee0c4d712565"><td class="mdescLeft"> </td><td class="mdescRight">Get the name of the "current" uv set.  <a href="class_m_fn_mesh.html#a63648568635afc4b0935ee0c4d712565">More...</a><br/></td></tr>
<tr class="separator:a63648568635afc4b0935ee0c4d712565"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2f32f69a6f2b124ac085df4b067c76de"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2f32f69a6f2b124ac085df4b067c76de" translate="no">getUVSetNames</a> (<a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;setNames) const </td></tr>
<tr class="memdesc:a2f32f69a6f2b124ac085df4b067c76de"><td class="mdescLeft"> </td><td class="mdescRight">Get the names of all of the uv sets on this object.  <a href="class_m_fn_mesh.html#a2f32f69a6f2b124ac085df4b067c76de">More...</a><br/></td></tr>
<tr class="separator:a2f32f69a6f2b124ac085df4b067c76de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3abce34eedcd859ac99cd248a40d8fa6"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a3abce34eedcd859ac99cd248a40d8fa6" translate="no">getUVSetFamilyNames</a> (<a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;familyNames) const </td></tr>
<tr class="memdesc:a3abce34eedcd859ac99cd248a40d8fa6"><td class="mdescLeft"> </td><td class="mdescRight">Get the names of all of the uv set families on this object.  <a href="class_m_fn_mesh.html#a3abce34eedcd859ac99cd248a40d8fa6">More...</a><br/></td></tr>
<tr class="separator:a3abce34eedcd859ac99cd248a40d8fa6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb8b2d8dd14a0820c822db9269d441de"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#abb8b2d8dd14a0820c822db9269d441de" translate="no">getUVSetsInFamily</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;familyName, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;setNames) const </td></tr>
<tr class="memdesc:abb8b2d8dd14a0820c822db9269d441de"><td class="mdescLeft"> </td><td class="mdescRight">Get the names of the uv sets that belong to this set family.  <a href="class_m_fn_mesh.html#abb8b2d8dd14a0820c822db9269d441de">More...</a><br/></td></tr>
<tr class="separator:abb8b2d8dd14a0820c822db9269d441de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec1c28ba99ebf1d17834e650a96aa91e"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aec1c28ba99ebf1d17834e650a96aa91e" translate="no">isUVSetPerInstance</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aec1c28ba99ebf1d17834e650a96aa91e"><td class="mdescLeft"> </td><td class="mdescRight">Return true if this set is per-instance, and false if it is shared across all instances.  <a href="class_m_fn_mesh.html#aec1c28ba99ebf1d17834e650a96aa91e">More...</a><br/></td></tr>
<tr class="separator:aec1c28ba99ebf1d17834e650a96aa91e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21697109f56b5742839159b620d8f4a9"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a21697109f56b5742839159b620d8f4a9" translate="no">getFaceUVSetNames</a> (int polygonId, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;setNames) const </td></tr>
<tr class="memdesc:a21697109f56b5742839159b620d8f4a9"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the list of UV sets mapped to a face.  <a href="class_m_fn_mesh.html#a21697109f56b5742839159b620d8f4a9">More...</a><br/></td></tr>
<tr class="separator:a21697109f56b5742839159b620d8f4a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a014536ed1d56dec2e5ac51bd8b3aa36d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a014536ed1d56dec2e5ac51bd8b3aa36d" translate="no">getAssociatedUVSetTextures</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> uvSetName, <a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp;textures) const </td></tr>
<tr class="memdesc:a014536ed1d56dec2e5ac51bd8b3aa36d"><td class="mdescLeft"> </td><td class="mdescRight">Get a list of texture nodes which are using a given uv set.  <a href="class_m_fn_mesh.html#a014536ed1d56dec2e5ac51bd8b3aa36d">More...</a><br/></td></tr>
<tr class="separator:a014536ed1d56dec2e5ac51bd8b3aa36d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a6473501431b311db95490e9759318b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a6a6473501431b311db95490e9759318b" translate="no">getAssociatedUVSetInstances</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;uvSetName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;instances) const </td></tr>
<tr class="memdesc:a6a6473501431b311db95490e9759318b"><td class="mdescLeft"> </td><td class="mdescRight">Get a list of the instance numbers associated with this uv map.  <a href="class_m_fn_mesh.html#a6a6473501431b311db95490e9759318b">More...</a><br/></td></tr>
<tr class="separator:a6a6473501431b311db95490e9759318b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a51bf5200523771e59ec4bf4c6bfdd0bc"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a51bf5200523771e59ec4bf4c6bfdd0bc" translate="no">setUVs</a> (const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;uArray, const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;vArray, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL)</td></tr>
<tr class="memdesc:a51bf5200523771e59ec4bf4c6bfdd0bc"><td class="mdescLeft"> </td><td class="mdescRight">Sets all of the texture coordinates (uv's) for this mesh.  <a href="class_m_fn_mesh.html#a51bf5200523771e59ec4bf4c6bfdd0bc">More...</a><br/></td></tr>
<tr class="separator:a51bf5200523771e59ec4bf4c6bfdd0bc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aac82902d0da7b2d1addf6b01a71f7d2d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aac82902d0da7b2d1addf6b01a71f7d2d" translate="no">setSomeUVs</a> (const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;uvIds, const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;uArray, const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;vArray, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL)</td></tr>
<tr class="memdesc:aac82902d0da7b2d1addf6b01a71f7d2d"><td class="mdescLeft"> </td><td class="mdescRight">Sets the specified texture coordinates (UV's) for this mesh.  <a href="class_m_fn_mesh.html#aac82902d0da7b2d1addf6b01a71f7d2d">More...</a><br/></td></tr>
<tr class="separator:aac82902d0da7b2d1addf6b01a71f7d2d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa41349e47d082451f1744cff85412159"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa41349e47d082451f1744cff85412159" translate="no">getUVs</a> (<a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;uArray, <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;vArray, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:aa41349e47d082451f1744cff85412159"><td class="mdescLeft"> </td><td class="mdescRight">This method copies the texture coordinate list for this mesh into the given uv arrays.  <a href="class_m_fn_mesh.html#aa41349e47d082451f1744cff85412159">More...</a><br/></td></tr>
<tr class="separator:aa41349e47d082451f1744cff85412159"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe8bc4718af88a29cca9ca0729c8395a"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#afe8bc4718af88a29cca9ca0729c8395a" translate="no">setUV</a> (int uvId, float u, float v, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL)</td></tr>
<tr class="memdesc:afe8bc4718af88a29cca9ca0729c8395a"><td class="mdescLeft"> </td><td class="mdescRight">Sets the specified texture coordinate.  <a href="class_m_fn_mesh.html#afe8bc4718af88a29cca9ca0729c8395a">More...</a><br/></td></tr>
<tr class="separator:afe8bc4718af88a29cca9ca0729c8395a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acca758d84edf1ddc2af1177c4a6ffc2f"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#acca758d84edf1ddc2af1177c4a6ffc2f" translate="no">getUV</a> (int uvId, float &amp;u, float &amp;v, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:acca758d84edf1ddc2af1177c4a6ffc2f"><td class="mdescLeft"> </td><td class="mdescRight">Get the value of the specified texture coordinate from this mesh's uv list.  <a href="class_m_fn_mesh.html#acca758d84edf1ddc2af1177c4a6ffc2f">More...</a><br/></td></tr>
<tr class="separator:acca758d84edf1ddc2af1177c4a6ffc2f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a111f9eefcd42b1f317d75b96fc96384a"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a111f9eefcd42b1f317d75b96fc96384a" translate="no">getPointAtUV</a> (int polygonId, <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;theClosestPoint, float2 &amp;uvPoint, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL, float tolerance=0.0)</td></tr>
<tr class="memdesc:a111f9eefcd42b1f317d75b96fc96384a"><td class="mdescLeft"> </td><td class="mdescRight">Return the position of the point at the given UV value in the current polygon.  <a href="class_m_fn_mesh.html#a111f9eefcd42b1f317d75b96fc96384a">More...</a><br/></td></tr>
<tr class="separator:a111f9eefcd42b1f317d75b96fc96384a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a299ae5b36f31f846e0cdde655b21988a"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a299ae5b36f31f846e0cdde655b21988a" translate="no">getPointsAtUV</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonIds, <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;points, const float2 &amp;uvPoint, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL, float tolerance=0.0) const </td></tr>
<tr class="memdesc:a299ae5b36f31f846e0cdde655b21988a"><td class="mdescLeft"> </td><td class="mdescRight">Return the positions of the points at the given UV value on the mesh.  <a href="class_m_fn_mesh.html#a299ae5b36f31f846e0cdde655b21988a">More...</a><br/></td></tr>
<tr class="separator:a299ae5b36f31f846e0cdde655b21988a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae28d849f5c29b8ccf09aa3800ba3a16c"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ae28d849f5c29b8ccf09aa3800ba3a16c" translate="no">getUVAtPoint</a> (<a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;pt, float2 &amp;uvPoint, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL, int *closestPolygon=NULL)</td></tr>
<tr class="memdesc:ae28d849f5c29b8ccf09aa3800ba3a16c"><td class="mdescLeft"> </td><td class="mdescRight">Find the point closest to the given point, and return the UV value at that point.  <a href="class_m_fn_mesh.html#ae28d849f5c29b8ccf09aa3800ba3a16c">More...</a><br/></td></tr>
<tr class="separator:ae28d849f5c29b8ccf09aa3800ba3a16c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ace39300b2f541b8928bbad517b5bfbd1"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ace39300b2f541b8928bbad517b5bfbd1" translate="no">getAxisAtPoint</a> (<a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;pt, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;normal, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;uTangent, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;vTangent, <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> space=<a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL, int *closestPolygon=NULL)</td></tr>
<tr class="memdesc:ace39300b2f541b8928bbad517b5bfbd1"><td class="mdescLeft"> </td><td class="mdescRight">Find the point on the mesh which is closest to the given point, and return the axis at that point.  <a href="class_m_fn_mesh.html#ace39300b2f541b8928bbad517b5bfbd1">More...</a><br/></td></tr>
<tr class="separator:ace39300b2f541b8928bbad517b5bfbd1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae1e08bf33700cb15fd273d66063643ef"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ae1e08bf33700cb15fd273d66063643ef" translate="no">getPolygonUV</a> (int polygonId, int vertexIndex, float &amp;u, float &amp;v, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:ae1e08bf33700cb15fd273d66063643ef"><td class="mdescLeft"> </td><td class="mdescRight">Get the value of the specified texture coordinate for a vertex in a polygon.  <a href="class_m_fn_mesh.html#ae1e08bf33700cb15fd273d66063643ef">More...</a><br/></td></tr>
<tr class="separator:ae1e08bf33700cb15fd273d66063643ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d2b8c1536e8f4ec330ff9d83661f9bd"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a1d2b8c1536e8f4ec330ff9d83661f9bd" translate="no">getPolygonUVid</a> (int polygonId, int vertexIndex, int &amp;uvId, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a1d2b8c1536e8f4ec330ff9d83661f9bd"><td class="mdescLeft"> </td><td class="mdescRight">Get the id of the specified texture coordinate for a vertex in a polygon.  <a href="class_m_fn_mesh.html#a1d2b8c1536e8f4ec330ff9d83661f9bd">More...</a><br/></td></tr>
<tr class="separator:a1d2b8c1536e8f4ec330ff9d83661f9bd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa8f5741f8b319715af87211e8274ea79"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa8f5741f8b319715af87211e8274ea79" translate="no">assignUV</a> (int polygonId, int vertexIndex, int uvId, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL)</td></tr>
<tr class="memdesc:aa8f5741f8b319715af87211e8274ea79"><td class="mdescLeft"> </td><td class="mdescRight">Maps a texture coordinate to a specified vertex of a polygon.  <a href="class_m_fn_mesh.html#aa8f5741f8b319715af87211e8274ea79">More...</a><br/></td></tr>
<tr class="separator:aa8f5741f8b319715af87211e8274ea79"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aecf710967d185b161c044dd95c04345b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aecf710967d185b161c044dd95c04345b" translate="no">assignUVs</a> (const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;uvCounts, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;uvIds, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL)</td></tr>
<tr class="memdesc:aecf710967d185b161c044dd95c04345b"><td class="mdescLeft"> </td><td class="mdescRight">This method maps all texture coordinates for the mesh.  <a href="class_m_fn_mesh.html#aecf710967d185b161c044dd95c04345b">More...</a><br/></td></tr>
<tr class="separator:aecf710967d185b161c044dd95c04345b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a642e3c0881f698c1a7c1ca93f0085d3b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a642e3c0881f698c1a7c1ca93f0085d3b" translate="no">clearUVs</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL)</td></tr>
<tr class="memdesc:a642e3c0881f698c1a7c1ca93f0085d3b"><td class="mdescLeft"> </td><td class="mdescRight">This method clears out all texture coordinates for the mesh, and leaves behind an empty UVset.  <a href="class_m_fn_mesh.html#a642e3c0881f698c1a7c1ca93f0085d3b">More...</a><br/></td></tr>
<tr class="separator:a642e3c0881f698c1a7c1ca93f0085d3b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abe6b4afaec85f867401eb3658c3e5459"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#abe6b4afaec85f867401eb3658c3e5459" translate="no">getAssignedUVs</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;uvCounts, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;uvIds, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:abe6b4afaec85f867401eb3658c3e5459"><td class="mdescLeft"> </td><td class="mdescRight">Get assigned UVs.  <a href="class_m_fn_mesh.html#abe6b4afaec85f867401eb3658c3e5459">More...</a><br/></td></tr>
<tr class="separator:abe6b4afaec85f867401eb3658c3e5459"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2261151d90491f3cef9ae854972798b4"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2261151d90491f3cef9ae854972798b4" translate="no">getUvShellsIds</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;uvShellIds, unsigned int &amp;nbUvShells, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a2261151d90491f3cef9ae854972798b4"><td class="mdescLeft"> </td><td class="mdescRight">Constructs an array of unique integer for each UV shell.  <a href="class_m_fn_mesh.html#a2261151d90491f3cef9ae854972798b4">More...</a><br/></td></tr>
<tr class="separator:a2261151d90491f3cef9ae854972798b4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d819fc02dc71cf37f5aa45db4f7df69"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9d819fc02dc71cf37f5aa45db4f7df69" translate="no">getPinUVs</a> (<a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp;pinIds, <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;pinData, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL) const </td></tr>
<tr class="memdesc:a9d819fc02dc71cf37f5aa45db4f7df69"><td class="mdescLeft"> </td><td class="mdescRight">This method returns the pin uvs of the mesh, and also the pin data associated with those uvs.  <a href="class_m_fn_mesh.html#a9d819fc02dc71cf37f5aa45db4f7df69">More...</a><br/></td></tr>
<tr class="separator:a9d819fc02dc71cf37f5aa45db4f7df69"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a696b96be712e4cd8c8b383c6ce3a6f94"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a696b96be712e4cd8c8b383c6ce3a6f94" translate="no">setPinUVs</a> (const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp;pinIds, const <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;pinData, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL)</td></tr>
<tr class="memdesc:a696b96be712e4cd8c8b383c6ce3a6f94"><td class="mdescLeft"> </td><td class="mdescRight">This method sets the specified uvs of the mesh as "pinned" uvs, a "pinned" uv is one which should not be modified.  <a href="class_m_fn_mesh.html#a696b96be712e4cd8c8b383c6ce3a6f94">More...</a><br/></td></tr>
<tr class="separator:a696b96be712e4cd8c8b383c6ce3a6f94"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8260a31521263408c478daf5eaffc881"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8260a31521263408c478daf5eaffc881" translate="no">isPolygonUVReversed</a> (int polygonId, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *uvSet=NULL, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a8260a31521263408c478daf5eaffc881"><td class="mdescLeft"> </td><td class="mdescRight">This method determines if the winding order of texture coordinates (uv's) for specified polygon are reversed (clockwise)  <a href="class_m_fn_mesh.html#a8260a31521263408c478daf5eaffc881">More...</a><br/></td></tr>
<tr class="separator:a8260a31521263408c478daf5eaffc881"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac82916690bb9966bdc05d342bb48cc08"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ac82916690bb9966bdc05d342bb48cc08" translate="no">numColorSets</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ac82916690bb9966bdc05d342bb48cc08"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of color sets for an object.  <a href="class_m_fn_mesh.html#ac82916690bb9966bdc05d342bb48cc08">More...</a><br/></td></tr>
<tr class="separator:ac82916690bb9966bdc05d342bb48cc08"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac392a4fcb7da0759a4301119a395bcd7"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ac392a4fcb7da0759a4301119a395bcd7" translate="no">createColorSetWithName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSetName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> *instances=NULL, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ac392a4fcb7da0759a4301119a395bcd7"><td class="mdescLeft"> </td><td class="mdescRight">Create a new empty color set for this mesh.  <a href="class_m_fn_mesh.html#ac392a4fcb7da0759a4301119a395bcd7">More...</a><br/></td></tr>
<tr class="separator:ac392a4fcb7da0759a4301119a395bcd7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acbcb4e7049e79e14b523a8edfb5b4d42"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#acbcb4e7049e79e14b523a8edfb5b4d42" translate="no">deleteColorSet</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSetName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, <a class="el" href="./class_m_selection_list.html" translate="no">MSelectionList</a> *currentSelection=NULL)</td></tr>
<tr class="memdesc:acbcb4e7049e79e14b523a8edfb5b4d42"><td class="mdescLeft"> </td><td class="mdescRight">Deletes a named color set from the object.  <a href="class_m_fn_mesh.html#acbcb4e7049e79e14b523a8edfb5b4d42">More...</a><br/></td></tr>
<tr class="separator:acbcb4e7049e79e14b523a8edfb5b4d42"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae4acd6b84edaab8e7b6234db0337021b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ae4acd6b84edaab8e7b6234db0337021b" translate="no">setCurrentColorSetName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a386bb83443e16a98e6fa10c683e76b6c" translate="no">setName</a>, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, <a class="el" href="./class_m_selection_list.html" translate="no">MSelectionList</a> *currentSelection=NULL)</td></tr>
<tr class="memdesc:ae4acd6b84edaab8e7b6234db0337021b"><td class="mdescLeft"> </td><td class="mdescRight">Set the "current" or "working" color set for this object.  <a href="class_m_fn_mesh.html#ae4acd6b84edaab8e7b6234db0337021b">More...</a><br/></td></tr>
<tr class="separator:ae4acd6b84edaab8e7b6234db0337021b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a05a2db74b6cfc632c605cbac1363eb99"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a05a2db74b6cfc632c605cbac1363eb99" translate="no">currentColorSetName</a> (int instance=kMFnMeshInstanceUnspecified, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a05a2db74b6cfc632c605cbac1363eb99"><td class="mdescLeft"> </td><td class="mdescRight">Get the name of the "current" or "working" color set.  <a href="class_m_fn_mesh.html#a05a2db74b6cfc632c605cbac1363eb99">More...</a><br/></td></tr>
<tr class="separator:a05a2db74b6cfc632c605cbac1363eb99"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa5f322f25f97f76df932054bf5847c8e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa5f322f25f97f76df932054bf5847c8e" translate="no">getColorSetNames</a> (<a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;setNames) const </td></tr>
<tr class="memdesc:aa5f322f25f97f76df932054bf5847c8e"><td class="mdescLeft"> </td><td class="mdescRight">Get the names of all of the colors sets on this object.  <a href="class_m_fn_mesh.html#aa5f322f25f97f76df932054bf5847c8e">More...</a><br/></td></tr>
<tr class="separator:aa5f322f25f97f76df932054bf5847c8e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9900f1475febb7c47b7a1a435951632f"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9900f1475febb7c47b7a1a435951632f" translate="no">getColorSetFamilyNames</a> (<a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;familyNames) const </td></tr>
<tr class="memdesc:a9900f1475febb7c47b7a1a435951632f"><td class="mdescLeft"> </td><td class="mdescRight">Get the names of all of the color set families on this object.  <a href="class_m_fn_mesh.html#a9900f1475febb7c47b7a1a435951632f">More...</a><br/></td></tr>
<tr class="separator:a9900f1475febb7c47b7a1a435951632f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad955599df74aa3caffcaedda6920ebf4"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad955599df74aa3caffcaedda6920ebf4" translate="no">getColorSetsInFamily</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;familyName, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;setNames) const </td></tr>
<tr class="memdesc:ad955599df74aa3caffcaedda6920ebf4"><td class="mdescLeft"> </td><td class="mdescRight">Get the names of the color sets that belong to this set family.  <a href="class_m_fn_mesh.html#ad955599df74aa3caffcaedda6920ebf4">More...</a><br/></td></tr>
<tr class="separator:ad955599df74aa3caffcaedda6920ebf4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a41682009252ece153547b52bc7ab17ab"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a41682009252ece153547b52bc7ab17ab" translate="no">isColorSetPerInstance</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a41682009252ece153547b52bc7ab17ab"><td class="mdescLeft"> </td><td class="mdescRight">Return true if this color set is per-instance, and false if it is shared across all instances.  <a href="class_m_fn_mesh.html#a41682009252ece153547b52bc7ab17ab">More...</a><br/></td></tr>
<tr class="separator:a41682009252ece153547b52bc7ab17ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6ddc617454101d1e0b63607e4f70278b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a6ddc617454101d1e0b63607e4f70278b" translate="no">getAssociatedColorSetInstances</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a386bb83443e16a98e6fa10c683e76b6c" translate="no">setName</a>, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;instances) const </td></tr>
<tr class="memdesc:a6ddc617454101d1e0b63607e4f70278b"><td class="mdescLeft"> </td><td class="mdescRight">Get a list of the instance numbers associated with this color map.  <a href="class_m_fn_mesh.html#a6ddc617454101d1e0b63607e4f70278b">More...</a><br/></td></tr>
<tr class="separator:a6ddc617454101d1e0b63607e4f70278b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2a51e9229a7b5e6d74c1bd5d1ad81864"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2a51e9229a7b5e6d74c1bd5d1ad81864" translate="no">setFaceColor</a> (<a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, int index)</td></tr>
<tr class="memdesc:a2a51e9229a7b5e6d74c1bd5d1ad81864"><td class="mdescLeft"> </td><td class="mdescRight">Set vertex-face Color for all vertices on this face.  <a href="class_m_fn_mesh.html#a2a51e9229a7b5e6d74c1bd5d1ad81864">More...</a><br/></td></tr>
<tr class="separator:a2a51e9229a7b5e6d74c1bd5d1ad81864"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed7bf1abff6c273198f4603222adb82b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aed7bf1abff6c273198f4603222adb82b" translate="no">setFaceColor</a> (<a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, int index, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:aed7bf1abff6c273198f4603222adb82b"><td class="mdescLeft"> </td><td class="mdescRight">Set vertex-face Color of specified channels for all vertices on this face.  <a href="class_m_fn_mesh.html#aed7bf1abff6c273198f4603222adb82b">More...</a><br/></td></tr>
<tr class="separator:aed7bf1abff6c273198f4603222adb82b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b2000791e09a5ab2759ee23044257a9"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a7b2000791e09a5ab2759ee23044257a9" translate="no">setVertexColor</a> (<a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, int index, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a7b2000791e09a5ab2759ee23044257a9"><td class="mdescLeft"> </td><td class="mdescRight">Set color for this vertex.  <a href="class_m_fn_mesh.html#a7b2000791e09a5ab2759ee23044257a9">More...</a><br/></td></tr>
<tr class="separator:a7b2000791e09a5ab2759ee23044257a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39583d4ee99520690256b8b09619ed94"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a39583d4ee99520690256b8b09619ed94" translate="no">setVertexColor</a> (<a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, int index, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:a39583d4ee99520690256b8b09619ed94"><td class="mdescLeft"> </td><td class="mdescRight">Set color of specified channels for this vertex.  <a href="class_m_fn_mesh.html#a39583d4ee99520690256b8b09619ed94">More...</a><br/></td></tr>
<tr class="separator:a39583d4ee99520690256b8b09619ed94"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9460ef56bb85ffa256e9ec54d980ea23"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9460ef56bb85ffa256e9ec54d980ea23" translate="no">setFaceVertexColor</a> (<a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, int faceIndex, int vertexIndex, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a9460ef56bb85ffa256e9ec54d980ea23"><td class="mdescLeft"> </td><td class="mdescRight">Set color for this vertex in this face.  <a href="class_m_fn_mesh.html#a9460ef56bb85ffa256e9ec54d980ea23">More...</a><br/></td></tr>
<tr class="separator:a9460ef56bb85ffa256e9ec54d980ea23"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec0a38ef3939e21f7169df3647519d96"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aec0a38ef3939e21f7169df3647519d96" translate="no">setFaceVertexColor</a> (<a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, int faceIndex, int vertexIndex, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:aec0a38ef3939e21f7169df3647519d96"><td class="mdescLeft"> </td><td class="mdescRight">Set color of specified channels for this vertex in this face.  <a href="class_m_fn_mesh.html#aec0a38ef3939e21f7169df3647519d96">More...</a><br/></td></tr>
<tr class="separator:aec0a38ef3939e21f7169df3647519d96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6d5b048dcb3dd6eb1f3572ed324007b8"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a6d5b048dcb3dd6eb1f3572ed324007b8" translate="no">setFaceVertexColor</a> (int faceIndex, int localVertexIndex, <a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a6d5b048dcb3dd6eb1f3572ed324007b8"><td class="mdescLeft"> </td><td class="mdescRight">Set color for this vertex in this face.  <a href="class_m_fn_mesh.html#a6d5b048dcb3dd6eb1f3572ed324007b8">More...</a><br/></td></tr>
<tr class="separator:a6d5b048dcb3dd6eb1f3572ed324007b8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad22efa21c2b6e10b04bcf9702361153b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad22efa21c2b6e10b04bcf9702361153b" translate="no">setFaceVertexColor</a> (int faceIndex, int localVertexIndex, <a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:ad22efa21c2b6e10b04bcf9702361153b"><td class="mdescLeft"> </td><td class="mdescRight">Set color of specified channels for this vertex in this face.  <a href="class_m_fn_mesh.html#ad22efa21c2b6e10b04bcf9702361153b">More...</a><br/></td></tr>
<tr class="separator:ad22efa21c2b6e10b04bcf9702361153b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a66524d11f38db3801bcf91279cbf2f8e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a66524d11f38db3801bcf91279cbf2f8e" translate="no">setFaceColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList)</td></tr>
<tr class="memdesc:a66524d11f38db3801bcf91279cbf2f8e"><td class="mdescLeft"> </td><td class="mdescRight">Set color for these faces.  <a href="class_m_fn_mesh.html#a66524d11f38db3801bcf91279cbf2f8e">More...</a><br/></td></tr>
<tr class="separator:a66524d11f38db3801bcf91279cbf2f8e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9caebc9990d005fd57bc5d299c510a1e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9caebc9990d005fd57bc5d299c510a1e" translate="no">setFaceColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:a9caebc9990d005fd57bc5d299c510a1e"><td class="mdescLeft"> </td><td class="mdescRight">Set color of specified channels for these faces.  <a href="class_m_fn_mesh.html#a9caebc9990d005fd57bc5d299c510a1e">More...</a><br/></td></tr>
<tr class="separator:a9caebc9990d005fd57bc5d299c510a1e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac87fe328d734133476d0ae30796c7400"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ac87fe328d734133476d0ae30796c7400" translate="no">setVertexColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:ac87fe328d734133476d0ae30796c7400"><td class="mdescLeft"> </td><td class="mdescRight">Set color for these vertices.  <a href="class_m_fn_mesh.html#ac87fe328d734133476d0ae30796c7400">More...</a><br/></td></tr>
<tr class="separator:ac87fe328d734133476d0ae30796c7400"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7cc0efa066a791af527a2540f2cc26ab"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a7cc0efa066a791af527a2540f2cc26ab" translate="no">setVertexColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:a7cc0efa066a791af527a2540f2cc26ab"><td class="mdescLeft"> </td><td class="mdescRight">Set color of specified channels for these vertices.  <a href="class_m_fn_mesh.html#a7cc0efa066a791af527a2540f2cc26ab">More...</a><br/></td></tr>
<tr class="separator:a7cc0efa066a791af527a2540f2cc26ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a005ad2f6fc047c8bd7bf5d00ccd69084"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a005ad2f6fc047c8bd7bf5d00ccd69084" translate="no">setFaceVertexColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a005ad2f6fc047c8bd7bf5d00ccd69084"><td class="mdescLeft"> </td><td class="mdescRight">Set colors for these face/vertex pairs.  <a href="class_m_fn_mesh.html#a005ad2f6fc047c8bd7bf5d00ccd69084">More...</a><br/></td></tr>
<tr class="separator:a005ad2f6fc047c8bd7bf5d00ccd69084"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a376d72dd5ca14631c23c001cc202d778"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a376d72dd5ca14631c23c001cc202d778" translate="no">setFaceVertexColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:a376d72dd5ca14631c23c001cc202d778"><td class="mdescLeft"> </td><td class="mdescRight">Set colors of specified channels for these face/vertex pairs.  <a href="class_m_fn_mesh.html#a376d72dd5ca14631c23c001cc202d778">More...</a><br/></td></tr>
<tr class="separator:a376d72dd5ca14631c23c001cc202d778"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab6c8410fa9ddf943401053bdee6a106e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ab6c8410fa9ddf943401053bdee6a106e" translate="no">removeFaceColors</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList)</td></tr>
<tr class="memdesc:ab6c8410fa9ddf943401053bdee6a106e"><td class="mdescLeft"> </td><td class="mdescRight">Remove previously set color these faces.  <a href="class_m_fn_mesh.html#ab6c8410fa9ddf943401053bdee6a106e">More...</a><br/></td></tr>
<tr class="separator:ab6c8410fa9ddf943401053bdee6a106e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a37878b3ef7f30b2316caa1711f227a72"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a37878b3ef7f30b2316caa1711f227a72" translate="no">removeVertexColors</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList)</td></tr>
<tr class="memdesc:a37878b3ef7f30b2316caa1711f227a72"><td class="mdescLeft"> </td><td class="mdescRight">Remove color from these vertices.  <a href="class_m_fn_mesh.html#a37878b3ef7f30b2316caa1711f227a72">More...</a><br/></td></tr>
<tr class="separator:a37878b3ef7f30b2316caa1711f227a72"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4f4f4dad9160a70f8610b23269bf7725"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4f4f4dad9160a70f8610b23269bf7725" translate="no">removeFaceVertexColors</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;faceList, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;vertexList)</td></tr>
<tr class="memdesc:a4f4f4dad9160a70f8610b23269bf7725"><td class="mdescLeft"> </td><td class="mdescRight">Remove colors for these face/vertex pairs.  <a href="class_m_fn_mesh.html#a4f4f4dad9160a70f8610b23269bf7725">More...</a><br/></td></tr>
<tr class="separator:a4f4f4dad9160a70f8610b23269bf7725"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8bb405fe0fb575fc31c6b3be5174a445"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8bb405fe0fb575fc31c6b3be5174a445" translate="no">getVertexColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL, const <a class="el" href="./class_m_color.html" translate="no">MColor</a> *defaultUnsetColor=NULL)</td></tr>
<tr class="memdesc:a8bb405fe0fb575fc31c6b3be5174a445"><td class="mdescLeft"> </td><td class="mdescRight">Get colors for all Vertices of the given colorSet.  <a href="class_m_fn_mesh.html#a8bb405fe0fb575fc31c6b3be5174a445">More...</a><br/></td></tr>
<tr class="separator:a8bb405fe0fb575fc31c6b3be5174a445"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2489d7d07e535211e2ab49a1a1f14c7e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2489d7d07e535211e2ab49a1a1f14c7e" translate="no">getFaceVertexColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL, const <a class="el" href="./class_m_color.html" translate="no">MColor</a> *defaultUnsetColor=NULL)</td></tr>
<tr class="memdesc:a2489d7d07e535211e2ab49a1a1f14c7e"><td class="mdescLeft"> </td><td class="mdescRight">Get colors for all vertex/faces of the given color set.  <a href="class_m_fn_mesh.html#a2489d7d07e535211e2ab49a1a1f14c7e">More...</a><br/></td></tr>
<tr class="separator:a2489d7d07e535211e2ab49a1a1f14c7e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83d8e021c382b54ba0eef0b3718d04f8"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a83d8e021c382b54ba0eef0b3718d04f8" translate="no">getFaceVertexColorIndex</a> (int faceIndex, int localVertexIndex, int &amp;colorIndex, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL)</td></tr>
<tr class="memdesc:a83d8e021c382b54ba0eef0b3718d04f8"><td class="mdescLeft"> </td><td class="mdescRight">Get an index into the array returned by getFaceVertexColors.  <a href="class_m_fn_mesh.html#a83d8e021c382b54ba0eef0b3718d04f8">More...</a><br/></td></tr>
<tr class="separator:a83d8e021c382b54ba0eef0b3718d04f8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa770030da9bf7ac10dcb6d554edd2ebf"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa770030da9bf7ac10dcb6d554edd2ebf" translate="no">setColors</a> (const <a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL)</td></tr>
<tr class="memdesc:aa770030da9bf7ac10dcb6d554edd2ebf"><td class="mdescLeft"> </td><td class="mdescRight">Sets all of the colors for this mesh.  <a href="class_m_fn_mesh.html#aa770030da9bf7ac10dcb6d554edd2ebf">More...</a><br/></td></tr>
<tr class="separator:aa770030da9bf7ac10dcb6d554edd2ebf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a87d355d41093d740991ecd823dd3faf7"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a87d355d41093d740991ecd823dd3faf7" translate="no">setColors</a> (const <a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:a87d355d41093d740991ecd823dd3faf7"><td class="mdescLeft"> </td><td class="mdescRight">Sets all of the colors of specified channels for this mesh.  <a href="class_m_fn_mesh.html#a87d355d41093d740991ecd823dd3faf7">More...</a><br/></td></tr>
<tr class="separator:a87d355d41093d740991ecd823dd3faf7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa694d787411ae5bed8972540ff42fcbd"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa694d787411ae5bed8972540ff42fcbd" translate="no">setSomeColors</a> (const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;colorIds, const <a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL)</td></tr>
<tr class="memdesc:aa694d787411ae5bed8972540ff42fcbd"><td class="mdescLeft"> </td><td class="mdescRight">Sets the specified colors for this mesh.  <a href="class_m_fn_mesh.html#aa694d787411ae5bed8972540ff42fcbd">More...</a><br/></td></tr>
<tr class="separator:aa694d787411ae5bed8972540ff42fcbd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a43afde2802b2ec0da53095fdcda3db34"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a43afde2802b2ec0da53095fdcda3db34" translate="no">setSomeColors</a> (const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;colorIds, const <a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:a43afde2802b2ec0da53095fdcda3db34"><td class="mdescLeft"> </td><td class="mdescRight">Sets the specified colors of specified channels for this mesh.  <a href="class_m_fn_mesh.html#a43afde2802b2ec0da53095fdcda3db34">More...</a><br/></td></tr>
<tr class="separator:a43afde2802b2ec0da53095fdcda3db34"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a01a4bbfbbe031efd14ee58771d38d236"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a01a4bbfbbe031efd14ee58771d38d236" translate="no">getColors</a> (<a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp;colors, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL, const <a class="el" href="./class_m_color.html" translate="no">MColor</a> *defaultUnsetColor=NULL) const </td></tr>
<tr class="memdesc:a01a4bbfbbe031efd14ee58771d38d236"><td class="mdescLeft"> </td><td class="mdescRight">This method copies the color array for this mesh into the given color array.  <a href="class_m_fn_mesh.html#a01a4bbfbbe031efd14ee58771d38d236">More...</a><br/></td></tr>
<tr class="separator:a01a4bbfbbe031efd14ee58771d38d236"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adcc83c6ccc1cbd3cdd5ed6668a149d1f"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#adcc83c6ccc1cbd3cdd5ed6668a149d1f" translate="no">getColorIndex</a> (int faceIndex, int localVertexIndex, int &amp;colorIndex, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL)</td></tr>
<tr class="memdesc:adcc83c6ccc1cbd3cdd5ed6668a149d1f"><td class="mdescLeft"> </td><td class="mdescRight">Get an index into the array returned by getColors.  <a href="class_m_fn_mesh.html#adcc83c6ccc1cbd3cdd5ed6668a149d1f">More...</a><br/></td></tr>
<tr class="separator:adcc83c6ccc1cbd3cdd5ed6668a149d1f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acd93503d62808228cbd46f80fb1d53cb"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#acd93503d62808228cbd46f80fb1d53cb" translate="no">setColor</a> (int colorId, const <a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL)</td></tr>
<tr class="memdesc:acd93503d62808228cbd46f80fb1d53cb"><td class="mdescLeft"> </td><td class="mdescRight">Sets the specified color values.  <a href="class_m_fn_mesh.html#acd93503d62808228cbd46f80fb1d53cb">More...</a><br/></td></tr>
<tr class="separator:acd93503d62808228cbd46f80fb1d53cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad424faddd9b4c9bd31bbf79e05cf6313"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad424faddd9b4c9bd31bbf79e05cf6313" translate="no">setColor</a> (int colorId, const <a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep)</td></tr>
<tr class="memdesc:ad424faddd9b4c9bd31bbf79e05cf6313"><td class="mdescLeft"> </td><td class="mdescRight">Sets the specified color values of specified channels.  <a href="class_m_fn_mesh.html#ad424faddd9b4c9bd31bbf79e05cf6313">More...</a><br/></td></tr>
<tr class="separator:ad424faddd9b4c9bd31bbf79e05cf6313"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad66fe51355fa1faf66ddc616c1884692"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad66fe51355fa1faf66ddc616c1884692" translate="no">getColor</a> (int colorId, <a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL, const <a class="el" href="./class_m_color.html" translate="no">MColor</a> *defaultUnsetColor=NULL) const </td></tr>
<tr class="memdesc:ad66fe51355fa1faf66ddc616c1884692"><td class="mdescLeft"> </td><td class="mdescRight">Get the value of the specified texture coordinate from this mesh's color list.  <a href="class_m_fn_mesh.html#ad66fe51355fa1faf66ddc616c1884692">More...</a><br/></td></tr>
<tr class="separator:ad66fe51355fa1faf66ddc616c1884692"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3949b8d4c4f589ac2d6a1aa23d8493ac"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a3949b8d4c4f589ac2d6a1aa23d8493ac" translate="no">assignColor</a> (int polygonId, int vertexIndex, int colorId, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL)</td></tr>
<tr class="memdesc:a3949b8d4c4f589ac2d6a1aa23d8493ac"><td class="mdescLeft"> </td><td class="mdescRight">Maps a color value to a specified vertex of a polygon.  <a href="class_m_fn_mesh.html#a3949b8d4c4f589ac2d6a1aa23d8493ac">More...</a><br/></td></tr>
<tr class="separator:a3949b8d4c4f589ac2d6a1aa23d8493ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9db86252d7a7d109c5b496207168bc20"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9db86252d7a7d109c5b496207168bc20" translate="no">assignColors</a> (const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;colorIds, const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL)</td></tr>
<tr class="memdesc:a9db86252d7a7d109c5b496207168bc20"><td class="mdescLeft"> </td><td class="mdescRight">This method maps all colors for the mesh.  <a href="class_m_fn_mesh.html#a9db86252d7a7d109c5b496207168bc20">More...</a><br/></td></tr>
<tr class="separator:a9db86252d7a7d109c5b496207168bc20"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8ef0e983f8284a5c2d762984ca49beed"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8ef0e983f8284a5c2d762984ca49beed" translate="no">clearColors</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> *colorSet=NULL)</td></tr>
<tr class="memdesc:a8ef0e983f8284a5c2d762984ca49beed"><td class="mdescLeft"> </td><td class="mdescRight">This method clears out all color for the mesh, and leaves behind an empty color set.  <a href="class_m_fn_mesh.html#a8ef0e983f8284a5c2d762984ca49beed">More...</a><br/></td></tr>
<tr class="separator:a8ef0e983f8284a5c2d762984ca49beed"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a97ab47fbb3cbfab6f1d6899d255b32e8"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a97ab47fbb3cbfab6f1d6899d255b32e8" translate="no">displayColors</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a97ab47fbb3cbfab6f1d6899d255b32e8"><td class="mdescLeft"> </td><td class="mdescRight">Determine if the mesh node is set to display vertex colors.  <a href="class_m_fn_mesh.html#a97ab47fbb3cbfab6f1d6899d255b32e8">More...</a><br/></td></tr>
<tr class="separator:a97ab47fbb3cbfab6f1d6899d255b32e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac5b1b4574da46a7530b5c2782e08ab05"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ac5b1b4574da46a7530b5c2782e08ab05" translate="no">setDisplayColors</a> (bool enable)</td></tr>
<tr class="memdesc:ac5b1b4574da46a7530b5c2782e08ab05"><td class="mdescLeft"> </td><td class="mdescRight">Set whether the mesh node should display vertex colors.  <a href="class_m_fn_mesh.html#ac5b1b4574da46a7530b5c2782e08ab05">More...</a><br/></td></tr>
<tr class="separator:ac5b1b4574da46a7530b5c2782e08ab05"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab0e871427039e4f00635a3c5b4af19f1"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ab0e871427039e4f00635a3c5b4af19f1" translate="no">getHoles</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;holeInfoArray, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;holeVertexArray, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ab0e871427039e4f00635a3c5b4af19f1"><td class="mdescLeft"> </td><td class="mdescRight">Retrieves a list of the holes in the polygon.  <a href="class_m_fn_mesh.html#ab0e871427039e4f00635a3c5b4af19f1">More...</a><br/></td></tr>
<tr class="separator:ab0e871427039e4f00635a3c5b4af19f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a012df987a82e008e957d1946738485cf"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a012df987a82e008e957d1946738485cf" translate="no">onBoundary</a> (int polygonId, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a012df987a82e008e957d1946738485cf"><td class="mdescLeft"> </td><td class="mdescRight">A method to determines whether the specified face in the mesh is a boundary face.  <a href="class_m_fn_mesh.html#a012df987a82e008e957d1946738485cf">More...</a><br/></td></tr>
<tr class="separator:a012df987a82e008e957d1946738485cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af736cc3ed8a3c7c459098b5c9470c1ff"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af736cc3ed8a3c7c459098b5c9470c1ff" translate="no">isBlindDataTypeUsed</a> (int blindDataId, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:af736cc3ed8a3c7c459098b5c9470c1ff"><td class="mdescLeft"> </td><td class="mdescRight">Is this BlindData type id is already in use in this scene?  <a href="class_m_fn_mesh.html#af736cc3ed8a3c7c459098b5c9470c1ff">More...</a><br/></td></tr>
<tr class="separator:af736cc3ed8a3c7c459098b5c9470c1ff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa5352e346243d140b7b30ac4242db937"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa5352e346243d140b7b30ac4242db937" translate="no">createBlindDataType</a> (int blindDataId, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> longNames, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> shortNames, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> formatNames)</td></tr>
<tr class="memdesc:aa5352e346243d140b7b30ac4242db937"><td class="mdescLeft"> </td><td class="mdescRight">Create a new blind data type.  <a href="class_m_fn_mesh.html#aa5352e346243d140b7b30ac4242db937">More...</a><br/></td></tr>
<tr class="separator:aa5352e346243d140b7b30ac4242db937"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a487f967198f594a077152f3999839726"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a487f967198f594a077152f3999839726" translate="no">hasBlindDataComponentId</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a487f967198f594a077152f3999839726"><td class="mdescLeft"> </td><td class="mdescRight">Does this component have blind data with the given ID.  <a href="class_m_fn_mesh.html#a487f967198f594a077152f3999839726">More...</a><br/></td></tr>
<tr class="separator:a487f967198f594a077152f3999839726"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e98180f88babf1b2d45c7c16d8ae286"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a5e98180f88babf1b2d45c7c16d8ae286" translate="no">hasBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a5e98180f88babf1b2d45c7c16d8ae286"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if any component of the given type on this mesh have blind data with the given ID.  <a href="class_m_fn_mesh.html#a5e98180f88babf1b2d45c7c16d8ae286">More...</a><br/></td></tr>
<tr class="separator:a5e98180f88babf1b2d45c7c16d8ae286"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4757e5f831a9a1a76c67fc79d18791de"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4757e5f831a9a1a76c67fc79d18791de" translate="no">hasBlindDataComponentId</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a4757e5f831a9a1a76c67fc79d18791de"><td class="mdescLeft"> </td><td class="mdescRight">Does this component have any kind of blind data.  <a href="class_m_fn_mesh.html#a4757e5f831a9a1a76c67fc79d18791de">More...</a><br/></td></tr>
<tr class="separator:a4757e5f831a9a1a76c67fc79d18791de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afbce826a6cca065c8d9ffa0a84728eaa"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#afbce826a6cca065c8d9ffa0a84728eaa" translate="no">hasBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:afbce826a6cca065c8d9ffa0a84728eaa"><td class="mdescLeft"> </td><td class="mdescRight">Does any component of this type have any blind data.  <a href="class_m_fn_mesh.html#afbce826a6cca065c8d9ffa0a84728eaa">More...</a><br/></td></tr>
<tr class="separator:afbce826a6cca065c8d9ffa0a84728eaa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a88317bf90ae2703149ec9ab200967244"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a88317bf90ae2703149ec9ab200967244" translate="no">getBlindDataTypes</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;blindDataIds) const </td></tr>
<tr class="memdesc:a88317bf90ae2703149ec9ab200967244"><td class="mdescLeft"> </td><td class="mdescRight">Get the list of blind data ID's associated with the given component type on this mesh.  <a href="class_m_fn_mesh.html#a88317bf90ae2703149ec9ab200967244">More...</a><br/></td></tr>
<tr class="separator:a88317bf90ae2703149ec9ab200967244"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a96c262ac789d822a21278e744152f53b"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a96c262ac789d822a21278e744152f53b" translate="no">getBlindDataAttrNames</a> (int blindDataId, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;longNames, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;shortNames, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;formatNames) const </td></tr>
<tr class="memdesc:a96c262ac789d822a21278e744152f53b"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data attribute names and types for the specified blind data type id.  <a href="class_m_fn_mesh.html#a96c262ac789d822a21278e744152f53b">More...</a><br/></td></tr>
<tr class="separator:a96c262ac789d822a21278e744152f53b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af18375adb69e719960a46d972fa0e962"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af18375adb69e719960a46d972fa0e962" translate="no">getFaceVertexBlindDataIndex</a> (int faceIndex, int vertexIndex, int &amp;blindDataIndex) const </td></tr>
<tr class="memdesc:af18375adb69e719960a46d972fa0e962"><td class="mdescLeft"> </td><td class="mdescRight">Get the single index to retrieve face-vertex blind data.  <a href="class_m_fn_mesh.html#af18375adb69e719960a46d972fa0e962">More...</a><br/></td></tr>
<tr class="separator:af18375adb69e719960a46d972fa0e962"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adfaf9bba50f6afd2dad942ccf15daf30"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#adfaf9bba50f6afd2dad942ccf15daf30" translate="no">getBlindDataFaceVertexIndices</a> (int blindDataIndex, int &amp;faceIndex, int &amp;vertexIndex) const </td></tr>
<tr class="memdesc:adfaf9bba50f6afd2dad942ccf15daf30"><td class="mdescLeft"> </td><td class="mdescRight">Get the face and vertex indices from the face-vertex blind data index.  <a href="class_m_fn_mesh.html#adfaf9bba50f6afd2dad942ccf15daf30">More...</a><br/></td></tr>
<tr class="separator:adfaf9bba50f6afd2dad942ccf15daf30"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a52ca8bcf4dbe0c7ad1b0a0e201c6b491"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a52ca8bcf4dbe0c7ad1b0a0e201c6b491" translate="no">getIntBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, int &amp;data) const </td></tr>
<tr class="memdesc:a52ca8bcf4dbe0c7ad1b0a0e201c6b491"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute of the specified component.  <a href="class_m_fn_mesh.html#a52ca8bcf4dbe0c7ad1b0a0e201c6b491">More...</a><br/></td></tr>
<tr class="separator:a52ca8bcf4dbe0c7ad1b0a0e201c6b491"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afc60db4cc7e04e622e4021ff25934f62"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#afc60db4cc7e04e622e4021ff25934f62" translate="no">getIntBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;data) const </td></tr>
<tr class="memdesc:afc60db4cc7e04e622e4021ff25934f62"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute of the given type of component.  <a href="class_m_fn_mesh.html#afc60db4cc7e04e622e4021ff25934f62">More...</a><br/></td></tr>
<tr class="separator:afc60db4cc7e04e622e4021ff25934f62"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc8318ebcbc33cb018df5d930aa03719"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#adc8318ebcbc33cb018df5d930aa03719" translate="no">getFloatBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, float &amp;data) const </td></tr>
<tr class="memdesc:adc8318ebcbc33cb018df5d930aa03719"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute of the specified component.  <a href="class_m_fn_mesh.html#adc8318ebcbc33cb018df5d930aa03719">More...</a><br/></td></tr>
<tr class="separator:adc8318ebcbc33cb018df5d930aa03719"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1e748730e9f9c113f7e5aef0786ae0f1"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a1e748730e9f9c113f7e5aef0786ae0f1" translate="no">getFloatBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;data) const </td></tr>
<tr class="memdesc:a1e748730e9f9c113f7e5aef0786ae0f1"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute for all components of the given type.  <a href="class_m_fn_mesh.html#a1e748730e9f9c113f7e5aef0786ae0f1">More...</a><br/></td></tr>
<tr class="separator:a1e748730e9f9c113f7e5aef0786ae0f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7d6413a5c91c2acccd833ccfecdeb896"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a7d6413a5c91c2acccd833ccfecdeb896" translate="no">getDoubleBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, double &amp;data) const </td></tr>
<tr class="memdesc:a7d6413a5c91c2acccd833ccfecdeb896"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute of the specified component.  <a href="class_m_fn_mesh.html#a7d6413a5c91c2acccd833ccfecdeb896">More...</a><br/></td></tr>
<tr class="separator:a7d6413a5c91c2acccd833ccfecdeb896"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa6c7a6b3b64285b48430e3c6f5c653fb"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa6c7a6b3b64285b48430e3c6f5c653fb" translate="no">getDoubleBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;data) const </td></tr>
<tr class="memdesc:aa6c7a6b3b64285b48430e3c6f5c653fb"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute for all components of the given type.  <a href="class_m_fn_mesh.html#aa6c7a6b3b64285b48430e3c6f5c653fb">More...</a><br/></td></tr>
<tr class="separator:aa6c7a6b3b64285b48430e3c6f5c653fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4fe04d06c0667b67ed7c8f29dfaf86b5"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4fe04d06c0667b67ed7c8f29dfaf86b5" translate="no">getBoolBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, bool &amp;data) const </td></tr>
<tr class="memdesc:a4fe04d06c0667b67ed7c8f29dfaf86b5"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute of the specified component.  <a href="class_m_fn_mesh.html#a4fe04d06c0667b67ed7c8f29dfaf86b5">More...</a><br/></td></tr>
<tr class="separator:a4fe04d06c0667b67ed7c8f29dfaf86b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a26f7a0e414b6f5145da4ba8dc24e956e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a26f7a0e414b6f5145da4ba8dc24e956e" translate="no">getBoolBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;data) const </td></tr>
<tr class="memdesc:a26f7a0e414b6f5145da4ba8dc24e956e"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute for all components of the given type.  <a href="class_m_fn_mesh.html#a26f7a0e414b6f5145da4ba8dc24e956e">More...</a><br/></td></tr>
<tr class="separator:a26f7a0e414b6f5145da4ba8dc24e956e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abc88d2109836b63f72ddfd7fe7aaeb86"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#abc88d2109836b63f72ddfd7fe7aaeb86" translate="no">stringBlindDataComponentId</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:abc88d2109836b63f72ddfd7fe7aaeb86"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute of the specified component.  <a href="class_m_fn_mesh.html#abc88d2109836b63f72ddfd7fe7aaeb86">More...</a><br/></td></tr>
<tr class="separator:abc88d2109836b63f72ddfd7fe7aaeb86"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1705fdf45427c7b5992c67e919d4db61"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a1705fdf45427c7b5992c67e919d4db61" translate="no">getStringBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;data) const </td></tr>
<tr class="memdesc:a1705fdf45427c7b5992c67e919d4db61"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute for all components of the given type.  <a href="class_m_fn_mesh.html#a1705fdf45427c7b5992c67e919d4db61">More...</a><br/></td></tr>
<tr class="separator:a1705fdf45427c7b5992c67e919d4db61"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2a541f1ff4a7416acc6fe477594524d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af2a541f1ff4a7416acc6fe477594524d" translate="no">binaryBlindDataComponentId</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:af2a541f1ff4a7416acc6fe477594524d"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute of the specified component.  <a href="class_m_fn_mesh.html#af2a541f1ff4a7416acc6fe477594524d">More...</a><br/></td></tr>
<tr class="separator:af2a541f1ff4a7416acc6fe477594524d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40f5742295cb83ad317ca12e7f73a5d6"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a40f5742295cb83ad317ca12e7f73a5d6" translate="no">getBinaryBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;data) const </td></tr>
<tr class="memdesc:a40f5742295cb83ad317ca12e7f73a5d6"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data value for the specified blind data attribute for all components of the given type.  <a href="class_m_fn_mesh.html#a40f5742295cb83ad317ca12e7f73a5d6">More...</a><br/></td></tr>
<tr class="separator:a40f5742295cb83ad317ca12e7f73a5d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7518cd0a4dcb82857af9a85871beec21"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a7518cd0a4dcb82857af9a85871beec21" translate="no">setIntBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, int data)</td></tr>
<tr class="memdesc:a7518cd0a4dcb82857af9a85871beec21"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for an integer blind data attribute.  <a href="class_m_fn_mesh.html#a7518cd0a4dcb82857af9a85871beec21">More...</a><br/></td></tr>
<tr class="separator:a7518cd0a4dcb82857af9a85871beec21"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a029bbec6cd39909312df1278d5f76371"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a029bbec6cd39909312df1278d5f76371" translate="no">setIntBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, int data)</td></tr>
<tr class="memdesc:a029bbec6cd39909312df1278d5f76371"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for an integer blind data on an array of components.  <a href="class_m_fn_mesh.html#a029bbec6cd39909312df1278d5f76371">More...</a><br/></td></tr>
<tr class="separator:a029bbec6cd39909312df1278d5f76371"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad9d25268bef268ae9cd8e93ec345497f"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad9d25268bef268ae9cd8e93ec345497f" translate="no">setIntBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;data)</td></tr>
<tr class="memdesc:ad9d25268bef268ae9cd8e93ec345497f"><td class="mdescLeft"> </td><td class="mdescRight">Set a values for an integer blind data on an array of components.  <a href="class_m_fn_mesh.html#ad9d25268bef268ae9cd8e93ec345497f">More...</a><br/></td></tr>
<tr class="separator:ad9d25268bef268ae9cd8e93ec345497f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a589e38acc86daee4382134afd8199125"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a589e38acc86daee4382134afd8199125" translate="no">setFloatBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, float data)</td></tr>
<tr class="memdesc:a589e38acc86daee4382134afd8199125"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for a float blind data attribute.  <a href="class_m_fn_mesh.html#a589e38acc86daee4382134afd8199125">More...</a><br/></td></tr>
<tr class="separator:a589e38acc86daee4382134afd8199125"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44fc02d1a8a25dabd8d731119d2bc0e7"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a44fc02d1a8a25dabd8d731119d2bc0e7" translate="no">setFloatBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, float data)</td></tr>
<tr class="memdesc:a44fc02d1a8a25dabd8d731119d2bc0e7"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for float blind data on an array of components.  <a href="class_m_fn_mesh.html#a44fc02d1a8a25dabd8d731119d2bc0e7">More...</a><br/></td></tr>
<tr class="separator:a44fc02d1a8a25dabd8d731119d2bc0e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9abee1b8736ee341eb92d4b2b54275b1"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9abee1b8736ee341eb92d4b2b54275b1" translate="no">setFloatBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp;data)</td></tr>
<tr class="memdesc:a9abee1b8736ee341eb92d4b2b54275b1"><td class="mdescLeft"> </td><td class="mdescRight">Set a values for a float blind data on an array of components.  <a href="class_m_fn_mesh.html#a9abee1b8736ee341eb92d4b2b54275b1">More...</a><br/></td></tr>
<tr class="separator:a9abee1b8736ee341eb92d4b2b54275b1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae53fe2c510e9221ac92d64b8562c39af"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ae53fe2c510e9221ac92d64b8562c39af" translate="no">setDoubleBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, double data)</td></tr>
<tr class="memdesc:ae53fe2c510e9221ac92d64b8562c39af"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for a double blind data attribute.  <a href="class_m_fn_mesh.html#ae53fe2c510e9221ac92d64b8562c39af">More...</a><br/></td></tr>
<tr class="separator:ae53fe2c510e9221ac92d64b8562c39af"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6de81856f127bec3ddce0d1e73c7b201"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a6de81856f127bec3ddce0d1e73c7b201" translate="no">setDoubleBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, double data)</td></tr>
<tr class="memdesc:a6de81856f127bec3ddce0d1e73c7b201"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for double blind data on an array of components.  <a href="class_m_fn_mesh.html#a6de81856f127bec3ddce0d1e73c7b201">More...</a><br/></td></tr>
<tr class="separator:a6de81856f127bec3ddce0d1e73c7b201"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a66000a2c0860bb907ca301463acbc5db"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a66000a2c0860bb907ca301463acbc5db" translate="no">setDoubleBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;data)</td></tr>
<tr class="memdesc:a66000a2c0860bb907ca301463acbc5db"><td class="mdescLeft"> </td><td class="mdescRight">Set a values for a double blind data on an array of components.  <a href="class_m_fn_mesh.html#a66000a2c0860bb907ca301463acbc5db">More...</a><br/></td></tr>
<tr class="separator:a66000a2c0860bb907ca301463acbc5db"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4587300ddf64bda38a5f7146285be5dc"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4587300ddf64bda38a5f7146285be5dc" translate="no">setBoolBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, bool data)</td></tr>
<tr class="memdesc:a4587300ddf64bda38a5f7146285be5dc"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for a boolean blind data attribute.  <a href="class_m_fn_mesh.html#a4587300ddf64bda38a5f7146285be5dc">More...</a><br/></td></tr>
<tr class="separator:a4587300ddf64bda38a5f7146285be5dc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74badb566f5d7670d9fbf568ce979f7a"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a74badb566f5d7670d9fbf568ce979f7a" translate="no">setBoolBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, bool data)</td></tr>
<tr class="memdesc:a74badb566f5d7670d9fbf568ce979f7a"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for boolean blind data on an array of components.  <a href="class_m_fn_mesh.html#a74badb566f5d7670d9fbf568ce979f7a">More...</a><br/></td></tr>
<tr class="separator:a74badb566f5d7670d9fbf568ce979f7a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7dec27ae45e701ad6469411f2c4bd16"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ab7dec27ae45e701ad6469411f2c4bd16" translate="no">setBoolBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;data)</td></tr>
<tr class="memdesc:ab7dec27ae45e701ad6469411f2c4bd16"><td class="mdescLeft"> </td><td class="mdescRight">Set a values for a boolean blind data on an array of components.  <a href="class_m_fn_mesh.html#ab7dec27ae45e701ad6469411f2c4bd16">More...</a><br/></td></tr>
<tr class="separator:ab7dec27ae45e701ad6469411f2c4bd16"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac88a1c88524c81ee8501994117b63d5d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ac88a1c88524c81ee8501994117b63d5d" translate="no">setStringBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_string.html" translate="no">MString</a> data)</td></tr>
<tr class="memdesc:ac88a1c88524c81ee8501994117b63d5d"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for a string blind data attribute.  <a href="class_m_fn_mesh.html#ac88a1c88524c81ee8501994117b63d5d">More...</a><br/></td></tr>
<tr class="separator:ac88a1c88524c81ee8501994117b63d5d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b95148242961bcce9d984e8dad0d37e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a7b95148242961bcce9d984e8dad0d37e" translate="no">setStringBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_string.html" translate="no">MString</a> data)</td></tr>
<tr class="memdesc:a7b95148242961bcce9d984e8dad0d37e"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for string blind data on an array of components.  <a href="class_m_fn_mesh.html#a7b95148242961bcce9d984e8dad0d37e">More...</a><br/></td></tr>
<tr class="separator:a7b95148242961bcce9d984e8dad0d37e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0773a54659279feceb61c0a8325980d9"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a0773a54659279feceb61c0a8325980d9" translate="no">setStringBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;data)</td></tr>
<tr class="memdesc:a0773a54659279feceb61c0a8325980d9"><td class="mdescLeft"> </td><td class="mdescRight">Set a values for a string blind data on an array of components.  <a href="class_m_fn_mesh.html#a0773a54659279feceb61c0a8325980d9">More...</a><br/></td></tr>
<tr class="separator:a0773a54659279feceb61c0a8325980d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ab38f65ca6a1f2d1d8572a856b5ad6c"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2ab38f65ca6a1f2d1d8572a856b5ad6c" translate="no">setBinaryBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_string.html" translate="no">MString</a> data)</td></tr>
<tr class="memdesc:a2ab38f65ca6a1f2d1d8572a856b5ad6c"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for a binary blind data attribute.  <a href="class_m_fn_mesh.html#a2ab38f65ca6a1f2d1d8572a856b5ad6c">More...</a><br/></td></tr>
<tr class="separator:a2ab38f65ca6a1f2d1d8572a856b5ad6c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a349d6c661c067c39a604d59738e3e3f1"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a349d6c661c067c39a604d59738e3e3f1" translate="no">setBinaryBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_string.html" translate="no">MString</a> data)</td></tr>
<tr class="memdesc:a349d6c661c067c39a604d59738e3e3f1"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for binary blind data on an array of components.  <a href="class_m_fn_mesh.html#a349d6c661c067c39a604d59738e3e3f1">More...</a><br/></td></tr>
<tr class="separator:a349d6c661c067c39a604d59738e3e3f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aad99295aa9378a61406a02b18aab5d11"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aad99295aa9378a61406a02b18aab5d11" translate="no">setBinaryBlindData</a> (<a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;compIDs, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;data)</td></tr>
<tr class="memdesc:aad99295aa9378a61406a02b18aab5d11"><td class="mdescLeft"> </td><td class="mdescRight">Set a values for a binary blind data on an array of components.  <a href="class_m_fn_mesh.html#aad99295aa9378a61406a02b18aab5d11">More...</a><br/></td></tr>
<tr class="separator:aad99295aa9378a61406a02b18aab5d11"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad07c654eb7214ea75891b803c5ee3628"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad07c654eb7214ea75891b803c5ee3628" translate="no">setBinaryBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, char *data, int length)</td></tr>
<tr class="memdesc:ad07c654eb7214ea75891b803c5ee3628"><td class="mdescLeft"> </td><td class="mdescRight">Set a value for a binary blind data attribute.  <a href="class_m_fn_mesh.html#ad07c654eb7214ea75891b803c5ee3628">More...</a><br/></td></tr>
<tr class="separator:ad07c654eb7214ea75891b803c5ee3628"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a41bc22c908735cae09a3dab4b8804810"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a41bc22c908735cae09a3dab4b8804810" translate="no">clearBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName)</td></tr>
<tr class="memdesc:a41bc22c908735cae09a3dab4b8804810"><td class="mdescLeft"> </td><td class="mdescRight">Delete a value for a binary blind data attribute on a particular componenr.  <a href="class_m_fn_mesh.html#a41bc22c908735cae09a3dab4b8804810">More...</a><br/></td></tr>
<tr class="separator:a41bc22c908735cae09a3dab4b8804810"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9216a34492c715cbcc879659ff77e1e4"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9216a34492c715cbcc879659ff77e1e4" translate="no">clearBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName)</td></tr>
<tr class="memdesc:a9216a34492c715cbcc879659ff77e1e4"><td class="mdescLeft"> </td><td class="mdescRight">Delete the values for the given attribute on the given binary blind data type from all components of the given type.  <a href="class_m_fn_mesh.html#a9216a34492c715cbcc879659ff77e1e4">More...</a><br/></td></tr>
<tr class="separator:a9216a34492c715cbcc879659ff77e1e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2139236dddbcc55d88ec2970531956dd"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a2139236dddbcc55d88ec2970531956dd" translate="no">clearBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType)</td></tr>
<tr class="memdesc:a2139236dddbcc55d88ec2970531956dd"><td class="mdescLeft"> </td><td class="mdescRight">Delete all blind data from components of the given type, e.g.  <a href="class_m_fn_mesh.html#a2139236dddbcc55d88ec2970531956dd">More...</a><br/></td></tr>
<tr class="separator:a2139236dddbcc55d88ec2970531956dd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaf3365a6b861eea09cb674278487c763"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aaf3365a6b861eea09cb674278487c763" translate="no">clearBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId)</td></tr>
<tr class="memdesc:aaf3365a6b861eea09cb674278487c763"><td class="mdescLeft"> </td><td class="mdescRight">Delete the values for a binary blind data type (all its attributes) from a particular component.  <a href="class_m_fn_mesh.html#aaf3365a6b861eea09cb674278487c763">More...</a><br/></td></tr>
<tr class="separator:aaf3365a6b861eea09cb674278487c763"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a421139620f24cf21460c061a4b346e04"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a421139620f24cf21460c061a4b346e04" translate="no">clearBlindData</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId)</td></tr>
<tr class="memdesc:a421139620f24cf21460c061a4b346e04"><td class="mdescLeft"> </td><td class="mdescRight">Delete the values for a binary blind data type (all its attributes) from all components of the given type.  <a href="class_m_fn_mesh.html#a421139620f24cf21460c061a4b346e04">More...</a><br/></td></tr>
<tr class="separator:a421139620f24cf21460c061a4b346e04"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af876ed6feb4e7a12c1615fd39fba70a2"><td align="right" class="memItemLeft" translate="no" valign="top">void </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af876ed6feb4e7a12c1615fd39fba70a2" translate="no">setCheckSamePointTwice</a> (bool check=true)</td></tr>
<tr class="memdesc:af876ed6feb4e7a12c1615fd39fba70a2"><td class="mdescLeft"> </td><td class="mdescRight">This method allows the turning on or off of duplicate point checking when polygons are created or added using this class.  <a href="class_m_fn_mesh.html#af876ed6feb4e7a12c1615fd39fba70a2">More...</a><br/></td></tr>
<tr class="separator:af876ed6feb4e7a12c1615fd39fba70a2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9cbec85167bda6017a86e5e566e2d0d"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa9cbec85167bda6017a86e5e566e2d0d" translate="no">getCheckSamePointTwice</a> (void)</td></tr>
<tr class="memdesc:aa9cbec85167bda6017a86e5e566e2d0d"><td class="mdescLeft"> </td><td class="mdescRight">Return true if checking for duplicate points is turned on.  <a href="class_m_fn_mesh.html#aa9cbec85167bda6017a86e5e566e2d0d">More...</a><br/></td></tr>
<tr class="separator:aa9cbec85167bda6017a86e5e566e2d0d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3f723a01bbdf26f5cb58742739de97c4"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a3f723a01bbdf26f5cb58742739de97c4" translate="no">createInPlace</a> (int <a class="el" href="./class_m_fn_mesh.html#a9959c49420dce143087cb0abe402923e" translate="no">numVertices</a>, int <a class="el" href="./class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed" translate="no">numPolygons</a>, const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;vertexArray, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonCounts, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;polygonConnects)</td></tr>
<tr class="memdesc:a3f723a01bbdf26f5cb58742739de97c4"><td class="mdescLeft"> </td><td class="mdescRight">Replaces the existing polygonal mesh with a new one specified by array of vertices and polygon connection information.  <a href="class_m_fn_mesh.html#a3f723a01bbdf26f5cb58742739de97c4">More...</a><br/></td></tr>
<tr class="separator:a3f723a01bbdf26f5cb58742739de97c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3436ba1b31e988b6eee43573e2909af2"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a3436ba1b31e988b6eee43573e2909af2" translate="no">copyInPlace</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;source)</td></tr>
<tr class="memdesc:a3436ba1b31e988b6eee43573e2909af2"><td class="mdescLeft"> </td><td class="mdescRight">This method creates copies the given source mesh onto the current surface.  <a href="class_m_fn_mesh.html#a3436ba1b31e988b6eee43573e2909af2">More...</a><br/></td></tr>
<tr class="separator:a3436ba1b31e988b6eee43573e2909af2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa705f8fc626667e5624fabca8ee77d6e"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa705f8fc626667e5624fabca8ee77d6e" translate="no">createColorSetWithName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSetName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus)</td></tr>
<tr class="memdesc:aa705f8fc626667e5624fabca8ee77d6e"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#aa705f8fc626667e5624fabca8ee77d6e">More...</a><br/></td></tr>
<tr class="separator:aa705f8fc626667e5624fabca8ee77d6e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acc1575fc1ca70a9cfea00ad683d36221"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#acc1575fc1ca70a9cfea00ad683d36221" translate="no">generateSmoothMesh</a> (<a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus)</td></tr>
<tr class="memdesc:acc1575fc1ca70a9cfea00ad683d36221"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#acc1575fc1ca70a9cfea00ad683d36221">More...</a><br/></td></tr>
<tr class="separator:acc1575fc1ca70a9cfea00ad683d36221"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0c420e9ee0ab2b2368bb2c9506c586ff"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a0c420e9ee0ab2b2368bb2c9506c586ff" translate="no">MFnMesh</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ret=NULL)</td></tr>
<tr class="memdesc:a0c420e9ee0ab2b2368bb2c9506c586ff"><td class="mdescLeft"> </td><td class="mdescRight">Constructor.  <a href="class_m_fn_mesh.html#a0c420e9ee0ab2b2368bb2c9506c586ff">More...</a><br/></td></tr>
<tr class="separator:a0c420e9ee0ab2b2368bb2c9506c586ff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b295cc747301e51d3db5e93ea7fcda0"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a3b295cc747301e51d3db5e93ea7fcda0" translate="no">currentColorSetName</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus) const </td></tr>
<tr class="memdesc:a3b295cc747301e51d3db5e93ea7fcda0"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a3b295cc747301e51d3db5e93ea7fcda0">More...</a><br/></td></tr>
<tr class="separator:a3b295cc747301e51d3db5e93ea7fcda0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69651a9c886c553141bd60169326fe4d"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a69651a9c886c553141bd60169326fe4d" translate="no">addPolygon</a> (<a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;vertexArray, double polyTolerance, bool mergeVertices=true, double pointTolerance=kMFnMeshPointTolerance, bool forceGeometry=true, <a class="el" href="./class_m_object.html" translate="no">MObject</a> parentOrOwner=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a69651a9c886c553141bd60169326fe4d"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a69651a9c886c553141bd60169326fe4d">More...</a><br/></td></tr>
<tr class="separator:a69651a9c886c553141bd60169326fe4d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a46bb7238028e644ff17ecdfc5f372f40"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a46bb7238028e644ff17ecdfc5f372f40" translate="no">intersect</a> (<a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;raySource, <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;rayDirection, <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;points, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a46bb7238028e644ff17ecdfc5f372f40"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a46bb7238028e644ff17ecdfc5f372f40">More...</a><br/></td></tr>
<tr class="separator:a46bb7238028e644ff17ecdfc5f372f40"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4408f6f06fc5c2f6a1d1e752461fd6d6"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a4408f6f06fc5c2f6a1d1e752461fd6d6" translate="no">intersect</a> (const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp;raySource, const <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp;rayDirection, <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp;points, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a4408f6f06fc5c2f6a1d1e752461fd6d6"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a4408f6f06fc5c2f6a1d1e752461fd6d6">More...</a><br/></td></tr>
<tr class="separator:a4408f6f06fc5c2f6a1d1e752461fd6d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adb7faf3cbbec47a35785b39b856a943f"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#adb7faf3cbbec47a35785b39b856a943f" translate="no">getBlindDataAttrNames</a> (int blindDataId, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;longNames, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;shortNames) const </td></tr>
<tr class="memdesc:adb7faf3cbbec47a35785b39b856a943f"><td class="mdescLeft"> </td><td class="mdescRight">Get the blind data attribute names for the specified blind data type id.  <a href="class_m_fn_mesh.html#adb7faf3cbbec47a35785b39b856a943f">More...</a><br/></td></tr>
<tr class="separator:adb7faf3cbbec47a35785b39b856a943f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a821fdbfed9826ff767a5a10ac967c2cb"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a821fdbfed9826ff767a5a10ac967c2cb" translate="no">hasBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a821fdbfed9826ff767a5a10ac967c2cb"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a821fdbfed9826ff767a5a10ac967c2cb">More...</a><br/></td></tr>
<tr class="separator:a821fdbfed9826ff767a5a10ac967c2cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a168464d97542736ee90ced3390fe9e16"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a168464d97542736ee90ced3390fe9e16" translate="no">hasBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a168464d97542736ee90ced3390fe9e16"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a168464d97542736ee90ced3390fe9e16">More...</a><br/></td></tr>
<tr class="separator:a168464d97542736ee90ced3390fe9e16"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9cd4c10fe30b80798d8e9585bfa44783"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9cd4c10fe30b80798d8e9585bfa44783" translate="no">createUVSet</a> (<a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;uvSetName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> *instances=NULL)</td></tr>
<tr class="memdesc:a9cd4c10fe30b80798d8e9585bfa44783"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a9cd4c10fe30b80798d8e9585bfa44783">More...</a><br/></td></tr>
<tr class="separator:a9cd4c10fe30b80798d8e9585bfa44783"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a963207996df5420b2689472d61849326"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a963207996df5420b2689472d61849326" translate="no">copyUVSet</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;fromName, <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;toName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL)</td></tr>
<tr class="memdesc:a963207996df5420b2689472d61849326"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a963207996df5420b2689472d61849326">More...</a><br/></td></tr>
<tr class="separator:a963207996df5420b2689472d61849326"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a63d1cbfe5459d728ec2594ccf9baf5a4"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a63d1cbfe5459d728ec2594ccf9baf5a4" translate="no">getCurrentUVSetName</a> (<a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a386bb83443e16a98e6fa10c683e76b6c" translate="no">setName</a>, int instance=kMFnMeshInstanceUnspecified) const </td></tr>
<tr class="memdesc:a63d1cbfe5459d728ec2594ccf9baf5a4"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a63d1cbfe5459d728ec2594ccf9baf5a4">More...</a><br/></td></tr>
<tr class="separator:a63d1cbfe5459d728ec2594ccf9baf5a4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16cc4ceddccecaa8c5872271cdfc6cdb"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a16cc4ceddccecaa8c5872271cdfc6cdb" translate="no">createColorSet</a> (<a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSetName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier=NULL, const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> *instances=NULL)</td></tr>
<tr class="memdesc:a16cc4ceddccecaa8c5872271cdfc6cdb"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a16cc4ceddccecaa8c5872271cdfc6cdb">More...</a><br/></td></tr>
<tr class="separator:a16cc4ceddccecaa8c5872271cdfc6cdb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a063d856ba751854f745c381891037444"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a063d856ba751854f745c381891037444" translate="no">createColorSet</a> (<a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;colorSetName, <a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> *modifier, bool clamped, <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> rep, const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> *instances=NULL)</td></tr>
<tr class="memdesc:a063d856ba751854f745c381891037444"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a063d856ba751854f745c381891037444">More...</a><br/></td></tr>
<tr class="separator:a063d856ba751854f745c381891037444"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaf39117dff642a4a76ded73ed7c60f46"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aaf39117dff642a4a76ded73ed7c60f46" translate="no">getCurrentColorSetName</a> (<a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a386bb83443e16a98e6fa10c683e76b6c" translate="no">setName</a>, int instance=kMFnMeshInstanceUnspecified) const </td></tr>
<tr class="memdesc:aaf39117dff642a4a76ded73ed7c60f46"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#aaf39117dff642a4a76ded73ed7c60f46">More...</a><br/></td></tr>
<tr class="separator:aaf39117dff642a4a76ded73ed7c60f46"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a29014da3ce4d288534c1eba3bde78664"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a29014da3ce4d288534c1eba3bde78664" translate="no">getStringBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;data) const </td></tr>
<tr class="memdesc:a29014da3ce4d288534c1eba3bde78664"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#a29014da3ce4d288534c1eba3bde78664">More...</a><br/></td></tr>
<tr class="separator:a29014da3ce4d288534c1eba3bde78664"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acb8efa2513ca72e9f115ba0b46e72982"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#acb8efa2513ca72e9f115ba0b46e72982" translate="no">getBinaryBlindData</a> (int compID, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, int blindDataId, <a class="el" href="./class_m_string.html" translate="no">MString</a> attrName, <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;data) const </td></tr>
<tr class="memdesc:acb8efa2513ca72e9f115ba0b46e72982"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#acb8efa2513ca72e9f115ba0b46e72982">More...</a><br/></td></tr>
<tr class="separator:acb8efa2513ca72e9f115ba0b46e72982"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeaf96cd731c1b624e3829abed4bad786"><td align="right" class="memItemLeft" translate="no" valign="top">virtual const <a class="el" href="./classadsk_1_1_data_1_1_associations.html" translate="no">adsk::Data::Associations</a> * </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aeaf96cd731c1b624e3829abed4bad786" translate="no">metadata</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aeaf96cd731c1b624e3829abed4bad786"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python. </b> <a href="class_m_fn_mesh.html#aeaf96cd731c1b624e3829abed4bad786">More...</a><br/></td></tr>
<tr class="separator:aeaf96cd731c1b624e3829abed4bad786"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67c91ff141e6ab94c0bc7d75da94719d"><td align="right" class="memItemLeft" translate="no" valign="top">virtual <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a67c91ff141e6ab94c0bc7d75da94719d" translate="no">setMetadata</a> (const <a class="el" href="./classadsk_1_1_data_1_1_associations.html" translate="no">adsk::Data::Associations</a> &amp;)</td></tr>
<tr class="memdesc:a67c91ff141e6ab94c0bc7d75da94719d"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python. </b> <a href="class_m_fn_mesh.html#a67c91ff141e6ab94c0bc7d75da94719d">More...</a><br/></td></tr>
<tr class="separator:a67c91ff141e6ab94c0bc7d75da94719d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a27d24e2641c379dad274e938cd33d2"><td align="right" class="memItemLeft" translate="no" valign="top">virtual <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a9a27d24e2641c379dad274e938cd33d2" translate="no">validateMetadata</a> (<a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;errors) const </td></tr>
<tr class="memdesc:a9a27d24e2641c379dad274e938cd33d2"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python. </b> <a href="class_m_fn_mesh.html#a9a27d24e2641c379dad274e938cd33d2">More...</a><br/></td></tr>
<tr class="separator:a9a27d24e2641c379dad274e938cd33d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_class_m_fn_dag_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_fn_dag_node')"><img alt="-" src="cpp_ref/closed.png"> Public Member Functions inherited from <a class="el" href="./class_m_fn_dag_node.html" translate="no">MFnDagNode</a></img></td></tr>
<tr class="memitem:ab3ba9a3f20938220e307a661ec529494 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">virtual </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ab3ba9a3f20938220e307a661ec529494" translate="no">~MFnDagNode</a> ()</td></tr>
<tr class="memdesc:ab3ba9a3f20938220e307a661ec529494 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Destructor.  <a href="class_m_fn_mesh.html#ab3ba9a3f20938220e307a661ec529494">More...</a><br/></td></tr>
<tr class="separator:ab3ba9a3f20938220e307a661ec529494 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d17a21e9877152fabfb789b340cc9b2 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a4d17a21e9877152fabfb789b340cc9b2" translate="no">MFnDagNode</a> ()</td></tr>
<tr class="memdesc:a4d17a21e9877152fabfb789b340cc9b2 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Class Constructor.  <a href="class_m_fn_mesh.html#a4d17a21e9877152fabfb789b340cc9b2">More...</a><br/></td></tr>
<tr class="separator:a4d17a21e9877152fabfb789b340cc9b2 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad1f0f5024c648322dbf8b0c6307faf32 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ad1f0f5024c648322dbf8b0c6307faf32" translate="no">MFnDagNode</a> (<a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ret=NULL)</td></tr>
<tr class="memdesc:ad1f0f5024c648322dbf8b0c6307faf32 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python.</b> <a href="class_m_fn_mesh.html#ad1f0f5024c648322dbf8b0c6307faf32">More...</a><br/></td></tr>
<tr class="separator:ad1f0f5024c648322dbf8b0c6307faf32 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4431e9a65bf7d309ec68cc4f2bed88cd inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a4431e9a65bf7d309ec68cc4f2bed88cd" translate="no">MFnDagNode</a> (const <a class="el" href="./class_m_dag_path.html" translate="no">MDagPath</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ret=NULL)</td></tr>
<tr class="memdesc:a4431e9a65bf7d309ec68cc4f2bed88cd inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Class Constructor.  <a href="class_m_fn_mesh.html#a4431e9a65bf7d309ec68cc4f2bed88cd">More...</a><br/></td></tr>
<tr class="separator:a4431e9a65bf7d309ec68cc4f2bed88cd inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8e6386aae3f6b5342032683f0db91d2 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ad8e6386aae3f6b5342032683f0db91d2" translate="no">create</a> (const <a class="el" href="./class_m_type_id.html" translate="no">MTypeId</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135" translate="no">typeId</a>, <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_dag_node.html#a7ad7d0a5ce859ac89e4bdfcc3148eb94" translate="no">parent</a>=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ad8e6386aae3f6b5342032683f0db91d2 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new DAG node with the given type tag.  <a href="class_m_fn_mesh.html#ad8e6386aae3f6b5342032683f0db91d2">More...</a><br/></td></tr>
<tr class="separator:ad8e6386aae3f6b5342032683f0db91d2 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acd5e0a6283757053eb557eaaaf10f525 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#acd5e0a6283757053eb557eaaaf10f525" translate="no">create</a> (const <a class="el" href="./class_m_type_id.html" translate="no">MTypeId</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135" translate="no">typeId</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_dag_node.html#a7ad7d0a5ce859ac89e4bdfcc3148eb94" translate="no">parent</a>=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:acd5e0a6283757053eb557eaaaf10f525 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new DAG node with the given type tag.  <a href="class_m_fn_mesh.html#acd5e0a6283757053eb557eaaaf10f525">More...</a><br/></td></tr>
<tr class="separator:acd5e0a6283757053eb557eaaaf10f525 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8a2da3b2418d4e7eadfc55fe7cc7a10e inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a8a2da3b2418d4e7eadfc55fe7cc7a10e" translate="no">create</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dag_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>, <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_dag_node.html#a7ad7d0a5ce859ac89e4bdfcc3148eb94" translate="no">parent</a>=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a8a2da3b2418d4e7eadfc55fe7cc7a10e inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new DAG node with the given type tag.  <a href="class_m_fn_mesh.html#a8a2da3b2418d4e7eadfc55fe7cc7a10e">More...</a><br/></td></tr>
<tr class="separator:a8a2da3b2418d4e7eadfc55fe7cc7a10e inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a17f95ef370ff89bd8df3568ace038cf0 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a17f95ef370ff89bd8df3568ace038cf0" translate="no">create</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dag_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_dag_node.html#a7ad7d0a5ce859ac89e4bdfcc3148eb94" translate="no">parent</a>=<a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a17f95ef370ff89bd8df3568ace038cf0 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new DAG node with the given type tag.  <a href="class_m_fn_mesh.html#a17f95ef370ff89bd8df3568ace038cf0">More...</a><br/></td></tr>
<tr class="separator:a17f95ef370ff89bd8df3568ace038cf0 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36d4f04f316d615a7d0af771a91016b9 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">unsigned int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a36d4f04f316d615a7d0af771a91016b9" translate="no">parentCount</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a36d4f04f316d615a7d0af771a91016b9 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the number of parent Nodes of the Node.  <a href="class_m_fn_mesh.html#a36d4f04f316d615a7d0af771a91016b9">More...</a><br/></td></tr>
<tr class="separator:a36d4f04f316d615a7d0af771a91016b9 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7ad7d0a5ce859ac89e4bdfcc3148eb94 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a7ad7d0a5ce859ac89e4bdfcc3148eb94" translate="no">parent</a> (unsigned int i, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a7ad7d0a5ce859ac89e4bdfcc3148eb94 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Queries the DAG Node attached to the Function Set for the parent Node corresponding to the given index.  <a href="class_m_fn_mesh.html#a7ad7d0a5ce859ac89e4bdfcc3148eb94">More...</a><br/></td></tr>
<tr class="separator:a7ad7d0a5ce859ac89e4bdfcc3148eb94 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2df898f9f9030e2c111c41d8dd90887 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ac2df898f9f9030e2c111c41d8dd90887" translate="no">addChild</a> (<a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_dag_node.html#aaba05ce0a6791c69b8c850afaeb3bf67" translate="no">child</a>, unsigned int index=<a class="el" href="./class_m_fn_dag_node.html#a0411cd49bb5b71852cecd93bcbf0ca2dacaa5b6082c10b02e2da670d9a0cbf13e" translate="no">kNextPos</a>, bool keepExistingParents=false)</td></tr>
<tr class="memdesc:ac2df898f9f9030e2c111c41d8dd90887 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Makes the given DAG Node a child of the DAG Node to which this instance of the Function Set is attached.  <a href="class_m_fn_mesh.html#ac2df898f9f9030e2c111c41d8dd90887">More...</a><br/></td></tr>
<tr class="separator:ac2df898f9f9030e2c111c41d8dd90887 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a30dbd585925d76328afe7ba4c96423a1 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a30dbd585925d76328afe7ba4c96423a1" translate="no">removeChild</a> (<a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_dag_node.html#aaba05ce0a6791c69b8c850afaeb3bf67" translate="no">child</a>)</td></tr>
<tr class="memdesc:a30dbd585925d76328afe7ba4c96423a1 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Removes the given DAG Node from the parent.  <a href="class_m_fn_mesh.html#a30dbd585925d76328afe7ba4c96423a1">More...</a><br/></td></tr>
<tr class="separator:a30dbd585925d76328afe7ba4c96423a1 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3eb816cdc49eece8f8ce54202dd008e inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ac3eb816cdc49eece8f8ce54202dd008e" translate="no">removeChildAt</a> (unsigned int index)</td></tr>
<tr class="memdesc:ac3eb816cdc49eece8f8ce54202dd008e inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Removes the child at the given index from the parent.  <a href="class_m_fn_mesh.html#ac3eb816cdc49eece8f8ce54202dd008e">More...</a><br/></td></tr>
<tr class="separator:ac3eb816cdc49eece8f8ce54202dd008e inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c6cdc0f5380b205fcf6e524e307b47f inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">unsigned int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a7c6cdc0f5380b205fcf6e524e307b47f" translate="no">childCount</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a7c6cdc0f5380b205fcf6e524e307b47f inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the number of child Nodes of the Node.  <a href="class_m_fn_mesh.html#a7c6cdc0f5380b205fcf6e524e307b47f">More...</a><br/></td></tr>
<tr class="separator:a7c6cdc0f5380b205fcf6e524e307b47f inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaba05ce0a6791c69b8c850afaeb3bf67 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#aaba05ce0a6791c69b8c850afaeb3bf67" translate="no">child</a> (unsigned int i, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aaba05ce0a6791c69b8c850afaeb3bf67 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Queries the DAG Node attached to the Function Set for the child Node corresponding to the given index.  <a href="class_m_fn_mesh.html#aaba05ce0a6791c69b8c850afaeb3bf67">More...</a><br/></td></tr>
<tr class="separator:aaba05ce0a6791c69b8c850afaeb3bf67 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9294bc937d4544754de3f8d6cd0eb233 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a9294bc937d4544754de3f8d6cd0eb233" translate="no">dagRoot</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a9294bc937d4544754de3f8d6cd0eb233 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the root of the first DAG Path to the DAG Node attached to the Function Set.  <a href="class_m_fn_mesh.html#a9294bc937d4544754de3f8d6cd0eb233">More...</a><br/></td></tr>
<tr class="separator:a9294bc937d4544754de3f8d6cd0eb233 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae44174b85fc62850f863823a9f9f418f inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ae44174b85fc62850f863823a9f9f418f" translate="no">hasParent</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;node, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ae44174b85fc62850f863823a9f9f418f inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the given Node is a parent of the DAG Node attached to the Function Set.  <a href="class_m_fn_mesh.html#ae44174b85fc62850f863823a9f9f418f">More...</a><br/></td></tr>
<tr class="separator:ae44174b85fc62850f863823a9f9f418f inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a59dfb5113547bc4cb73fb1c030d3c6b9 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a59dfb5113547bc4cb73fb1c030d3c6b9" translate="no">hasChild</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;node, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a59dfb5113547bc4cb73fb1c030d3c6b9 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the given Node is a child of the DAG Node attached to the Function Set.  <a href="class_m_fn_mesh.html#a59dfb5113547bc4cb73fb1c030d3c6b9">More...</a><br/></td></tr>
<tr class="separator:a59dfb5113547bc4cb73fb1c030d3c6b9 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1ed8580ddc4046557612745812564a7 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ab1ed8580ddc4046557612745812564a7" translate="no">isChildOf</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;node, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ab1ed8580ddc4046557612745812564a7 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the DAG Node attached to the Function Set is a child of the given node.  <a href="class_m_fn_mesh.html#ab1ed8580ddc4046557612745812564a7">More...</a><br/></td></tr>
<tr class="separator:ab1ed8580ddc4046557612745812564a7 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afcdebae60da551fd16379fd296ffa1e3 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#afcdebae60da551fd16379fd296ffa1e3" translate="no">isParentOf</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;node, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:afcdebae60da551fd16379fd296ffa1e3 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the DAG Node attached to the Function Set is a parent of the given node.  <a href="class_m_fn_mesh.html#afcdebae60da551fd16379fd296ffa1e3">More...</a><br/></td></tr>
<tr class="separator:afcdebae60da551fd16379fd296ffa1e3 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6560236e7c4d96c12d4857db4acf5be inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#af6560236e7c4d96c12d4857db4acf5be" translate="no">inUnderWorld</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:af6560236e7c4d96c12d4857db4acf5be inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the DAG Node is an underworld node.  <a href="class_m_fn_mesh.html#af6560236e7c4d96c12d4857db4acf5be">More...</a><br/></td></tr>
<tr class="separator:af6560236e7c4d96c12d4857db4acf5be inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8c9eac0df7d5672e934e29c6e0fd9f50 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a8c9eac0df7d5672e934e29c6e0fd9f50" translate="no">inModel</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a8c9eac0df7d5672e934e29c6e0fd9f50 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the DAG Node is in the model.  <a href="class_m_fn_mesh.html#a8c9eac0df7d5672e934e29c6e0fd9f50">More...</a><br/></td></tr>
<tr class="separator:a8c9eac0df7d5672e934e29c6e0fd9f50 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85ff9eda577684602d17e1cb0c6da5bb inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a85ff9eda577684602d17e1cb0c6da5bb" translate="no">isInstanceable</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a85ff9eda577684602d17e1cb0c6da5bb inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if the DAG node can be instanced, and false otherwise.  <a href="class_m_fn_mesh.html#a85ff9eda577684602d17e1cb0c6da5bb">More...</a><br/></td></tr>
<tr class="separator:a85ff9eda577684602d17e1cb0c6da5bb inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7d3433cd48319932741738911292095 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ac7d3433cd48319932741738911292095" translate="no">setInstanceable</a> (const bool how)</td></tr>
<tr class="memdesc:ac7d3433cd48319932741738911292095 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets whether or not the DAG node is instanceable.  <a href="class_m_fn_mesh.html#ac7d3433cd48319932741738911292095">More...</a><br/></td></tr>
<tr class="separator:ac7d3433cd48319932741738911292095 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a7ad65572dca3e5cbeab283ffc9c90b inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a6a7ad65572dca3e5cbeab283ffc9c90b" translate="no">isInstanced</a> (bool indirect=true, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a6a7ad65572dca3e5cbeab283ffc9c90b inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether the DAG Node attached to the Function Set is directly or indirectly instanced.  <a href="class_m_fn_mesh.html#a6a7ad65572dca3e5cbeab283ffc9c90b">More...</a><br/></td></tr>
<tr class="separator:a6a7ad65572dca3e5cbeab283ffc9c90b inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb5c6940c8ee72d99efd274ac6fad6b1 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#aeb5c6940c8ee72d99efd274ac6fad6b1" translate="no">isInstancedAttribute</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aeb5c6940c8ee72d99efd274ac6fad6b1 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if the specified attribute is instanced.  <a href="class_m_fn_mesh.html#aeb5c6940c8ee72d99efd274ac6fad6b1">More...</a><br/></td></tr>
<tr class="separator:aeb5c6940c8ee72d99efd274ac6fad6b1 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb6d7f0ad7224cf9134a6a32a1e4261e inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">unsigned int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#aeb6d7f0ad7224cf9134a6a32a1e4261e" translate="no">instanceCount</a> (bool total, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aeb6d7f0ad7224cf9134a6a32a1e4261e inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the number of times the Node attached to the Function Set is instanced.  <a href="class_m_fn_mesh.html#aeb6d7f0ad7224cf9134a6a32a1e4261e">More...</a><br/></td></tr>
<tr class="separator:aeb6d7f0ad7224cf9134a6a32a1e4261e inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac1abc89bd329c4b2d1794cc8b971ea7b inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ac1abc89bd329c4b2d1794cc8b971ea7b" translate="no">duplicate</a> (bool instance=false, bool instanceLeaf=false, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ac1abc89bd329c4b2d1794cc8b971ea7b inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">This method duplicates the DAG hierarchy rooted at the current node.  <a href="class_m_fn_mesh.html#ac1abc89bd329c4b2d1794cc8b971ea7b">More...</a><br/></td></tr>
<tr class="separator:ac1abc89bd329c4b2d1794cc8b971ea7b inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adfb40b1f56af23ad94c4ca77c9a147b5 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#adfb40b1f56af23ad94c4ca77c9a147b5" translate="no">getPath</a> (<a class="el" href="./class_m_dag_path.html" translate="no">MDagPath</a> &amp;path) const </td></tr>
<tr class="memdesc:adfb40b1f56af23ad94c4ca77c9a147b5 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns a DAG Path to the DAG Node attached to the Function Set.  <a href="class_m_fn_mesh.html#adfb40b1f56af23ad94c4ca77c9a147b5">More...</a><br/></td></tr>
<tr class="separator:adfb40b1f56af23ad94c4ca77c9a147b5 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5144d66e53014e4bd907b5be1165f95e inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a5144d66e53014e4bd907b5be1165f95e" translate="no">getAllPaths</a> (<a class="el" href="./class_m_dag_path_array.html" translate="no">MDagPathArray</a> &amp;paths) const </td></tr>
<tr class="memdesc:a5144d66e53014e4bd907b5be1165f95e inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines all DAG Paths to the DAG Node attached to the Function Set.  <a href="class_m_fn_mesh.html#a5144d66e53014e4bd907b5be1165f95e">More...</a><br/></td></tr>
<tr class="separator:a5144d66e53014e4bd907b5be1165f95e inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac4b316731c4019c927aa63731d4749e8 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ac4b316731c4019c927aa63731d4749e8" translate="no">fullPathName</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ac4b316731c4019c927aa63731d4749e8 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Return a string representing the full path from the root of the dag to this object.  <a href="class_m_fn_mesh.html#ac4b316731c4019c927aa63731d4749e8">More...</a><br/></td></tr>
<tr class="separator:ac4b316731c4019c927aa63731d4749e8 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6e9ba8c60415451d03d26e01accaca81 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a6e9ba8c60415451d03d26e01accaca81" translate="no">partialPathName</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a6e9ba8c60415451d03d26e01accaca81 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Return a string representing the partial path from the root of the dag to this object.  <a href="class_m_fn_mesh.html#a6e9ba8c60415451d03d26e01accaca81">More...</a><br/></td></tr>
<tr class="separator:a6e9ba8c60415451d03d26e01accaca81 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a178b42ca425d71d2cf6d99ec3f2aaeb9 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_matrix.html" translate="no">MMatrix</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a178b42ca425d71d2cf6d99ec3f2aaeb9" translate="no">transformationMatrix</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a178b42ca425d71d2cf6d99ec3f2aaeb9 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the object space transformation matrix for this DAG node.  <a href="class_m_fn_mesh.html#a178b42ca425d71d2cf6d99ec3f2aaeb9">More...</a><br/></td></tr>
<tr class="separator:a178b42ca425d71d2cf6d99ec3f2aaeb9 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7293b39df2aa5ccfe5ffa7f483fffcae inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a7293b39df2aa5ccfe5ffa7f483fffcae" translate="no">isIntermediateObject</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a7293b39df2aa5ccfe5ffa7f483fffcae inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if this object is an intermediate in a geometry calculation.  <a href="class_m_fn_mesh.html#a7293b39df2aa5ccfe5ffa7f483fffcae">More...</a><br/></td></tr>
<tr class="separator:a7293b39df2aa5ccfe5ffa7f483fffcae inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a80b189c417a52f8ce696b0aa978a72a6 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a80b189c417a52f8ce696b0aa978a72a6" translate="no">setIntermediateObject</a> (bool isIntermediate)</td></tr>
<tr class="memdesc:a80b189c417a52f8ce696b0aa978a72a6 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets whether this object is an intermediate in a geometry calculation.  <a href="class_m_fn_mesh.html#a80b189c417a52f8ce696b0aa978a72a6">More...</a><br/></td></tr>
<tr class="separator:a80b189c417a52f8ce696b0aa978a72a6 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2760ddeb13fdb4c12a386454a7c7af50 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a2760ddeb13fdb4c12a386454a7c7af50" translate="no">objectColor</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a2760ddeb13fdb4c12a386454a7c7af50 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#a2760ddeb13fdb4c12a386454a7c7af50">More...</a><br/></td></tr>
<tr class="separator:a2760ddeb13fdb4c12a386454a7c7af50 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a170c1a7555e3703601957c2f5b6a1d32 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a170c1a7555e3703601957c2f5b6a1d32" translate="no">setObjectColor</a> (int color)</td></tr>
<tr class="memdesc:a170c1a7555e3703601957c2f5b6a1d32 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets the index for the current user defined inactive color used by the node.  <a href="class_m_fn_mesh.html#a170c1a7555e3703601957c2f5b6a1d32">More...</a><br/></td></tr>
<tr class="separator:a170c1a7555e3703601957c2f5b6a1d32 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6a57cc523bd8f59b1c0bf9388d2e2e4 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#af6a57cc523bd8f59b1c0bf9388d2e2e4" translate="no">usingObjectColor</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="separator:af6a57cc523bd8f59b1c0bf9388d2e2e4 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa8645538f23b220ccbdfe5eb25728452 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#aa8645538f23b220ccbdfe5eb25728452" translate="no">setUseObjectColor</a> (bool useObjectColor)</td></tr>
<tr class="separator:aa8645538f23b220ccbdfe5eb25728452 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa87de71b2fbd8b2c88178c0cbe6328df inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_fn_dag_node.html#a3a431d228bde7f6f439c661e3caa224d" translate="no">MObjectColorType</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#aa87de71b2fbd8b2c88178c0cbe6328df" translate="no">objectColorType</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aa87de71b2fbd8b2c88178c0cbe6328df inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the user defined inactive color will be used for the node, or whether the default inactive color will be used.  <a href="class_m_fn_mesh.html#aa87de71b2fbd8b2c88178c0cbe6328df">More...</a><br/></td></tr>
<tr class="separator:aa87de71b2fbd8b2c88178c0cbe6328df inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5f1d0f1f48c6728a9c1d3391df9365e8 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a5f1d0f1f48c6728a9c1d3391df9365e8" translate="no">setObjectColorType</a> (<a class="el" href="./class_m_fn_dag_node.html#a3a431d228bde7f6f439c661e3caa224d" translate="no">MObjectColorType</a> <a class="el" href="./class_m_fn_dag_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>)</td></tr>
<tr class="memdesc:a5f1d0f1f48c6728a9c1d3391df9365e8 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets whether or not the user defined inactive object color will be used.  <a href="class_m_fn_mesh.html#a5f1d0f1f48c6728a9c1d3391df9365e8">More...</a><br/></td></tr>
<tr class="separator:a5f1d0f1f48c6728a9c1d3391df9365e8 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adcee01ee529a8fdfffc3de713873dc01 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#adcee01ee529a8fdfffc3de713873dc01" translate="no">setObjectColor</a> (const <a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color)</td></tr>
<tr class="memdesc:adcee01ee529a8fdfffc3de713873dc01 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets the color value for the current user defined inactive color used by the node.  <a href="class_m_fn_mesh.html#adcee01ee529a8fdfffc3de713873dc01">More...</a><br/></td></tr>
<tr class="separator:adcee01ee529a8fdfffc3de713873dc01 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac004fcfb67830f8a842ee43d958d156b inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_color.html" translate="no">MColor</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ac004fcfb67830f8a842ee43d958d156b" translate="no">objectColorRGB</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ac004fcfb67830f8a842ee43d958d156b inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the RGB color for the current user defined inactive color used by the node.  <a href="class_m_fn_mesh.html#ac004fcfb67830f8a842ee43d958d156b">More...</a><br/></td></tr>
<tr class="separator:ac004fcfb67830f8a842ee43d958d156b inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a66da22331bc7e9c0bbff90d489d039aa inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a66da22331bc7e9c0bbff90d489d039aa" translate="no">objectColorIndex</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a66da22331bc7e9c0bbff90d489d039aa inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the index for the current user defined inactive color used by the node.  <a href="class_m_fn_mesh.html#a66da22331bc7e9c0bbff90d489d039aa">More...</a><br/></td></tr>
<tr class="separator:a66da22331bc7e9c0bbff90d489d039aa inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab4b5280533ebe636e26701929b8cb916 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_color.html" translate="no">MColor</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ab4b5280533ebe636e26701929b8cb916" translate="no">hiliteColor</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ab4b5280533ebe636e26701929b8cb916 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the current hilite color used by the node.  <a href="class_m_fn_mesh.html#ab4b5280533ebe636e26701929b8cb916">More...</a><br/></td></tr>
<tr class="separator:ab4b5280533ebe636e26701929b8cb916 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad9fdaa5e3e5601e6227d178c5c5599b6 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ad9fdaa5e3e5601e6227d178c5c5599b6" translate="no">usingHiliteColor</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ad9fdaa5e3e5601e6227d178c5c5599b6 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the hilite color will be used for the node.  <a href="class_m_fn_mesh.html#ad9fdaa5e3e5601e6227d178c5c5599b6">More...</a><br/></td></tr>
<tr class="separator:ad9fdaa5e3e5601e6227d178c5c5599b6 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b39d61bc9de696b4bebf838e0bd74d2 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_color.html" translate="no">MColor</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a6b39d61bc9de696b4bebf838e0bd74d2" translate="no">dormantColor</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a6b39d61bc9de696b4bebf838e0bd74d2 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the dormant color used by this node.  <a href="class_m_fn_mesh.html#a6b39d61bc9de696b4bebf838e0bd74d2">More...</a><br/></td></tr>
<tr class="separator:a6b39d61bc9de696b4bebf838e0bd74d2 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8c0a6ac5a75609946dc02fc640b60428 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_color.html" translate="no">MColor</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a8c0a6ac5a75609946dc02fc640b60428" translate="no">activeColor</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a8c0a6ac5a75609946dc02fc640b60428 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the active color used by this node.  <a href="class_m_fn_mesh.html#a8c0a6ac5a75609946dc02fc640b60428">More...</a><br/></td></tr>
<tr class="separator:a8c0a6ac5a75609946dc02fc640b60428 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4aa93724de5d167003a864c49b77efb3 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a4aa93724de5d167003a864c49b77efb3" translate="no">drawOverrideEnabled</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a4aa93724de5d167003a864c49b77efb3 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not draw override is turned on for this node.  <a href="class_m_fn_mesh.html#a4aa93724de5d167003a864c49b77efb3">More...</a><br/></td></tr>
<tr class="separator:a4aa93724de5d167003a864c49b77efb3 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2377542aa822b472fdfb105d8c77ebbc inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a2377542aa822b472fdfb105d8c77ebbc" translate="no">drawOverrideIsReference</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a2377542aa822b472fdfb105d8c77ebbc inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not Display Type of the draw override is Reference for this node.  <a href="class_m_fn_mesh.html#a2377542aa822b472fdfb105d8c77ebbc">More...</a><br/></td></tr>
<tr class="separator:a2377542aa822b472fdfb105d8c77ebbc inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0fbcccb257989b5a78f58cc3a64f3ed8 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a0fbcccb257989b5a78f58cc3a64f3ed8" translate="no">drawOverrideIsTemplate</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a0fbcccb257989b5a78f58cc3a64f3ed8 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not Display Type of the draw override is Template for this node.  <a href="class_m_fn_mesh.html#a0fbcccb257989b5a78f58cc3a64f3ed8">More...</a><br/></td></tr>
<tr class="separator:a0fbcccb257989b5a78f58cc3a64f3ed8 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1e1ccf92c7cb10c833d43b42b5ae5ca3 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a1e1ccf92c7cb10c833d43b42b5ae5ca3" translate="no">drawOverrideColor</a> (<a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp;color, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a1e1ccf92c7cb10c833d43b42b5ae5ca3 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines the draw override color used by this node.  <a href="class_m_fn_mesh.html#a1e1ccf92c7cb10c833d43b42b5ae5ca3">More...</a><br/></td></tr>
<tr class="separator:a1e1ccf92c7cb10c833d43b42b5ae5ca3 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae19de6f173f69f8753fdca910e208dc7 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ae19de6f173f69f8753fdca910e208dc7" translate="no">getConnectedSetsAndMembers</a> (unsigned int instanceNumber, <a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp;sets, <a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp;comps, bool renderableSetsOnly) const </td></tr>
<tr class="memdesc:ae19de6f173f69f8753fdca910e208dc7 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns all the sets connected to the specified instance of this DAG object.  <a href="class_m_fn_mesh.html#ae19de6f173f69f8753fdca910e208dc7">More...</a><br/></td></tr>
<tr class="separator:ae19de6f173f69f8753fdca910e208dc7 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9efd77281910086e293d68b2ea568663 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_bounding_box.html" translate="no">MBoundingBox</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a9efd77281910086e293d68b2ea568663" translate="no">boundingBox</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a9efd77281910086e293d68b2ea568663 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the bounding box for the dag node in object space.  <a href="class_m_fn_mesh.html#a9efd77281910086e293d68b2ea568663">More...</a><br/></td></tr>
<tr class="separator:a9efd77281910086e293d68b2ea568663 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac9c499ea694bc8d3391ff9d925e78ae1 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_dag_path.html" translate="no">MDagPath</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ac9c499ea694bc8d3391ff9d925e78ae1" translate="no">dagPath</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ac9c499ea694bc8d3391ff9d925e78ae1 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the DagPath to which the Function Set is attached.  <a href="class_m_fn_mesh.html#ac9c499ea694bc8d3391ff9d925e78ae1">More...</a><br/></td></tr>
<tr class="separator:ac9c499ea694bc8d3391ff9d925e78ae1 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b2301b53683a8e8f56dd0b9cb088b0f inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">virtual <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a6b2301b53683a8e8f56dd0b9cb088b0f" translate="no">setObject</a> (const <a class="el" href="./class_m_dag_path.html" translate="no">MDagPath</a> &amp;path)</td></tr>
<tr class="memdesc:a6b2301b53683a8e8f56dd0b9cb088b0f inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Attaches Function Set to the DAG Node that has the given DAG Path.  <a href="class_m_fn_mesh.html#a6b2301b53683a8e8f56dd0b9cb088b0f">More...</a><br/></td></tr>
<tr class="separator:a6b2301b53683a8e8f56dd0b9cb088b0f inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad09f5acece0f9926b3e0e55cff78c3be inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">virtual <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#ad09f5acece0f9926b3e0e55cff78c3be" translate="no">setObject</a> (<a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>)</td></tr>
<tr class="memdesc:ad09f5acece0f9926b3e0e55cff78c3be inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">Attaches Function Set to given DAG Node.  <a href="class_m_fn_mesh.html#ad09f5acece0f9926b3e0e55cff78c3be">More...</a><br/></td></tr>
<tr class="separator:ad09f5acece0f9926b3e0e55cff78c3be inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b660972547cfd37af923d643e6c5dcb inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a5b660972547cfd37af923d643e6c5dcb" translate="no">model</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a5b660972547cfd37af923d643e6c5dcb inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#a5b660972547cfd37af923d643e6c5dcb">More...</a><br/></td></tr>
<tr class="separator:a5b660972547cfd37af923d643e6c5dcb inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a617394a6eeb84eb29fb60a7b181ee0e8 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a617394a6eeb84eb29fb60a7b181ee0e8" translate="no">MFnDagNode</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ret=NULL)</td></tr>
<tr class="memdesc:a617394a6eeb84eb29fb60a7b181ee0e8 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">No script support.  <a href="class_m_fn_mesh.html#a617394a6eeb84eb29fb60a7b181ee0e8">More...</a><br/></td></tr>
<tr class="separator:a617394a6eeb84eb29fb60a7b181ee0e8 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a6adbb56d6259860ec665ab5d86bdb5 inherit pub_methods_class_m_fn_dag_node"><td align="right" class="memItemLeft" translate="no" valign="top">virtual <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dag_node.html#a4a6adbb56d6259860ec665ab5d86bdb5" translate="no">setObject</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>)</td></tr>
<tr class="memdesc:a4a6adbb56d6259860ec665ab5d86bdb5 inherit pub_methods_class_m_fn_dag_node"><td class="mdescLeft"> </td><td class="mdescRight">No script support.  <a href="class_m_fn_mesh.html#a4a6adbb56d6259860ec665ab5d86bdb5">More...</a><br/></td></tr>
<tr class="separator:a4a6adbb56d6259860ec665ab5d86bdb5 inherit pub_methods_class_m_fn_dag_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_class_m_fn_dependency_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_fn_dependency_node')"><img alt="-" src="cpp_ref/closed.png"> Public Member Functions inherited from <a class="el" href="./class_m_fn_dependency_node.html" translate="no">MFnDependencyNode</a></img></td></tr>
<tr class="memitem:ac96b310b7d0baa35f9dd9b386dc16e46 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="anchor" id="ac96b310b7d0baa35f9dd9b386dc16e46"></a>
virtual </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ac96b310b7d0baa35f9dd9b386dc16e46" translate="no">~MFnDependencyNode</a> ()</td></tr>
<tr class="memdesc:ac96b310b7d0baa35f9dd9b386dc16e46 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:ac96b310b7d0baa35f9dd9b386dc16e46 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a97bddbd69b9daef0731551d416d51525 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="anchor" id="a97bddbd69b9daef0731551d416d51525"></a>
 </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a97bddbd69b9daef0731551d416d51525" translate="no">MFnDependencyNode</a> ()</td></tr>
<tr class="memdesc:a97bddbd69b9daef0731551d416d51525 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a97bddbd69b9daef0731551d416d51525 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7d38bf5b71920ad1fbb339079a27c6e inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ab7d38bf5b71920ad1fbb339079a27c6e" translate="no">MFnDependencyNode</a> (<a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ab7d38bf5b71920ad1fbb339079a27c6e inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Constructor.  <a href="class_m_fn_mesh.html#ab7d38bf5b71920ad1fbb339079a27c6e">More...</a><br/></td></tr>
<tr class="separator:ab7d38bf5b71920ad1fbb339079a27c6e inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aae69364b2e9c744f9e36acb18dccaf30 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#aae69364b2e9c744f9e36acb18dccaf30" translate="no">create</a> (const <a class="el" href="./class_m_type_id.html" translate="no">MTypeId</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135" translate="no">typeId</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:aae69364b2e9c744f9e36acb18dccaf30 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new dependency node with the given type tag.  <a href="class_m_fn_mesh.html#aae69364b2e9c744f9e36acb18dccaf30">More...</a><br/></td></tr>
<tr class="separator:aae69364b2e9c744f9e36acb18dccaf30 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b042b0d7fd2476efa9f08f83188adb5 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a7b042b0d7fd2476efa9f08f83188adb5" translate="no">create</a> (const <a class="el" href="./class_m_type_id.html" translate="no">MTypeId</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135" translate="no">typeId</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a7b042b0d7fd2476efa9f08f83188adb5 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new dependency node with the given type tag.  <a href="class_m_fn_mesh.html#a7b042b0d7fd2476efa9f08f83188adb5">More...</a><br/></td></tr>
<tr class="separator:a7b042b0d7fd2476efa9f08f83188adb5 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad9dc7ac865d4529903155e39fc0848d0 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ad9dc7ac865d4529903155e39fc0848d0" translate="no">create</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ad9dc7ac865d4529903155e39fc0848d0 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new dependency node with the given type.  <a href="class_m_fn_mesh.html#ad9dc7ac865d4529903155e39fc0848d0">More...</a><br/></td></tr>
<tr class="separator:ad9dc7ac865d4529903155e39fc0848d0 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b237e334764997ef144bb93a14c51cb inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a5b237e334764997ef144bb93a14c51cb" translate="no">create</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a5b237e334764997ef144bb93a14c51cb inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new dependency node with the given type.  <a href="class_m_fn_mesh.html#a5b237e334764997ef144bb93a14c51cb">More...</a><br/></td></tr>
<tr class="separator:a5b237e334764997ef144bb93a14c51cb inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d0bbd4d50dae591f8e003c0aedc8135 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_type_id.html" translate="no">MTypeId</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135" translate="no">typeId</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a1d0bbd4d50dae591f8e003c0aedc8135 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the type id of this node.  <a href="class_m_fn_mesh.html#a1d0bbd4d50dae591f8e003c0aedc8135">More...</a><br/></td></tr>
<tr class="separator:a1d0bbd4d50dae591f8e003c0aedc8135 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a895d4516a7ad8b46fabddf057865ae94 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a895d4516a7ad8b46fabddf057865ae94" translate="no">typeName</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a895d4516a7ad8b46fabddf057865ae94 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the type name of this node.  <a href="class_m_fn_mesh.html#a895d4516a7ad8b46fabddf057865ae94">More...</a><br/></td></tr>
<tr class="separator:a895d4516a7ad8b46fabddf057865ae94 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a049384adbea0396ea2f03d1ad4d69df1 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a049384adbea0396ea2f03d1ad4d69df1 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this node.  <a href="class_m_fn_mesh.html#a049384adbea0396ea2f03d1ad4d69df1">More...</a><br/></td></tr>
<tr class="separator:a049384adbea0396ea2f03d1ad4d69df1 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a14ae19db432d68e75abf249ecbf82307 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a14ae19db432d68e75abf249ecbf82307" translate="no">absoluteName</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a14ae19db432d68e75abf249ecbf82307 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the absolute name of this node.  <a href="class_m_fn_mesh.html#a14ae19db432d68e75abf249ecbf82307">More...</a><br/></td></tr>
<tr class="separator:a14ae19db432d68e75abf249ecbf82307 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a01ba6bd4421513c932893ebeeef233f5 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a01ba6bd4421513c932893ebeeef233f5" translate="no">pluginName</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a01ba6bd4421513c932893ebeeef233f5 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of the plug-in this MFnDependendencyNode was defined in.  <a href="class_m_fn_mesh.html#a01ba6bd4421513c932893ebeeef233f5">More...</a><br/></td></tr>
<tr class="separator:a01ba6bd4421513c932893ebeeef233f5 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a386bb83443e16a98e6fa10c683e76b6c inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a386bb83443e16a98e6fa10c683e76b6c" translate="no">setName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, bool createNamespace=false, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a386bb83443e16a98e6fa10c683e76b6c inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets the name of this node.  <a href="class_m_fn_mesh.html#a386bb83443e16a98e6fa10c683e76b6c">More...</a><br/></td></tr>
<tr class="separator:a386bb83443e16a98e6fa10c683e76b6c inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a985f6747fe491d93740f7c0e54f0bbcb inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_uuid.html" translate="no">MUuid</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a985f6747fe491d93740f7c0e54f0bbcb" translate="no">uuid</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a985f6747fe491d93740f7c0e54f0bbcb inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the node's UUID.  <a href="class_m_fn_mesh.html#a985f6747fe491d93740f7c0e54f0bbcb">More...</a><br/></td></tr>
<tr class="separator:a985f6747fe491d93740f7c0e54f0bbcb inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a814dfeb0249b1d049a7c324c484ab86f inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">void </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a814dfeb0249b1d049a7c324c484ab86f" translate="no">setUuid</a> (const <a class="el" href="./class_m_uuid.html" translate="no">MUuid</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a985f6747fe491d93740f7c0e54f0bbcb" translate="no">uuid</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a814dfeb0249b1d049a7c324c484ab86f inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets the node's UUID.  <a href="class_m_fn_mesh.html#a814dfeb0249b1d049a7c324c484ab86f">More...</a><br/></td></tr>
<tr class="separator:a814dfeb0249b1d049a7c324c484ab86f inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8f45152f514fbdab917691ba6e10e5ae inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a8f45152f514fbdab917691ba6e10e5ae" translate="no">getConnections</a> (<a class="el" href="./class_m_plug_array.html" translate="no">MPlugArray</a> &amp;array) const </td></tr>
<tr class="memdesc:a8f45152f514fbdab917691ba6e10e5ae inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Get all of the current connections to this node as an array of plugs.  <a href="class_m_fn_mesh.html#a8f45152f514fbdab917691ba6e10e5ae">More...</a><br/></td></tr>
<tr class="separator:a8f45152f514fbdab917691ba6e10e5ae inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af762f251eae844405571ed86ab9d1509 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">unsigned int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#af762f251eae844405571ed86ab9d1509" translate="no">attributeCount</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:af762f251eae844405571ed86ab9d1509 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of attributes that this node has.  <a href="class_m_fn_mesh.html#af762f251eae844405571ed86ab9d1509">More...</a><br/></td></tr>
<tr class="separator:af762f251eae844405571ed86ab9d1509 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6117a63ae3bb2d03aa976dc8732d93a5 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a6117a63ae3bb2d03aa976dc8732d93a5" translate="no">attribute</a> (unsigned int index, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a6117a63ae3bb2d03aa976dc8732d93a5 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Finds the attribute of this node at the given index.  <a href="class_m_fn_mesh.html#a6117a63ae3bb2d03aa976dc8732d93a5">More...</a><br/></td></tr>
<tr class="separator:a6117a63ae3bb2d03aa976dc8732d93a5 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a23304041268bb12da5e5f05be5103f1f inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a23304041268bb12da5e5f05be5103f1f" translate="no">reorderedAttribute</a> (unsigned int index, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a23304041268bb12da5e5f05be5103f1f inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Some nodes, such as the various animCurve nodes, require that their attributes be set in a specific order for proper operation.  <a href="class_m_fn_mesh.html#a23304041268bb12da5e5f05be5103f1f">More...</a><br/></td></tr>
<tr class="separator:a23304041268bb12da5e5f05be5103f1f inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acc822d97061e3f4aaec00172b713e413 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#acc822d97061e3f4aaec00172b713e413" translate="no">attribute</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;attrName, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:acc822d97061e3f4aaec00172b713e413 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Finds the attribute of this node that has the given name.  <a href="class_m_fn_mesh.html#acc822d97061e3f4aaec00172b713e413">More...</a><br/></td></tr>
<tr class="separator:acc822d97061e3f4aaec00172b713e413 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad629db615b4ae99ddb4099f3c61370d0 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0" translate="no">MAttrClass</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ad629db615b4ae99ddb4099f3c61370d0" translate="no">attributeClass</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ad629db615b4ae99ddb4099f3c61370d0 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the class (normal, dynamic, extension) of the specified attribute.  <a href="class_m_fn_mesh.html#ad629db615b4ae99ddb4099f3c61370d0">More...</a><br/></td></tr>
<tr class="separator:ad629db615b4ae99ddb4099f3c61370d0 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67fbad8061ac9362ed5549449a376f67 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a67fbad8061ac9362ed5549449a376f67" translate="no">getAffectedAttributes</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, <a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp;affectedAttributes) const </td></tr>
<tr class="memdesc:a67fbad8061ac9362ed5549449a376f67 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns an array of attributes that are affected by the attribute passed in.  <a href="class_m_fn_mesh.html#a67fbad8061ac9362ed5549449a376f67">More...</a><br/></td></tr>
<tr class="separator:a67fbad8061ac9362ed5549449a376f67 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0a5201e171945d154d69950a75b21fba inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a0a5201e171945d154d69950a75b21fba" translate="no">getAffectedByAttributes</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, <a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp;affectedByAttributes) const </td></tr>
<tr class="memdesc:a0a5201e171945d154d69950a75b21fba inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns an array of attributes that affect the attribute passed in, <em>attr</em>.  <a href="class_m_fn_mesh.html#a0a5201e171945d154d69950a75b21fba">More...</a><br/></td></tr>
<tr class="separator:a0a5201e171945d154d69950a75b21fba inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aac29b4a3b51c9d236175e955638f7153 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_plug.html" translate="no">MPlug</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153" translate="no">findPlug</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, bool wantNetworkedPlug, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aac29b4a3b51c9d236175e955638f7153 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Attempt to find a plug for the given attribute.  <a href="class_m_fn_mesh.html#aac29b4a3b51c9d236175e955638f7153">More...</a><br/></td></tr>
<tr class="separator:aac29b4a3b51c9d236175e955638f7153 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3fb7e255fe8fc23da004c673a06e7a7f inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_plug.html" translate="no">MPlug</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a3fb7e255fe8fc23da004c673a06e7a7f" translate="no">findPlug</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;attrName, bool wantNetworkedPlug, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a3fb7e255fe8fc23da004c673a06e7a7f inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Attempt to find a plug for the given attribute.  <a href="class_m_fn_mesh.html#a3fb7e255fe8fc23da004c673a06e7a7f">More...</a><br/></td></tr>
<tr class="separator:a3fb7e255fe8fc23da004c673a06e7a7f inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad6251d0cc84e81086fe7656875126b48 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_plug.html" translate="no">MPlug</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ad6251d0cc84e81086fe7656875126b48" translate="no">findPlug</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ad6251d0cc84e81086fe7656875126b48 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#ad6251d0cc84e81086fe7656875126b48">More...</a><br/></td></tr>
<tr class="separator:ad6251d0cc84e81086fe7656875126b48 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2568d4c649bd8f25f96df954dd59badf inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_plug.html" translate="no">MPlug</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a2568d4c649bd8f25f96df954dd59badf" translate="no">findPlug</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;attrName, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a2568d4c649bd8f25f96df954dd59badf inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#a2568d4c649bd8f25f96df954dd59badf">More...</a><br/></td></tr>
<tr class="separator:a2568d4c649bd8f25f96df954dd59badf inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a837094252166c0b365fafb53e4a0203b inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a837094252166c0b365fafb53e4a0203b" translate="no">addAttribute</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr)</td></tr>
<tr class="memdesc:a837094252166c0b365fafb53e4a0203b inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Add a new dynamic attibute to this node.  <a href="class_m_fn_mesh.html#a837094252166c0b365fafb53e4a0203b">More...</a><br/></td></tr>
<tr class="separator:a837094252166c0b365fafb53e4a0203b inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a07ac2233e719287c3f13a63d00bf63b0 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a07ac2233e719287c3f13a63d00bf63b0" translate="no">removeAttribute</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr)</td></tr>
<tr class="memdesc:a07ac2233e719287c3f13a63d00bf63b0 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Remove a dynamic attribute from a node.  <a href="class_m_fn_mesh.html#a07ac2233e719287c3f13a63d00bf63b0">More...</a><br/></td></tr>
<tr class="separator:a07ac2233e719287c3f13a63d00bf63b0 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4f2c53c9d1dcf25a6462c70fb25aead1 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_px_node.html" translate="no">MPxNode</a> * </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a4f2c53c9d1dcf25a6462c70fb25aead1" translate="no">userNode</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a4f2c53c9d1dcf25a6462c70fb25aead1 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">If the function set's node is a plug-in node, then this method will extract the <a class="el" href="./class_m_px_node.html" title="Base class for user defined dependency nodes. " translate="no">MPxNode</a> pointer from it.  <a href="class_m_fn_mesh.html#a4f2c53c9d1dcf25a6462c70fb25aead1">More...</a><br/></td></tr>
<tr class="separator:a4f2c53c9d1dcf25a6462c70fb25aead1 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a831907d371e0ce9df483aaac543ab1f3 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a831907d371e0ce9df483aaac543ab1f3" translate="no">isFromReferencedFile</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a831907d371e0ce9df483aaac543ab1f3 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether or not this node came from a referenced file.  <a href="class_m_fn_mesh.html#a831907d371e0ce9df483aaac543ab1f3">More...</a><br/></td></tr>
<tr class="separator:a831907d371e0ce9df483aaac543ab1f3 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6edf59334859b393aa91788e10f37dd6 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a6edf59334859b393aa91788e10f37dd6" translate="no">isShared</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a6edf59334859b393aa91788e10f37dd6 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether or not this node is shared.  <a href="class_m_fn_mesh.html#a6edf59334859b393aa91788e10f37dd6">More...</a><br/></td></tr>
<tr class="separator:a6edf59334859b393aa91788e10f37dd6 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf0b0c43c1773a6d0431bc86dd54245e inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#abf0b0c43c1773a6d0431bc86dd54245e" translate="no">isTrackingEdits</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:abf0b0c43c1773a6d0431bc86dd54245e inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns whether or not edits on the given node are being tracked by the generalized edit system.  <a href="class_m_fn_mesh.html#abf0b0c43c1773a6d0431bc86dd54245e">More...</a><br/></td></tr>
<tr class="separator:abf0b0c43c1773a6d0431bc86dd54245e inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae482e56641ea79c1656a51fcd548f9aa inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ae482e56641ea79c1656a51fcd548f9aa" translate="no">hasUniqueName</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:ae482e56641ea79c1656a51fcd548f9aa inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether or not this node's name is unique within the scene.  <a href="class_m_fn_mesh.html#ae482e56641ea79c1656a51fcd548f9aa">More...</a><br/></td></tr>
<tr class="separator:ae482e56641ea79c1656a51fcd548f9aa inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc7c921f383b3c4d207d44e3f04d87f7 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#adc7c921f383b3c4d207d44e3f04d87f7" translate="no">parentNamespace</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:adc7c921f383b3c4d207d44e3f04d87f7 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of the namespace in which this node resides.  <a href="class_m_fn_mesh.html#adc7c921f383b3c4d207d44e3f04d87f7">More...</a><br/></td></tr>
<tr class="separator:adc7c921f383b3c4d207d44e3f04d87f7 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a213498fb2178052452ce8e0a323d2e5c inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a213498fb2178052452ce8e0a323d2e5c" translate="no">isLocked</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a213498fb2178052452ce8e0a323d2e5c inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether or not this node is locked.  <a href="class_m_fn_mesh.html#a213498fb2178052452ce8e0a323d2e5c">More...</a><br/></td></tr>
<tr class="separator:a213498fb2178052452ce8e0a323d2e5c inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0eb2f4f3be6845848e546709e1410be2 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a0eb2f4f3be6845848e546709e1410be2" translate="no">setLocked</a> (bool locked)</td></tr>
<tr class="memdesc:a0eb2f4f3be6845848e546709e1410be2 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Locks or unlocks this node.  <a href="class_m_fn_mesh.html#a0eb2f4f3be6845848e546709e1410be2">More...</a><br/></td></tr>
<tr class="separator:a0eb2f4f3be6845848e546709e1410be2 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af44c7ca5bf1702fa32971208e6de3aaf inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#af44c7ca5bf1702fa32971208e6de3aaf" translate="no">isNewAttribute</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:af44c7ca5bf1702fa32971208e6de3aaf inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether or not the specified attribute was added to this node within the current scene.  <a href="class_m_fn_mesh.html#af44c7ca5bf1702fa32971208e6de3aaf">More...</a><br/></td></tr>
<tr class="separator:af44c7ca5bf1702fa32971208e6de3aaf inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acad856458f6209f89f472217669d2f41 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#acad856458f6209f89f472217669d2f41" translate="no">setFlag</a> (unsigned int flag, bool state)</td></tr>
<tr class="memdesc:acad856458f6209f89f472217669d2f41 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets the <em>state</em> of the specified <em>flag</em> for the node.  <a href="class_m_fn_mesh.html#acad856458f6209f89f472217669d2f41">More...</a><br/></td></tr>
<tr class="separator:acad856458f6209f89f472217669d2f41 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a105e5fd029bab1aa51a211c4d988146e inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a105e5fd029bab1aa51a211c4d988146e" translate="no">isFlagSet</a> (unsigned int flag, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a105e5fd029bab1aa51a211c4d988146e inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Retrieves the current state of the specified <em>flag</em> for a node.  <a href="class_m_fn_mesh.html#a105e5fd029bab1aa51a211c4d988146e">More...</a><br/></td></tr>
<tr class="separator:a105e5fd029bab1aa51a211c4d988146e inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a68b1312c32163c811b22a0e18bdc1829 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a68b1312c32163c811b22a0e18bdc1829" translate="no">isDefaultNode</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a68b1312c32163c811b22a0e18bdc1829 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if the node is a default node.  <a href="class_m_fn_mesh.html#a68b1312c32163c811b22a0e18bdc1829">More...</a><br/></td></tr>
<tr class="separator:a68b1312c32163c811b22a0e18bdc1829 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02d5ad99659b3a4d33135ac436fbc162 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a02d5ad99659b3a4d33135ac436fbc162" translate="no">setDoNotWrite</a> (bool flag)</td></tr>
<tr class="memdesc:a02d5ad99659b3a4d33135ac436fbc162 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Use this method to mark the "do not write" state of this node.  <a href="class_m_fn_mesh.html#a02d5ad99659b3a4d33135ac436fbc162">More...</a><br/></td></tr>
<tr class="separator:a02d5ad99659b3a4d33135ac436fbc162 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8c56aba92965f98e40c307cc368c0b4e inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a8c56aba92965f98e40c307cc368c0b4e" translate="no">canBeWritten</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a8c56aba92965f98e40c307cc368c0b4e inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the do not write state of the node.  <a href="class_m_fn_mesh.html#a8c56aba92965f98e40c307cc368c0b4e">More...</a><br/></td></tr>
<tr class="separator:a8c56aba92965f98e40c307cc368c0b4e inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a62ffa50a6a1c929dc606648269f1d0fe inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a62ffa50a6a1c929dc606648269f1d0fe" translate="no">hasAttribute</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a62ffa50a6a1c929dc606648269f1d0fe inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if the node already has an attribute with the given name.  <a href="class_m_fn_mesh.html#a62ffa50a6a1c929dc606648269f1d0fe">More...</a><br/></td></tr>
<tr class="separator:a62ffa50a6a1c929dc606648269f1d0fe inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a90f3e7a094dd38db428c30fb35f9c4f0 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a90f3e7a094dd38db428c30fb35f9c4f0" translate="no">getAliasAttr</a> (bool force, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a90f3e7a094dd38db428c30fb35f9c4f0 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the node's alias attribute, which is a special attribute used to store information about the node's attribute aliases.  <a href="class_m_fn_mesh.html#a90f3e7a094dd38db428c30fb35f9c4f0">More...</a><br/></td></tr>
<tr class="separator:a90f3e7a094dd38db428c30fb35f9c4f0 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee34260ca9f0fac8f803d4d2d3ac96b1 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#aee34260ca9f0fac8f803d4d2d3ac96b1" translate="no">setAlias</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;alias, const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, const <a class="el" href="./class_m_plug.html" translate="no">MPlug</a> &amp;plug, bool add=true, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:aee34260ca9f0fac8f803d4d2d3ac96b1 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets or removes an alias (i.e.  <a href="class_m_fn_mesh.html#aee34260ca9f0fac8f803d4d2d3ac96b1">More...</a><br/></td></tr>
<tr class="separator:aee34260ca9f0fac8f803d4d2d3ac96b1 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aae7833e07a4687792b67dbedbf6c2866 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#aae7833e07a4687792b67dbedbf6c2866" translate="no">findAlias</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;alias, <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attrObj, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:aae7833e07a4687792b67dbedbf6c2866 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Retrieves the attribute with the given alias.  <a href="class_m_fn_mesh.html#aae7833e07a4687792b67dbedbf6c2866">More...</a><br/></td></tr>
<tr class="separator:aae7833e07a4687792b67dbedbf6c2866 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae746a1f4976e6cbe19ad8741b3729f9b inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ae746a1f4976e6cbe19ad8741b3729f9b" translate="no">getAliasList</a> (<a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;strArray, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ae746a1f4976e6cbe19ad8741b3729f9b inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns a list of all attribute aliases for this node.  <a href="class_m_fn_mesh.html#ae746a1f4976e6cbe19ad8741b3729f9b">More...</a><br/></td></tr>
<tr class="separator:ae746a1f4976e6cbe19ad8741b3729f9b inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae1f09699deeaf884ba979e73fa4f3e04 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ae1f09699deeaf884ba979e73fa4f3e04" translate="no">plugsAlias</a> (const <a class="el" href="./class_m_plug.html" translate="no">MPlug</a> &amp;plug, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ae1f09699deeaf884ba979e73fa4f3e04 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the alias for the plug's attribute or the empty string if that attribute has no alias.  <a href="class_m_fn_mesh.html#ae1f09699deeaf884ba979e73fa4f3e04">More...</a><br/></td></tr>
<tr class="separator:ae1f09699deeaf884ba979e73fa4f3e04 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a187c99648a70fc0c945e0510815ce38f inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a187c99648a70fc0c945e0510815ce38f" translate="no">setIcon</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;filename)</td></tr>
<tr class="memdesc:a187c99648a70fc0c945e0510815ce38f inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Associates a custom icon with the node for display in the Maya UI.  <a href="class_m_fn_mesh.html#a187c99648a70fc0c945e0510815ce38f">More...</a><br/></td></tr>
<tr class="separator:a187c99648a70fc0c945e0510815ce38f inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a10902916aefab3eee0ba6aae6421b955 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a10902916aefab3eee0ba6aae6421b955" translate="no">icon</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a10902916aefab3eee0ba6aae6421b955 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the custom icon filename associated with the node.  <a href="class_m_fn_mesh.html#a10902916aefab3eee0ba6aae6421b955">More...</a><br/></td></tr>
<tr class="separator:a10902916aefab3eee0ba6aae6421b955 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa1a11fdf2ff139b45c26b911c1a05ab4 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#aa1a11fdf2ff139b45c26b911c1a05ab4" translate="no">getExternalContent</a> (<a class="el" href="./class_m_external_content_info_table.html" translate="no">MExternalContentInfoTable</a> &amp;table) const </td></tr>
<tr class="memdesc:aa1a11fdf2ff139b45c26b911c1a05ab4 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the external content (files) that this node depends on.  <a href="class_m_fn_mesh.html#aa1a11fdf2ff139b45c26b911c1a05ab4">More...</a><br/></td></tr>
<tr class="separator:aa1a11fdf2ff139b45c26b911c1a05ab4 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0f029864ded30a68804ad666af52fd01 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a0f029864ded30a68804ad666af52fd01" translate="no">addExternalContentForFileAttr</a> (<a class="el" href="./class_m_external_content_info_table.html" translate="no">MExternalContentInfoTable</a> &amp;table, const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr) const </td></tr>
<tr class="memdesc:a0f029864ded30a68804ad666af52fd01 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Adds content info to the specified table from a file path attribute.  <a href="class_m_fn_mesh.html#a0f029864ded30a68804ad666af52fd01">More...</a><br/></td></tr>
<tr class="separator:a0f029864ded30a68804ad666af52fd01 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a54193b5ac963b2cd834aec221cb72d8b inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a54193b5ac963b2cd834aec221cb72d8b" translate="no">setExternalContentForFileAttr</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, const <a class="el" href="./class_m_external_content_location_table.html" translate="no">MExternalContentLocationTable</a> &amp;table)</td></tr>
<tr class="memdesc:a54193b5ac963b2cd834aec221cb72d8b inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets content info in the specified attribute from the table.  <a href="class_m_fn_mesh.html#a54193b5ac963b2cd834aec221cb72d8b">More...</a><br/></td></tr>
<tr class="separator:a54193b5ac963b2cd834aec221cb72d8b inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a18166c63efb09896671cb3bfdc4289f8 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a18166c63efb09896671cb3bfdc4289f8" translate="no">setExternalContent</a> (const <a class="el" href="./class_m_external_content_location_table.html" translate="no">MExternalContentLocationTable</a> &amp;table)</td></tr>
<tr class="memdesc:a18166c63efb09896671cb3bfdc4289f8 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Changes the location of external content.  <a href="class_m_fn_mesh.html#a18166c63efb09896671cb3bfdc4289f8">More...</a><br/></td></tr>
<tr class="separator:a18166c63efb09896671cb3bfdc4289f8 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7663c68acd32682094068b0689bada54 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a7663c68acd32682094068b0689bada54" translate="no">setName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;<a class="el" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1" translate="no">name</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus)</td></tr>
<tr class="memdesc:a7663c68acd32682094068b0689bada54 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">OBSOLETE FUNCTION, NO SCRIPT SUPPORT.  <a href="class_m_fn_mesh.html#a7663c68acd32682094068b0689bada54">More...</a><br/></td></tr>
<tr class="separator:a7663c68acd32682094068b0689bada54 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aace5d777b9c50031fc20edca586a7145 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#aace5d777b9c50031fc20edca586a7145" translate="no">MFnDependencyNode</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;<a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:aace5d777b9c50031fc20edca586a7145 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">NO SCRIPT SUPPORT.  <a href="class_m_fn_mesh.html#aace5d777b9c50031fc20edca586a7145">More...</a><br/></td></tr>
<tr class="separator:aace5d777b9c50031fc20edca586a7145 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a959e491f7099bfd3bc39a7290325d0e0 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a959e491f7099bfd3bc39a7290325d0e0" translate="no">getPlugsAlias</a> (const <a class="el" href="./class_m_plug.html" translate="no">MPlug</a> &amp;plug, <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;aliasName, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a959e491f7099bfd3bc39a7290325d0e0 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">NO SCRIPT SUPPORT.  <a href="class_m_fn_mesh.html#a959e491f7099bfd3bc39a7290325d0e0">More...</a><br/></td></tr>
<tr class="separator:a959e491f7099bfd3bc39a7290325d0e0 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a493ae4d7bf901a809180ce645d3ca23f inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">virtual <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a493ae4d7bf901a809180ce645d3ca23f" translate="no">deleteMetadata</a> ()</td></tr>
<tr class="memdesc:a493ae4d7bf901a809180ce645d3ca23f inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is not available in Python. </b> <a href="class_m_fn_mesh.html#a493ae4d7bf901a809180ce645d3ca23f">More...</a><br/></td></tr>
<tr class="separator:a493ae4d7bf901a809180ce645d3ca23f inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9df7a295e360f95fed2045e6e95ceb8c inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a9df7a295e360f95fed2045e6e95ceb8c" translate="no">dgTimerOn</a> ()</td></tr>
<tr class="memdesc:a9df7a295e360f95fed2045e6e95ceb8c inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Indicates that this node should collect DG timing data whenever DG timing is enabled.  <a href="class_m_fn_mesh.html#a9df7a295e360f95fed2045e6e95ceb8c">More...</a><br/></td></tr>
<tr class="separator:a9df7a295e360f95fed2045e6e95ceb8c inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7dec1fda96eea99af491ea54c03df1b5 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a7dec1fda96eea99af491ea54c03df1b5" translate="no">dgTimerOff</a> ()</td></tr>
<tr class="memdesc:a7dec1fda96eea99af491ea54c03df1b5 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Indicates that this node should no longer collect DG timing data when DG timing is enabled.  <a href="class_m_fn_mesh.html#a7dec1fda96eea99af491ea54c03df1b5">More...</a><br/></td></tr>
<tr class="separator:a7dec1fda96eea99af491ea54c03df1b5 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a11f4a861bb7f94b22946c76dc41447e7 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_fn_dependency_node.html#af67ab59a5df7d4b6a4551d1b4f95a7d8" translate="no">MdgTimerState</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a11f4a861bb7f94b22946c76dc41447e7" translate="no">dgTimerQueryState</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a11f4a861bb7f94b22946c76dc41447e7 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">The function returns the current on/off state of the node's timer.  <a href="class_m_fn_mesh.html#a11f4a861bb7f94b22946c76dc41447e7">More...</a><br/></td></tr>
<tr class="separator:a11f4a861bb7f94b22946c76dc41447e7 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c6f258e7b46541649b9df9ae66f7e65 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a4c6f258e7b46541649b9df9ae66f7e65" translate="no">dgTimerReset</a> ()</td></tr>
<tr class="memdesc:a4c6f258e7b46541649b9df9ae66f7e65 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">The function resets the dependency graph timers and counters for this node to zero.  <a href="class_m_fn_mesh.html#a4c6f258e7b46541649b9df9ae66f7e65">More...</a><br/></td></tr>
<tr class="separator:a4c6f258e7b46541649b9df9ae66f7e65 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4975877da99c76d816c0dd0c9d45b98c inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">double </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a4975877da99c76d816c0dd0c9d45b98c" translate="no">dgTimer</a> (const <a class="el" href="./class_m_fn_dependency_node.html#a583374b4d3ddd639bd008c68d2592ae5" translate="no">MdgTimerMetric</a> timerMetric, const <a class="el" href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1" translate="no">MdgTimerType</a> timerType, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a4975877da99c76d816c0dd0c9d45b98c inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">The function returns the specified timer value for the current node.  <a href="class_m_fn_mesh.html#a4975877da99c76d816c0dd0c9d45b98c">More...</a><br/></td></tr>
<tr class="separator:a4975877da99c76d816c0dd0c9d45b98c inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a95a447dd10cf484eae6cbddf01bd09b1 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a95a447dd10cf484eae6cbddf01bd09b1" translate="no">dgCallbacks</a> (const <a class="el" href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1" translate="no">MdgTimerType</a> <a class="el" href="./class_m_fn_dependency_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>, <a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp;callbackName, <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;value)</td></tr>
<tr class="memdesc:a95a447dd10cf484eae6cbddf01bd09b1 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Node callbacks that occur when timing is enabled get logged with the node and can be queried via this method.  <a href="class_m_fn_mesh.html#a95a447dd10cf484eae6cbddf01bd09b1">More...</a><br/></td></tr>
<tr class="separator:a95a447dd10cf484eae6cbddf01bd09b1 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ada466cc5ff206505aa5553a00a094ec9 inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ada466cc5ff206505aa5553a00a094ec9" translate="no">dgCallbackIds</a> (const <a class="el" href="./class_m_fn_dependency_node.html#a12e545677c0b06b58953d5f350832ae1" translate="no">MdgTimerType</a> <a class="el" href="./class_m_fn_dependency_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>, const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;callbackName, <a class="el" href="./class_m_callback_id_array.html" translate="no">MCallbackIdArray</a> &amp;callbackId, <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp;value)</td></tr>
<tr class="memdesc:ada466cc5ff206505aa5553a00a094ec9 inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">This method provides a further breakdown of the per-callback time returned via <a class="el" href="./class_m_fn_dependency_node.html#a95a447dd10cf484eae6cbddf01bd09b1" title="Node callbacks that occur when timing is enabled get logged with the node and can be queried via this..." translate="no">dgCallbacks()</a> by returning the data on a per-callbackId basis.  <a href="class_m_fn_mesh.html#ada466cc5ff206505aa5553a00a094ec9">More...</a><br/></td></tr>
<tr class="separator:ada466cc5ff206505aa5553a00a094ec9 inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf987b9e2952de7944afdab7f236943d inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#abf987b9e2952de7944afdab7f236943d" translate="no">addAttribute</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, <a class="el" href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0" translate="no">MAttrClass</a> <a class="el" href="./class_m_fn_dependency_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>)</td></tr>
<tr class="memdesc:abf987b9e2952de7944afdab7f236943d inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#abf987b9e2952de7944afdab7f236943d">More...</a><br/></td></tr>
<tr class="separator:abf987b9e2952de7944afdab7f236943d inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b1460a7a80a5cb57621e403914ee90d inherit pub_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a3b1460a7a80a5cb57621e403914ee90d" translate="no">removeAttribute</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;attr, <a class="el" href="./class_m_fn_dependency_node.html#a02f8ee0648b8421efbc74c67d840cac0" translate="no">MAttrClass</a> <a class="el" href="./class_m_fn_dependency_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">type</a>)</td></tr>
<tr class="memdesc:a3b1460a7a80a5cb57621e403914ee90d inherit pub_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight"><b>This method is obsolete.</b> <a href="class_m_fn_mesh.html#a3b1460a7a80a5cb57621e403914ee90d">More...</a><br/></td></tr>
<tr class="separator:a3b1460a7a80a5cb57621e403914ee90d inherit pub_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_class_m_fn_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_fn_base')"><img alt="-" src="cpp_ref/closed.png"> Public Member Functions inherited from <a class="el" href="./class_m_fn_base.html" translate="no">MFnBase</a></img></td></tr>
<tr class="memitem:a5ba621af875a0d489e1031eddac02b82 inherit pub_methods_class_m_fn_base"><td align="right" class="memItemLeft" translate="no" valign="top">virtual </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_base.html#a5ba621af875a0d489e1031eddac02b82" translate="no">~MFnBase</a> ()</td></tr>
<tr class="memdesc:a5ba621af875a0d489e1031eddac02b82 inherit pub_methods_class_m_fn_base"><td class="mdescLeft"> </td><td class="mdescRight">Class Destructor.  <a href="class_m_fn_mesh.html#a5ba621af875a0d489e1031eddac02b82">More...</a><br/></td></tr>
<tr class="separator:a5ba621af875a0d489e1031eddac02b82 inherit pub_methods_class_m_fn_base"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5f2479ff74d96fda6f7cd31ee4c1c463 inherit pub_methods_class_m_fn_base"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_base.html#a5f2479ff74d96fda6f7cd31ee4c1c463" translate="no">hasObj</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a>) const </td></tr>
<tr class="memdesc:a5f2479ff74d96fda6f7cd31ee4c1c463 inherit pub_methods_class_m_fn_base"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the Function Set is compatible with the specified Maya Object within the API RTTI system.  <a href="class_m_fn_mesh.html#a5f2479ff74d96fda6f7cd31ee4c1c463">More...</a><br/></td></tr>
<tr class="separator:a5f2479ff74d96fda6f7cd31ee4c1c463 inherit pub_methods_class_m_fn_base"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a28acbd3253b9c86a1e64b3457de9f4ea inherit pub_methods_class_m_fn_base"><td align="right" class="memItemLeft" translate="no" valign="top">bool </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_base.html#a28acbd3253b9c86a1e64b3457de9f4ea" translate="no">hasObj</a> (const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp;) const </td></tr>
<tr class="memdesc:a28acbd3253b9c86a1e64b3457de9f4ea inherit pub_methods_class_m_fn_base"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not the Function Set is compatible with the specified Maya Object within the API RTTI system.  <a href="class_m_fn_mesh.html#a28acbd3253b9c86a1e64b3457de9f4ea">More...</a><br/></td></tr>
<tr class="separator:a28acbd3253b9c86a1e64b3457de9f4ea inherit pub_methods_class_m_fn_base"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a01c802c0a7fc219b5a9beff9787bcfa2 inherit pub_methods_class_m_fn_base"><td align="right" class="memItemLeft" translate="no" valign="top"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2" translate="no">object</a> (<a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a01c802c0a7fc219b5a9beff9787bcfa2 inherit pub_methods_class_m_fn_base"><td class="mdescLeft"> </td><td class="mdescRight">Returns the <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> that is attached to the Function Set.  <a href="class_m_fn_mesh.html#a01c802c0a7fc219b5a9beff9787bcfa2">More...</a><br/></td></tr>
<tr class="separator:a01c802c0a7fc219b5a9beff9787bcfa2 inherit pub_methods_class_m_fn_base"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6935c5bb858e53b60ad6d04ab5025899"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a6935c5bb858e53b60ad6d04ab5025899" translate="no">uniformGridParams</a> (int xDiv, int yDiv, int zDiv)</td></tr>
<tr class="memdesc:a6935c5bb858e53b60ad6d04ab5025899"><td class="mdescLeft"> </td><td class="mdescRight">Creates a <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> configuration object that can be passed to several of the geometric query methods available on <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a>.  <a href="class_m_fn_mesh.html#a6935c5bb858e53b60ad6d04ab5025899">More...</a><br/></td></tr>
<tr class="separator:a6935c5bb858e53b60ad6d04ab5025899"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af405a2789178f0cc8e8609b7a1dd5b20"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#af405a2789178f0cc8e8609b7a1dd5b20" translate="no">autoUniformGridParams</a> ()</td></tr>
<tr class="memdesc:af405a2789178f0cc8e8609b7a1dd5b20"><td class="mdescLeft"> </td><td class="mdescRight">Creates a <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> configuration object that can be passed to several of the geometric query methods on <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> to speed up their operation.  <a href="class_m_fn_mesh.html#af405a2789178f0cc8e8609b7a1dd5b20">More...</a><br/></td></tr>
<tr class="separator:af405a2789178f0cc8e8609b7a1dd5b20"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acda309cf310fdac3ad08665c41a6bf7f"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#acda309cf310fdac3ad08665c41a6bf7f" translate="no">globalIntersectionAcceleratorsInfo</a> ()</td></tr>
<tr class="memdesc:acda309cf310fdac3ad08665c41a6bf7f"><td class="mdescLeft"> </td><td class="mdescRight">Retrieves a string that describes the systemwide resource usage for cached mesh intersection accelerators.  <a href="class_m_fn_mesh.html#acda309cf310fdac3ad08665c41a6bf7f">More...</a><br/></td></tr>
<tr class="separator:acda309cf310fdac3ad08665c41a6bf7f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16138ce87b1366bc78de69c05319c166"><td align="right" class="memItemLeft" translate="no" valign="top">static void </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a16138ce87b1366bc78de69c05319c166" translate="no">clearGlobalIntersectionAcceleratorInfo</a> ()</td></tr>
<tr class="memdesc:a16138ce87b1366bc78de69c05319c166"><td class="mdescLeft"> </td><td class="mdescRight">As described above, clears the "total count", "total build time", and "peak memory" fields from the information string returned by <a class="el" href="./class_m_fn_mesh.html#acda309cf310fdac3ad08665c41a6bf7f" title="Retrieves a string that describes the systemwide resource usage for cached mesh intersection accelera..." translate="no">globalIntersectionAcceleratorsInfo()</a>.  <a href="class_m_fn_mesh.html#a16138ce87b1366bc78de69c05319c166">More...</a><br/></td></tr>
<tr class="separator:a16138ce87b1366bc78de69c05319c166"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa4fef6442be0536d2316c00f2251ba29"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa4fef6442be0536d2316c00f2251ba29" translate="no">componentTypeName</a> (<a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> compType, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> &amp;status)</td></tr>
<tr class="memdesc:aa4fef6442be0536d2316c00f2251ba29"><td class="mdescLeft"> </td><td class="mdescRight">Get a string representing a particular component type.  <a href="class_m_fn_mesh.html#aa4fef6442be0536d2316c00f2251ba29">More...</a><br/></td></tr>
<tr class="separator:aa4fef6442be0536d2316c00f2251ba29"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8bcea1244d150d93ab3cf162d5219b74"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a8bcea1244d150d93ab3cf162d5219b74" translate="no">componentTypeFromName</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;assocName)</td></tr>
<tr class="memdesc:a8bcea1244d150d93ab3cf162d5219b74"><td class="mdescLeft"> </td><td class="mdescRight">Get a component type from its string name.  <a href="class_m_fn_mesh.html#a8bcea1244d150d93ab3cf162d5219b74">More...</a><br/></td></tr>
<tr class="separator:a8bcea1244d150d93ab3cf162d5219b74"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad48b6008bf77ccf6159cd6875a6ce0d9"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#ad48b6008bf77ccf6159cd6875a6ce0d9" translate="no">polyTriangulate</a> (const float *pointsAndHoles, unsigned int pointsCount, unsigned int outerPointsCount, unsigned int holesCount, bool considerNormal, const float *normals, unsigned short *triangles, int &amp;trianglesCount)</td></tr>
<tr class="memdesc:ad48b6008bf77ccf6159cd6875a6ce0d9"><td class="mdescLeft"> </td><td class="mdescRight">Triangulates a polygon.  <a href="class_m_fn_mesh.html#ad48b6008bf77ccf6159cd6875a6ce0d9">More...</a><br/></td></tr>
<tr class="separator:ad48b6008bf77ccf6159cd6875a6ce0d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a722ab78f04d7cde092fad106bd94b948"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#a722ab78f04d7cde092fad106bd94b948" translate="no">polyTriangulate</a> (const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp;points, const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;holes, unsigned int outerPointsCount, const <a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp;normals, <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp;triangles)</td></tr>
<tr class="memdesc:a722ab78f04d7cde092fad106bd94b948"><td class="mdescLeft"> </td><td class="mdescRight">Triangulates a polygon.  <a href="class_m_fn_mesh.html#a722ab78f04d7cde092fad106bd94b948">More...</a><br/></td></tr>
<tr class="separator:a722ab78f04d7cde092fad106bd94b948"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_static_methods_class_m_fn_dependency_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_fn_dependency_node')"><img alt="-" src="cpp_ref/closed.png"> Static Public Member Functions inherited from <a class="el" href="./class_m_fn_dependency_node.html" translate="no">MFnDependencyNode</a></img></td></tr>
<tr class="memitem:afa8bedf4debeff43054d3217a8990831 inherit pub_static_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_string.html" translate="no">MString</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#afa8bedf4debeff43054d3217a8990831" translate="no">classification</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp;nodeTypeName)</td></tr>
<tr class="memdesc:afa8bedf4debeff43054d3217a8990831 inherit pub_static_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Retrieves the <em>classification string</em> for a node type.  <a href="class_m_fn_mesh.html#afa8bedf4debeff43054d3217a8990831">More...</a><br/></td></tr>
<tr class="separator:afa8bedf4debeff43054d3217a8990831 inherit pub_static_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abae04fb2cd53d336a7ba30a26e4eb2af inherit pub_static_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">static unsigned int </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#abae04fb2cd53d336a7ba30a26e4eb2af" translate="no">allocateFlag</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> <a class="el" href="./class_m_fn_dependency_node.html#a01ba6bd4421513c932893ebeeef233f5" translate="no">pluginName</a>, <a class="el" href="./class_m_status.html" translate="no">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:abae04fb2cd53d336a7ba30a26e4eb2af inherit pub_static_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Allocates a node flag for sole use by the caller.  <a href="class_m_fn_mesh.html#abae04fb2cd53d336a7ba30a26e4eb2af">More...</a><br/></td></tr>
<tr class="separator:abae04fb2cd53d336a7ba30a26e4eb2af inherit pub_static_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7115d9ec3e4bba10a0b04eef2655b379 inherit pub_static_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a7115d9ec3e4bba10a0b04eef2655b379" translate="no">deallocateFlag</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> <a class="el" href="./class_m_fn_dependency_node.html#a01ba6bd4421513c932893ebeeef233f5" translate="no">pluginName</a>, unsigned int flag)</td></tr>
<tr class="memdesc:a7115d9ec3e4bba10a0b04eef2655b379 inherit pub_static_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Deallocates a node <em>flag</em> which was previously allocated by a call to <b>allocateFlag</b>.  <a href="class_m_fn_mesh.html#a7115d9ec3e4bba10a0b04eef2655b379">More...</a><br/></td></tr>
<tr class="separator:a7115d9ec3e4bba10a0b04eef2655b379 inherit pub_static_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a00234b2b22b451488785ac959c537357 inherit pub_static_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">static <a class="el" href="./class_m_status.html" translate="no">MStatus</a> </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#a00234b2b22b451488785ac959c537357" translate="no">deallocateAllFlags</a> (const <a class="el" href="./class_m_string.html" translate="no">MString</a> <a class="el" href="./class_m_fn_dependency_node.html#a01ba6bd4421513c932893ebeeef233f5" translate="no">pluginName</a>)</td></tr>
<tr class="memdesc:a00234b2b22b451488785ac959c537357 inherit pub_static_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Deallocates all of the node flags which are currently allocated to the specified plugin.  <a href="class_m_fn_mesh.html#a00234b2b22b451488785ac959c537357">More...</a><br/></td></tr>
<tr class="separator:a00234b2b22b451488785ac959c537357 inherit pub_static_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac536258db23a250e7d1a4692916b2132 inherit pub_static_methods_class_m_fn_dependency_node"><td align="right" class="memItemLeft" translate="no" valign="top">static void </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_dependency_node.html#ac536258db23a250e7d1a4692916b2132" translate="no">enableDGTiming</a> (bool enable)</td></tr>
<tr class="memdesc:ac536258db23a250e7d1a4692916b2132 inherit pub_static_methods_class_m_fn_dependency_node"><td class="mdescLeft"> </td><td class="mdescRight">Globally enables or disables the DG node timing mechanism.  <a href="class_m_fn_mesh.html#ac536258db23a250e7d1a4692916b2132">More...</a><br/></td></tr>
<tr class="separator:ac536258db23a250e7d1a4692916b2132 inherit pub_static_methods_class_m_fn_dependency_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_static_methods_class_m_fn_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_fn_base')"><img alt="-" src="cpp_ref/closed.png"> Static Public Member Functions inherited from <a class="el" href="./class_m_fn_base.html" translate="no">MFnBase</a></img></td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_fn_base"><td align="right" class="memItemLeft" translate="no" valign="top">static const char * </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_base.html#a774cd5d8fbebe8e7ed82a5aa587d1f04" translate="no">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_fn_base"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this class.  <a href="class_m_fn_mesh.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br/></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_fn_base"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa738bbefadab412b5cc9e600f5013322"><td align="right" class="memItemLeft" translate="no" valign="top">virtual const char * </td><td class="memItemRight" translate="no" valign="bottom"><a class="el" href="./class_m_fn_mesh.html#aa738bbefadab412b5cc9e600f5013322" translate="no">className</a> () const </td></tr>
<tr class="memdesc:aa738bbefadab412b5cc9e600f5013322"><td class="mdescLeft"> </td><td class="mdescRight">Class name.  <a href="class_m_fn_mesh.html#aa738bbefadab412b5cc9e600f5013322">More...</a><br/></td></tr>
<tr class="separator:aa738bbefadab412b5cc9e600f5013322"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a80dc8673cdbdbb813c71dfa32e0643f2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">enum <a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>Specifies which color components are used by a colorSet. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a80dc8673cdbdbb813c71dfa32e0643f2a1e1554ff20f693b1e84e28330320b237"></a>kAlpha </td><td class="fielddoc">
<p>Alpha only. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a80dc8673cdbdbb813c71dfa32e0643f2a8cadb7b1406f2e3233ddf5276c8c07ed"></a>kRGB </td><td class="fielddoc">
<p>Red, green and blue only. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a80dc8673cdbdbb813c71dfa32e0643f2a3c05b20237a36142d29e02c2141ce685"></a>kRGBA </td><td class="fielddoc">
<p>Red, green, blue and alpha. </p>
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a268415a8195ca8a7471a0dc2a611d105"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">enum <a class="el" href="./class_m_fn_mesh.html#a268415a8195ca8a7471a0dc2a611d105" translate="no">SplitPlacement</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>Specifies how a point along split is to be determined. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a268415a8195ca8a7471a0dc2a611d105a0bfc0edc789ffe2049b71e2ea8af262b"></a>kOnEdge </td><td class="fielddoc">
<p>Split at a position along an edge. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a268415a8195ca8a7471a0dc2a611d105a3ecd45a76462bc63dcc4117e6d2cc078"></a>kInternalPoint </td><td class="fielddoc">
<p>Split at a point within a face. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a268415a8195ca8a7471a0dc2a611d105a94dd08feda7b2cf0ff8262312c4fcc09"></a>kInvalid </td><td class="fielddoc">
<p>  </p>
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a4451c8eb916f7cae80bb690274643d8a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">enum <a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8a" translate="no">BoolOperation</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>Boolean operators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4451c8eb916f7cae80bb690274643d8aa6eb10237f8f0629e0a2e01771e7bda38"></a>kUnion </td><td class="fielddoc">
<p>Boolean union. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4451c8eb916f7cae80bb690274643d8aa1fe9ba39d04b5e63e535da32eb7804ac"></a>kDifference </td><td class="fielddoc">
<p>Boolean difference. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4451c8eb916f7cae80bb690274643d8aa2a9eac913399d5326aa7950a906b5c38"></a>kIntersection </td><td class="fielddoc">
<p>Boolean intersection. </p>
</td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad5f8a9596b2ead166fe200ccf8f03478"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no">~<a class="el" href="./class_m_fn_mesh.html" translate="no">MFnMesh</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>
<p>Class destructor. </p>
</div>
</div>
<a class="anchor" id="aa8ebe643258224ce9f9e281f0b922684"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="el" href="./class_m_fn_mesh.html" translate="no">MFnMesh</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp; </td>
<td class="paramname"><em>object</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>
<p>Class constructor that initializes the function set to the given <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> to attach the function set to </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>the return status</td></tr>
</table>
</dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> if the function set is successfully attached </li>
<li><b>MS::kInvalidParameter</b> if the <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> does not represent a valid Maya object or if the function set is not allowed to attach to this <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a45a8c2938873c91dd49861e752e1fb84"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="el" href="./class_m_fn_mesh.html" translate="no">MFnMesh</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_dag_path.html" translate="no">MDagPath</a> &amp; </td>
<td class="paramname"><em>object</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>
<p>Class constructor that initializes the function set to the given constant <a class="el" href="./class_m_dag_path.html" title="DAG Path. " translate="no">MDagPath</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The const <a class="el" href="./class_m_dag_path.html" title="DAG Path. " translate="no">MDagPath</a> to attach the function set to </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>The return status</td></tr>
</table>
</dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> if the function set is successfully attached </li>
<li><b>MS::kInvalidParameter</b> if the <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> does not represent a valid Maya object or if the function set is not allowed to attach to this <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a0c420e9ee0ab2b2368bb2c9506c586ff"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="el" href="./class_m_fn_mesh.html" translate="no">MFnMesh</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp; </td>
<td class="paramname"><em>object</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>
<p>Class constructor that initializes the function set to the given <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> to attach the function set to </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>the return status</td></tr>
</table>
</dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> if the function set is successfully attached </li>
<li><b>MS::kInvalidParameter</b> if the <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> does not represent a valid Maya object or if the function set is not allowed to attach to this <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. " translate="no">MObject</a> </li>
</ul>
</dd></dl>
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adc3250674414e8a0b2f4584959c6ec4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/type"></a><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> type </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Function set type. </p>
<p>Return the class type : <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62" title="  " translate="no">MFn::kMesh</a>. </p>
<p>Reimplemented from <a class="el" href="./class_m_fn_dag_node.html#adc3250674414e8a0b2f4584959c6ec4c" translate="no">MFnDagNode</a>.</p>
</div>
</div>
<a class="anchor" id="aa738bbefadab412b5cc9e600f5013322"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no">OPENMAYA_MAJOR_NAMESPACE_OPEN const char * className </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Class name. </p>
<p>Return the class name : "MFnMesh". </p>
<p>Reimplemented from <a class="el" href="./class_m_fn_dag_node.html#aa738bbefadab412b5cc9e600f5013322" translate="no">MFnDagNode</a>.</p>
</div>
</div>
<a class="anchor" id="af9b9e5d33d289134d567c62bad4ca3d5"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/create"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> create </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>numVertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>numPolygons</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonConnects</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a new polygonal mesh given an array of vertices and polygon connection information and sets this function set to operate on the new surface. </p>
<p>This method is meant to be as efficient as possible and thus assumes that all the given data is topologically correct.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">numVertices</td><td>number of vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">numPolygons</td><td>number of polygons </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonCounts</td><td>array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonConnects</td><td>array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4, 0, 4, 7, 1, 1, 7, 6, 2 } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>parent of the polygon that will be created </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> Array length does not match given item count; parentOrOwner was not valid; or there was no model present to add the object to </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example1" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example1-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example1-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_alembic_node_8cpp-example.html#a96" translate="no">AbcImport/AlembicNode.cpp</a>, <a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a31" translate="no">AbcImport/MeshHelper.cpp</a>, <a class="el" href="./anim_cube_node_2anim_cube_node_8cpp-example.html#a21" translate="no">animCubeNode/animCubeNode.cpp</a>, <a class="el" href="./blind_data_shader_2blind_data_mesh_8cpp-example.html#a16" translate="no">blindDataShader/blindDataMesh.cpp</a>, <a class="el" href="./poly_primitive_cmd_2poly_primitive_cmd_8cpp-example.html#a20" translate="no">polyPrimitiveCmd/polyPrimitiveCmd.cpp</a>, and <a class="el" href="./shell_node_2shell_node_8cpp-example.html#a21" translate="no">shellNode/shellNode.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a52ee98712c8f4460342b2fc5d91dba3b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/create"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> create </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>numVertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>numPolygons</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonConnects</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a new polygonal mesh given an array of vertices and polygon connection information and sets this function set to operate on the new surface. </p>
<p>This method is meant to be as efficient as possible and thus assumes that all the given data is topologically correct.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">numVertices</td><td>number of vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">numPolygons</td><td>number of polygons </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonCounts</td><td>array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonConnects</td><td>array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4,0, 4, 7, 1, 1, 7, 6, 2 } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>parent of the polygon that will be created </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> Array length does not match given item count; parentOrOwner was not valid; or there was no model present to add the object to </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad0eba420c55b35922afcc548f8571e90"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/create"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> create </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>numVertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>numPolygons</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonConnects</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>storeDoubles</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a new polygonal mesh given an array of vertices and polygon connection information and sets this function set to operate on the new surface. </p>
<p>This method is meant to be as efficient as possible and thus assumes that all the given data is topologically correct.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">numVertices</td><td>number of vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">numPolygons</td><td>number of polygons </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonCounts</td><td>array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonConnects</td><td>array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4,0, 4, 7, 1, 1, 7, 6, 2 } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">storeDoubles</td><td>Whether to store the vertex data at double precision internally. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>parent of the polygon that will be created </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> One of the following parameter errors</li>
</ul>
<ul>
<li>Array length does not match given item count </li>
<li>parentOrOwner was not valid </li>
<li>There was no model present to add the object to</li>
</ul>
<ul>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9a62e8586fb47fb49d10c9d36d3cf5df"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/create"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> create </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>numVertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>numPolygons</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonConnects</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>uArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>vArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a new polygonal mesh given an array of vertices, polygon connection information, UV information, and sets this function set to operate on the new surface. </p>
<p>This method is meant to be as efficient as possible and thus assumes that all the given data is topologically correct.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<p>The uv arrays must be of equal size. After using this method to create the mesh and the UV values, you can call assignUVs to assign the corresponding UV ids to the geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">numVertices</td><td>number of vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">numPolygons</td><td>number of polygons </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonCounts</td><td>array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonConnects</td><td>array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4,0, 4, 7, 1, 1, 7, 6, 2 } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uArray</td><td>The array of u values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vArray</td><td>The array of v values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>parent of the polygon that will be created </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> Array length does not match given item count; parentOrOwner was not valid; or there was no model present to add the object to </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa7aac5894b2e8964bb2722c26fac3edb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/create"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> create </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>numVertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>numPolygons</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonConnects</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>uArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>vArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a new polygonal mesh given an array of vertices, polygon connection information, UV information, and sets this function set to operate on the new surface. </p>
<p>This method is meant to be as efficient as possible and thus assumes that all the given data is topologically correct.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<p>The uv arrays must be of equal size. After using this method to create the mesh and the UV values, you can call assignUVs to assign the corresponding UV ids to the geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">numVertices</td><td>number of vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">numPolygons</td><td>number of polygons </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonCounts</td><td>array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonConnects</td><td>array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4,0, 4, 7, 1, 1, 7, 6, 2 } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uArray</td><td>The array of u values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vArray</td><td>The array of v values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>parent of the polygon that will be created </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> Array length does not match given item count; parentOrOwner was not valid; or there was no model present to add the object to </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ac843310c50ba6a4d18733db383c1cb74"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/create"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> create </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edges</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edgeConnectsCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edgeFaceConnects</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edgeFaceDesc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a new polygonal mesh given an array of vertices, edge information, polygon connection information, UV and sets this function set to operate on the new surface. </p>
<p>This method is meant to be as efficient as possible and thus assumes that all the given data is topologically correct.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>array of vertex indices that define the edges of the geometry. For example, the cube { (0,1), (1,2), (2,3), (3,0), (4,7), (7,6), (6,5), (5,4), (0,4), (1,7), (2,6), (3,5) } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">edgeConnectsCount</td><td>array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the edgeConnectsCount would be {4,4,4,4,4,4}. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">edgeFaceConnects</td><td>array of edge connections for each polygon. For example, in the cube, we have 4 edges for every face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edges array: e.g for the cube: { 0, 1, 2, 3, 1, 10, 5, 9, 2, 11, 6, 10, 3, 8, 7, 11, 0, 9, 4, 8, 4, 5, 6, 7 } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">edgeFaceDesc</td><td>array of edge direction populated by members of MFnMesh::MEdgeDirection defining if a given edge for a polygon is intended to be in its normal direction, or in the reverse direction. Example, for the cube: { 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0} </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>parent of the polygon that will be created </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> One of the following parameter errors</li>
</ul>
<ul>
<li>parentOrOwner was not valid </li>
<li>There was no model present to add the object to</li>
</ul>
<ul>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="acb7279765ccba9c472e0845fd91e437e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/generateSmoothMesh"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> generateSmoothMesh </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_mesh_smooth_options.html" translate="no">MMeshSmoothOptions</a> * </td>
<td class="paramname"><em>options</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a new polygonal mesh using either the Smooth Mesh Preview attributes of this mesh or a set of options specified in an <a class="el" href="./class_m_mesh_smooth_options.html" title="Options for control of smooth mesh generation. " translate="no">MMeshSmoothOptions</a> object. </p>
<p>Unlike the <a class="el" href="./class_m_fn_mesh.html#af9b9e5d33d289134d567c62bad4ca3d5" title="Creates a new polygonal mesh given an array of vertices and polygon connection information and sets t..." translate="no">MFnMesh::create</a> functions, this function does not set this function set to operate on the new surface.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>parent of the polygon that will be created </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Set of options to use when generating the smoothed mesh </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> parentOrOwner was not valid; or there was no model present to add the object to </li>
<li><b>MS::kFailure</b> An object error has occurred, or the mesh has no geometry to smooth. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5f8bfd632c7bbdc5bd34345699f2aa87"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getSmoothMeshDisplayOptions"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getSmoothMeshDisplayOptions </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_mesh_smooth_options.html" translate="no">MMeshSmoothOptions</a> &amp; </td>
<td class="paramname"><em>options</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieve the current display smoothing options for the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">options</td><td>storge for the options</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aab4749565ad2517f28b93599b2c05c96"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setSmoothMeshDisplayOptions"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setSmoothMeshDisplayOptions </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_mesh_smooth_options.html" translate="no">MMeshSmoothOptions</a> &amp; </td>
<td class="paramname"><em>options</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the current display smoothing options for the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5d9b2da1ced87d07152df74788558e07"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/addPolygon"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> addPolygon </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>mergeVertices</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>pointTolerance</em> = <code>kMFnMeshPointTolerance</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Adds a new polygon to this polygonal mesh. </p>
<p>If there is no current geometry then a new polygonal mesh is created and parentOrOwner is used to specify the owner of the new surface. If parentOrOwner is nullptr or a DAG parent is specified, then a new transform will be created in the DAG and returned. If the parentOrOwner is kMeshData then the new surface will become its data and the geometry will be returned.</p>
<p>If we are adding to an existing polygonal mesh then parentOrOwner is ignored and the geometry is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>array of ordered vertices that make up the polygon </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mergeVertices</td><td>If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointTolerance</td><td>specifies how close verticies have to be to before they are <em>merged</em>. This merging is only done if <em>mergeVerticies</em> is true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>the DAG parent or kMeshData the new surface will belong to </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transform if one is created, otherwise the geometry.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a6c1fe3ef6d0042ebb6ffb00b68bec287"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/addPolygon"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> addPolygon </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>mergeVertices</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>pointTolerance</em> = <code>kMFnMeshPointTolerance</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Adds a new polygon to this polygonal mesh. </p>
<p>Return an index of the created polygon.</p>
<p>If there is no current geometry then a new polygonal mesh is created and parentOrOwner is used to specify the owner of the new surface. If parentOrOwner is nullptr or a DAG parent is specified, then a new transform will be created in the DAG and returned. If the parentOrOwner is kMeshData then the new surface will become its data and the geometry will be returned.</p>
<p>If we are adding to an existing polygonal mesh then parentOrOwner is ignored and the geometry is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>Array of ordered vertices that make up the polygon. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">faceIndex</td><td>Index of the newly added polygon. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mergeVertices</td><td>If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointTolerance</td><td>Specifies how close verticies have to be to before they are <em>merged</em>. This merging is only done if <em>mergeVerticies</em> is true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>The DAG parent or kMeshData the new surface will belong to. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transform if one is created, otherwise the geometry.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a90d7831027dca6a6b4e6068b2911d755"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/addPolygon"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> addPolygon </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>loopCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>mergeVertices</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>pointTolerance</em> = <code>kMFnMeshPointTolerance</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Adds a new polygon to this polygonal mesh. </p>
<p>Return an index of the created polygon.</p>
<p>This version of <a class="el" href="./class_m_fn_mesh.html#a5d9b2da1ced87d07152df74788558e07" title="Adds a new polygon to this polygonal mesh. " translate="no">addPolygon()</a> allows for the creation of faces with holes. The loopCounts argument is used for this. loopCounts is an array of vertex counts. The first entry gives the count of vertices that make up the exterior of the polygon (using that many entries in vertexArray). The following entries in loopCounts give the count of vertices that make up each hole, using the following entries in vertexArray.</p>
<p>Therefore the sum of the entries of loopCounts should equal the total length of vertexArray.</p>
<p>If loopCounts is an empty array, it is treated as if it had one entry equal to the length of vertexArray i.e. the face has no holes.</p>
<p>Note that holes should normally be specified with the opposite winding order to the exterior polygon.</p>
<p>If there is no current geometry then a new polygonal mesh is created and parentOrOwner is used to specify the owner of the new surface. If parentOrOwner is nullptr or a DAG parent is specified, then a new transform will be created in the DAG and returned. If the parentOrOwner is kMeshData then the new surface will become its data and the geometry will be returned.</p>
<p>If we are adding to an existing polygonal mesh then parentOrOwner is ignored and the geometry is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>Array of ordered vertices that make up the polygon. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">loopCounts</td><td>Array of vertex loop counts. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">faceIndex</td><td>Index of the newly added polygon. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mergeVertices</td><td>If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointTolerance</td><td>Specifies how close verticies have to be to before they are <em>merged</em>. This merging is only done if <em>mergeVerticies</em> is true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>The DAG parent or kMeshData the new surface will belong to. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transform if one is created, otherwise the geometry.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a99327cc9a37ec10d8027ff15e28e3b95"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/addHoles"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> addHoles </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>loopCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>mergeVertices</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>pointTolerance</em> = <code>kMFnMeshPointTolerance</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Adds holes to a mesh polygon. </p>
<p>loopCounts is an array of vertex counts. The first entry gives the count of vertices that make up the first hole to add to the polygon (using that many entries in vertexArray). The following entries in loopCounts give the count of vertices that make up each remaining hole, using the following entries in vertexArray.</p>
<p>Therefore the sum of the entries of loopCounts should equal the total length of vertexArray.</p>
<p>Note that holes should normally be specified with the opposite winding order to the exterior polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of the face to which to add holes. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>Array of ordered vertices that make up the polygon. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">loopCounts</td><td>Array of vertex loop counts. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mergeVertices</td><td>If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointTolerance</td><td>Specifies how close verticies have to be to before they are <em>merged</em>. This merging is only done if <em>mergeVerticies</em> is true.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a3e1d9fef8e59f2a65783f4fdac434081"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/deleteFace"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> deleteFace </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete this face. </p>
<p>The method will return failure if an attempt is made to delete the last polygonal face in the object.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceId</td><td>The face to delete </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face index or attempt to delete mesh's last face. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a2820d9c79a27560da2c25fc0bdc46b4e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/deleteEdge"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> deleteEdge </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>edgeId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete this edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeId</td><td>The edge to delete </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid edge id. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="abadea7b4f2817f8744d7353074bd38ca"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/deleteVertex"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> deleteVertex </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete this vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexId</td><td>The object-relative (mehs-relative/global) vertex index to delete </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid vertex id. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa0fab620139a3143447ead1927936248"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/split"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> split </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>placements</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edgeList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>edgeFactors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>internalPoints</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function splits a set of edges and faces in a continuous manner. </p>
<p>The elements of the placements array must be elements of the SplitPlacement enumeration. For each SplitPlacement::kOnEdge element in the placements array, an equivalent edge ID and factor must be included in the edgeList and edgeFactors arrays. Similarly for SplitPlacement::kInternalPoint elements and the internalPoints array. The equivalent elements must be in the same order in all three arrays so that the first SplitPlacement::kOnEdge element in the placements array maps to the first elements in the edgeList and edgeFactors arrays. If one of the vertices cannot be created, the whole algorithm fails. The same edge cannot be split more than once.</p>
<p>The split must also start and end on an edge. This means that the first and last elements in the placements array must be SplitPlacement::kOnEdge values. If the placements array does not start and end on an edge then the code will still succeed but the mesh will not be split.</p>
<p>NOTE: the algorithm used by this method is the same as the polySplit command and has similar limitations.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">placements</td><td>array that contains elements of the SplitPlacement enumeration. They represent where to place the new vertices for the split. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">edgeList</td><td>array of edge IDs to be split, in order of their appearance in the split. There must be as many elements in this array as there are SplitPlacement::kOnEdge elements in the placements array. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">edgeFactors</td><td>array of factors in the range [0,1] that represent how far along each edge must the split be done. This array must have the same number of elements as the edgeList array. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">internalPoints</td><td>array of positions for the vertices that will be added inside existing faces. There must be as many elements in this array as there are SplitPlacement::kInternalPoint elements in the placements array. This array can be empty. Internal points should be specified on the face between the previous edge id and the next edge id.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> One or more of the edge IDs are not on the mesh; one or more of the edge factors are not within the [0,1] range; the given placements list is empty; the array sizes are not appropriate; or the split algorithm could not be completed successfully </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example2" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example2-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example2-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a35" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a8a4e8dfe0bd906b2ac2551e2fb2690f3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/subdivideFaces"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> subdivideFaces </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>divisionCount</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function subdivides multiple faces. </p>
<p>This method only accepts faces that are three of four-sided. The operation adds a vertex in the middle of each given face and connects it to the middle of every edge in the given face. This results in three or four new faces for each original face.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>array of face IDs to subdivide </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">divisionCount</td><td>number of subsequent subdivisions to do</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The given subdivision count is less than 1; the given faceIDs are not on the mesh; the given face list is empty; or the given information cannot produce a valid subdivision of the faces </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example3" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example3-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example3-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a16" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a25616dd654e9807fe6e74e16d84e2611"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/subdivideEdges"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> subdivideEdges </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edgeList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>divisionCount</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function subdivides edges at regular intervals. </p>
<p>The divisionCount argument is the number of subdivisions per edges and represents the number of new vertices created on each edge.</p>
<p>For example, a divisionCount of 2 will add a new vertex on every edge in the edgeList 33% along the edges and a new vertex at 67% along the edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeList</td><td>array of edge component IDs to be subdivided </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">divisionCount</td><td>number of subsequent subdivisions to do</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The given edge IDs are not on the mesh; the given subdivision count is less than 1; the given edge list is empty; or the subdivision could not be completed successfully </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example4" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example4-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example4-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a15" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ab15cb5975fdab32d083f0636266ca555"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/extrudeFaces"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> extrudeFaces </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>extrusionCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> * </td>
<td class="paramname"><em>translation</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>extrudeTogether</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>thickness</em> = <code>0.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>offset</em> = <code>0.0f</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function extrudes a set of faces. </p>
<p>The resulting mesh will have extra parallelograms coming out of the edges of the given polygons going to the new extruded edges. The extrusionCount argument is the number of subsequent extrusions per polygon and represents the number of faces that will be created for each edge of the polygons in the list.</p>
<p>The difference between using thickness or offset instead of providing a vector with the translation variable is that the translation will be applied to each vertex in the extrusion along its local direction. This can result in vertices being moved the same distance, but the angles between the original components are not maintained so the overall shape is not the same. Both the thickness and offset variables will attempt to move the components a distance that will maintain angles between edges at the border of the extrusion.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>array of face component IDs to be extruded </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">extrusionCount</td><td>number of subsequent extrusions to do </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">translation</td><td>translation vector to apply to the extruded elements. This is a world-space translation. Use nullptr if not required. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">extrudeTogether</td><td>sets whether the components should be extruded individually or together, as if one complex component was being extruded. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">thickness</td><td>Faces are moved outwards this distance from their original position to give the object a consistent thickness. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Faces are moved this distance towards the inside of the face.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The given face IDs are not on the mesh; the given extrusion count is less than 1; the given face list is empty; or the extrusion could not be completed successfully </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example5" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example5-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example5-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a18" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a35423618f98694bb2a6230e5430f4e5d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/extrudeEdges"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> extrudeEdges </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edgeList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>extrusionCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> * </td>
<td class="paramname"><em>translation</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>extrudeTogether</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>thickness</em> = <code>0.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>offset</em> = <code>0.0f</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function extrudes edges. </p>
<p>The resulting mesh will have extra parallelograms coming out of the given edges and going to the new extruded edges. The extrusionCount argument is the number of subsequent extrusions per edges and represents the number of polygons that will be created from each given edge to the extruded edges.</p>
<p>The difference between using thickness or offset instead of providing a vector with the translation variable is that the translation will be applied to each vertex in the extrusion along its local direction. This can result in vertices being moved the same distance, but the angles between the original components are not maintained so the overall shape is not the same. Both the thickness and offset variables will attempt to move the components a distance that will maintain angles between edges at the border of the extrusion.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeList</td><td>array of edge component IDs to be extruded </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">extrusionCount</td><td>number of subsequent extrusions to do </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">translation</td><td>translation vector to apply to the extruded elements. This is a world-space translation. Use nullptr if not required. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">extrudeTogether</td><td>sets whether the components should be extruded individually or together, as if one complex component was being extruded. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">thickness</td><td>Edges are moved this distance in the direction of the connected face normals. original position to give the object a consistent thickmess. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Edges are moved this distance in the opposite direction of the edge.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The given edge IDs are not on the mesh; the given extrusion count is less than 1; the given edge list is empty; or the extrusion could not be completed successfully. </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example6" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example6-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example6-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a17" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ae0c0818607c11b7d2f484a81e475fd66"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/duplicateFaces"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> duplicateFaces </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> * </td>
<td class="paramname"><em>translation</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function duplicates a set of faces and detaches them from the rest of the mesh. </p>
<p>The resulting mesh will contain one more independant piece of geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>array of face component IDs to be duplicated </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">translation</td><td>translation vector to apply to the duplicated elements. This is a world-space translation. Use nullptr if not required.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The given face IDs are not on the mesh; the given face list is empty; or the duplication could not be completed successfully </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example7" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example7-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example7-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a21" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a8888ea2f9c68478882f0ff4c90c1d40b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/extractFaces"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> extractFaces </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> * </td>
<td class="paramname"><em>translation</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function detaches a set of faces from the mesh so that the resulting mesh will contain one more independant piece of geometry and leaves a hole where the faces use to be. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>array of face component IDs to be extracted </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">translation</td><td>translation vector to apply to the extracted elements. This is a world-space translation. Use nullptr if not required.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The given face IDs are not on the mesh; the given face list is empty; or the extraction could not be completed successfully </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example8" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example8-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example8-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a22" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a334445a339b2f817b87ac5c87f51cdb1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/collapseFaces"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> collapseFaces </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function collapse faces into vertices. </p>
<p>Non-adjacent faces will be collapsed individually so that each pieces of adjacent faces turn into one vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>array of face component IDs to be collapsed</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The given face IDs are not on the mesh; the given face list is empty; or the collapse could not be completed successfully </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example9" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example9-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example9-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a20" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a68fec76262010b57a32acb44623cd0e9"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/collapseEdges"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> collapseEdges </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edgeList</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function collapse edges into vertices. </p>
<p>The two vertices that create each given edge are replaced in turn by one vertex placed at the average of the two initial vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeList</td><td>array of edge component IDs to be collapsed</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The given edge IDs are not on the mesh; the given edge list is empty; or the collapse could not be completed successfully. </li>
<li><b>MS::kFailure</b> An object error has occurred; or the mesh shape has no geometry to work on </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example10" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example10-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example10-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a19" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a9959c49420dce143087cb0abe402923e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numVertices </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of vertices in the vertex list for this mesh. </p>
<p>This number will be the same as the length of the vertex array returned with the getPoints method.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices of the mesh</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example11" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example11-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example11-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a14" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a742ce017199905f06ad07c178375a2d8"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numEdges </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of edges for this mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of edges for this mesh</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example12" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example12-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example12-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a61" translate="no">AbcImport/MeshHelper.cpp</a>, and <a class="el" href="./gpu_cache_2_cache_writer_8cpp-example.html#a21" translate="no">gpuCache/CacheWriter.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a3a7a28cf8f6a12dd19ab6ed0a639f9ed"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numPolygons </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of polygons for this mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of polygons for this mesh</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example13" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example13-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example13-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#a4" translate="no">AbcExport/MayaMeshWriter.cpp</a>, <a class="el" href="./_abc_import_2_create_scene_helper_8cpp-example.html#a30" translate="no">AbcImport/CreateSceneHelper.cpp</a>, <a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a19" translate="no">AbcImport/MeshHelper.cpp</a>, <a class="el" href="./gpu_cache_2_cache_writer_8cpp-example.html#a19" translate="no">gpuCache/CacheWriter.cpp</a>, and <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#a7" translate="no">vertexBufferGenerator/vertexBufferGenerator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ade2b77f791f506aba04d9d4818c12fee"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numFaceVertices </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of face-vertices for this mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of face-vertices for this mesh</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example14" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example14-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example14-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#a20" translate="no">AbcExport/MayaMeshWriter.cpp</a>, <a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a18" translate="no">AbcImport/MeshHelper.cpp</a>, and <a class="el" href="./custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#a4" translate="no">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a4ca016a3feb28fee0b9f373f86aebced"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int polygonVertexCount </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of vertices for the specified polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon index </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices for the specified polygon</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygon index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example15" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example15-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example15-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#a7" translate="no">AbcExport/MayaMeshWriter.cpp</a>, <a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a33" translate="no">AbcImport/MeshHelper.cpp</a>, and <a class="el" href="./vertex_buffer_generator_2vertex_buffer_generator_8cpp-example.html#a8" translate="no">vertexBufferGenerator/vertexBufferGenerator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a8ec9383ddfdf01902e7d5c8affd0c14c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numUVs </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of texture (uv) coordinates for this mesh. </p>
<p>The uv's are stored in a list which is referenced by polygons requiring textures on a per-polygon per-vertex basis. This method returns the number of elements in this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of texture coordinates</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example16" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example16-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example16-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a34" translate="no">AbcImport/MeshHelper.cpp</a>, and <a class="el" href="./split_u_v_cmd_2split_u_v_fty_action_8cpp-example.html#a14" translate="no">splitUVCmd/splitUVFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a88e0df23c70f998573e435cf13b7466c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numUVs </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>uvSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of texture (uv) coordinates for this mesh. </p>
<p>The uv's are stored in a list which is referenced by polygons requiring textures on a per-polygon per-vertex basis. This method returns the number of elements in this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of texture coordinates</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a8eba9438fe4c6ab02d307cc02261193e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of (vertex) color for this mesh. </p>
<p>The color are stored in a list which is referenced by polygons requiring color on a per-polygon per-vertex basis. This method returns the number of elements in this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of colors</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a7ff2aefcd9553395f959a9754d30bd9e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numColors </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of colors (vertex data) for this mesh. </p>
<p>The colors are stored in a list which is referenced by polygons requiring textures on a per-polygon per-vertex basis. This method returns the number of elements in this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of colors</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ab7cc2855f68a882b2217f525068322e0"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of per-polygon per-vertex normals for this mesh. </p>
<p>This number will correspond to the length of the normal array returned by getNormals( normalArray, space ).</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of per-polygon per-vertex normals</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a0e34a918fc6c4c6eb697fc029610bf97"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool hasColorChannels </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns if the color set has RGB components. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The color set has RGB components </li>
<li><b>false</b> The color set doesn't have RGB components</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a29c14970fc689e97ce67f95f19d38ea6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool hasAlphaChannels </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns true if the color set has Alpha component. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The color set has Alpha component </li>
<li><b>false</b> The color set doesn't have Alpha component</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="af23d73f055a2654f6d2b59a4a1e13c33"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getColorRepresentation"></a><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MFnMesh::MColorRepresentation</a> getColorRepresentation </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the color representation (RGB/RGBA/A) of a color set. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>kAlpha</b> The color set contains only Alpha component </li>
<li><b>kRGB</b> The color set contains only RGB components </li>
<li><b>kRGBA</b> The color set contains RGBA components</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> The color set doesn't exist </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a52c541ed670c56137ed1c2dabe97ef7b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isColorClamped </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns if the color set has its R,G,B,and A components clamped in the range from 0 to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> All components in the color set are clamped </li>
<li><b>false</b> All components in the color set are not clamped</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad8b07fedf64d78eabfb2c067ac8155c5"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setIsColorClamped"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setIsColorClamped </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>clamped</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set the color set to be clamped. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">clamped</td><td>If the color set should be set clamped</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4518ef27addc1639a4ae139fe3d75265"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getTriangles"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getTriangles </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>triangleCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>triangleVertices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of triangles for every polygon face and the vertex Ids of each triangle vertex. </p>
<p>The triangleVertices array holds each vertex for each triangle in sequence, so it has three times as many elements as there are triangles. (i.e. three times the sum of the elements of the triangleCounts array)</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">triangleCounts</td><td>The number of triangles for each polygon face </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">triangleVertices</td><td>The triangle vertex Ids for each triangle</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a21f54d9e1ca3cbed6492f576f9f61215"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getTriangleOffsets"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getTriangleOffsets </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>triangleCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>triangleIndices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of triangles for every polygon face and the offset into the vertex indices array for each triangle vertex (see <a class="el" href="./class_m_fn_mesh.html#a2f2e041f01dc1ec3648002e2524fbfbc" title="This method retrieves the object-relative (mesh-relative/global) vertex indices for all polygons..." translate="no">getVertices()</a>). </p>
<p>The triangleVertices array holds each vertex for each triangle in sequence, so it has three times as many elements as there are triangles. (i.e. three times the sum of the elements of the triangleCounts array)</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">triangleCounts</td><td>The number of triangles for each polygon face </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">triangleIndices</td><td>The index array for each triangle in face vertex space</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example17" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example17-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example17-content" style="display:none;"><dd><a class="el" href="./custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#a12" translate="no">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a64611268a18041e82d6f25ffa3c063b6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/booleanOp"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> booleanOp </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8a" translate="no">BoolOperation</a> </td>
<td class="paramname"><em>op</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html" translate="no">MFnMesh</a> &amp; </td>
<td class="paramname"><em>mesh1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html" translate="no">MFnMesh</a> &amp; </td>
<td class="paramname"><em>mesh2</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000095" translate="no">Deprecated:</a></b></dt><dd>This method uses Maya's legacy boolean algorithm. Use <a class="el" href="./class_m_fn_mesh.html#a28e288336ac402e5ceda4e8c0e35938b" title="Computes the boolean between multiple meshes. " translate="no">MFnMesh::booleanOps</a> instead to choose between Maya's newer boolean algorithm and the legacy algorithm.</dd></dl>
<p>Computes the boolean between two meshes. The result is stored in the current <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> instance. The current instance must point to a valid mesh, which can be empty. Such a mesh can result from using <a class="el" href="./class_m_fn_mesh.html#af9b9e5d33d289134d567c62bad4ca3d5" title="Creates a new polygonal mesh given an array of vertices and polygon connection information and sets t..." translate="no">MFnMesh::create()</a> for example.</p>
<p>The union operation adds the two meshes together. The difference operation subtracts the second mesh from the first. The intersection operation takes only the parts of the two mesh volumes which overlap.</p>
<p>The operation is performed in object space, so transformations applied by the DAG hierarchy are ignored. If you want transformations to be taken into account then you will have to first bake them onto the geometry, for example by using the <em>makeIdentity</em> command.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Operation to perform (kUnion, kDifference or kIntersection) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mesh1</td><td>The first mesh in the boolean operation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mesh2</td><td>The second mesh in the boolean operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kFailure</b> Mesh1, mesh2, this mesh is invalid, or the boolean operation failed. </li>
<li><b>MS::kSuccess</b> Operation successful. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a28e288336ac402e5ceda4e8c0e35938b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/booleanOps"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> booleanOps </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a4451c8eb916f7cae80bb690274643d8a" translate="no">BoolOperation</a> </td>
<td class="paramname"><em>op</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp; </td>
<td class="paramname"><em>meshes</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>useLegacy</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the boolean between multiple meshes. </p>
<p>The result is stored in the current <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> instance. The current instance must point to a valid mesh, which can be empty. Such a mesh can result from using <a class="el" href="./class_m_fn_mesh.html#af9b9e5d33d289134d567c62bad4ca3d5" title="Creates a new polygonal mesh given an array of vertices and polygon connection information and sets t..." translate="no">MFnMesh::create()</a> for example.</p>
<p>The union operation adds the meshes in the array together. The difference operation subtracts the proceeding meshes from the first mesh in the array. The intersection operation takes only the parts of the mesh volumes which overlap. The current <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> instance is not used as input to the boolean operation.</p>
<p>The operation is performed in object space, so transformations applied by the DAG hierarchy are ignored. If you want transformations to be taken into account then you will have to first bake them onto the geometry, for example by using the <em>makeIdentity</em> command.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Operation to perform (kUnion, kDifference or kIntersection) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">meshes</td><td>The meshes for the boolean operation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">useLegacy</td><td>Flag to indicate if Maya's legacy boolean algorithm should be used. The legacy algorithm produces lower quality results, and should only be used when required to match boolean results from versions of Maya prior to 2015.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kFailure</b> Any of the meshes in the array are invalid, this mesh is invalid, meshes contains less than two elements, or the boolean operation failed. </li>
<li><b>MS::kSuccess</b> Operation successful. </li>
<li><b>MS::kInvalidParameter</b> meshes array contains too many or too few items for the boolean operation, an element in the mesh array was invalid, or a <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> function set could not be attached to it. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a6935c5bb858e53b60ad6d04ab5025899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/uniformGridParams"></a><a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> uniformGridParams </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>xDiv</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>yDiv</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>zDiv</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> configuration object that can be passed to several of the geometric query methods available on <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a>. </p>
<p>For example, the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> closest point and intersection methods can optionally make use of this object to speed up their operation.</p>
<p>This object specifies the number of voxel cells to be used in the x, y, and z dimensions. The grid acceleration structure will be cached with the mesh, so that if the same <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> configuration is used on the next call, the acceleration structure will not need to be rebuilt.</p>
<p>To see details of the acceleration structure, including build time and memory usage, refer to the <a class="el" href="./class_m_fn_mesh.html#a3bc71baf47c585ab81a20cda45f6dabe" title="Retrieves a string that describes the intersection acceleration structure for this object..." translate="no">cachedIntersectionAcceleratorInfo()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">xDiv</td><td>Number of voxels in the x direction </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">yDiv</td><td>Number of voxels in the y direction </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">zDiv</td><td>Number of voxels in the z direction</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Intersection accelerator object. </dd></dl>
</div>
</div>
<a class="anchor" id="af405a2789178f0cc8e8609b7a1dd5b20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/autoUniformGridParams"></a><a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> autoUniformGridParams </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> configuration object that can be passed to several of the geometric query methods on <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> to speed up their operation. </p>
<p>For example, the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> closest point and intersection methods can optionally make use of this object.</p>
<p>This object specifies that a uniform voxel grid structure should be used by these routines, and that the system should automatically determine the number of voxel cells to use based on the density of triangles in the mesh. The grid acceleration structure will be cached with the mesh, so that if the same <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> configuration is used on the next call, the acceleration structure will not need to be rebuilt.</p>
<p>To see details of the acceleration structure, including build time and memory usage, refer to the <a class="el" href="./class_m_fn_mesh.html#a3bc71baf47c585ab81a20cda45f6dabe" title="Retrieves a string that describes the intersection acceleration structure for this object..." translate="no">cachedIntersectionAcceleratorInfo()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>Intersection accelerator object. </dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example18" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example18-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example18-content" style="display:none;"><dd><a class="el" href="./intersect_cmd_2intersect_cmd_8cpp-example.html#a37" translate="no">intersectCmd/intersectCmd.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="afdb59391c386066b662504d4a055c103"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool closestIntersection </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp; </td>
<td class="paramname"><em>raySource</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> &amp; </td>
<td class="paramname"><em>rayDirection</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>faceIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>triIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>idsSorted</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>maxParam</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>testBothDirections</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> * </td>
<td class="paramname"><em>accelParams</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp; </td>
<td class="paramname"><em>hitPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>hitRayParam</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>hitFace</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>hitTriangle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>hitBary1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>hitBary2</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>tolerance</em> = <code>1e-6</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Finds the closest intersection of a ray starting at raySource and travelling in rayDirection with the mesh. </p>
<p>If faceIds is non-nullptr and triIds is nullptr, then only the faces specified by faceIds will be considered for intersection. If both faceIds and triIds are non-nullptr, then each pair of entries will be taken as a (face,triangle) pair to be considered for intersection, where triangles are numbered on each face starting from 0. Thus, the face-triangle pair (10,0) means the first triangle on face 10. If both faceIds and triIds are nullptr, then all face-triangles in the mesh will be considered.</p>
<p>The maxParam and testBothDirections flags can be used to control the radius of the search around the raySource point.</p>
<p>If accelParams is nullptr, the search proceeds by testing all applicable face-triangles looking for intersections. If an <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> structure is passed in via this parameter, the mesh builds an intersection acceleration structure based on the description provided by the parameter object. This acceleration structure is used to speed up the intersection operation, sometimes by a factor of several hundred over the non-accelerated case. Once created, the acceleration structure is cached, and will be reused the next time this method (or <a class="el" href="./class_m_fn_mesh.html#a935fa7510dbeb972223c06ed5d83b400" title="Finds any intersection of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">anyIntersection()</a> or <a class="el" href="./class_m_fn_mesh.html#aa6c4717b168258664d399fb92e2cdcee" title="Finds all intersections of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">allIntersections()</a>) is called with an identically-configured <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> object. If a different <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> object is used, then the acceleration structure will be deleted and re-created according to the new settings. Once created, the acceleration structure will persist until either the object is destroyed (or rebuilt by a construction history operation), or if the <a class="el" href="./class_m_fn_mesh.html#a9e66af440a1965abc80c0e8692c7f475" title="If the mesh has a cached accelerator structure, then this routine forces it to be deleted..." translate="no">freeCachedIntersectionAccelerator()</a> method is called. The <a class="el" href="./class_m_fn_mesh.html#a3bc71baf47c585ab81a20cda45f6dabe" title="Retrieves a string that describes the intersection acceleration structure for this object..." translate="no">cachedIntersectionAcceleratorInfo()</a> and <a class="el" href="./class_m_fn_mesh.html#acda309cf310fdac3ad08665c41a6bf7f" title="Retrieves a string that describes the systemwide resource usage for cached mesh intersection accelera..." translate="no">globalIntersectionAcceleratorsInfo()</a> methods provide useful information about the resource usage of individual acceleration structures, and of all such structures in the system.</p>
<p>If the ray hits the mesh, the details of the closest intersection point to the raySource will be returned via the hitPoint, hitRayParam, hitFace, hitTriangle, hitBary1, and hitBary2 parameters. These parameters completely describe where the hit occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">raySource</td><td>Starting point for the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>Direction of the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIds</td><td>(see above) if non-nullptr, describes a subset of faces to consider for intersection. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">triIds</td><td>(see above) if non-nullptr, then along with faceIds describes a set of face-triangles to consider for intersection. If triIds is non-nullptr, then faceIds must be non-nullptr as well, otherwise an error will be generated. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">idsSorted</td><td>should be true if the faceIds or faceIds/triIds arrays are properly sorted into ascending order. For face-triangle pairs, the arrays must be sorted by ascending face ids, then by ascending triangle ids within each face. The routine <a class="el" href="./class_m_fn_mesh.html#af90b27d0d9fc6ab7487735bdb220a76d" title="Convenience routine for sorting faceIds or face/triangle ids before passing them into the closestInte..." translate="no">sortIntersectionFaceTriIds()</a> can be used to perform this task. It is not important to sort ids unless an acceleration structure is being used. When using an acceleration structure in conjunction with a limited set of faces or face-triangles, it is ESSENTIAL to sort the indices, otherwise performance will be severely degraded. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>specifies the space in which raySource and rayDirection are specified, as well as the space in which the hit point will be returned. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">maxParam</td><td>specifies the maximum radius within which hits will be considered. This radius is specified as a multiple of the length of the rayDirection vector, so any hits beyond raySource+maxParam*rayDirection will not be considered. This value must be positive. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">testBothDirections</td><td>specifies that hits in the negative rayDirection should also be considered. The maxParam value still applies to limit the search radius, which means that if testBothDirections is true, then only hits that lie between raySource-maxParam*rayDirection and raySource+maxParam*rayDirection will be considered. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">accelParams</td><td>optional acceleration parameters. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitPoint</td><td>receives the 3d coordinates of the closest intersection, in the space specified by the space parameter. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitRayParam</td><td>if non-nullptr, points to a value that will be filled in with the parametric distance along the ray to the hit point, if one was found. That is, hitPoint = raySource+(*hitRayParam)*rayDirection. If no hit was found, the referenced value will not be modified. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitFace</td><td>if non-nullptr, points to a value that will be filled in with the face id of the hit point, if one was found. If no hit was found, the referenced value will not be modified. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitTriangle</td><td>if non-nullptr, points to a value that will be filled in with the 0-based index of the triangle that was hit within the face given by *hitFace. If no hit was found, the referenced value will not be modified, </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitBary1</td><td>if non-nullptr, points to a value that will be filled in with the first barycentric coordinate of the hit point within the triangle defined by hitFace and *hitTriangle. If v1, v2, and v3 are the vertices of that triangle, then the barycentric coordinates are such that hitPoint = (*hitBary1)*v1 + (*hitBary2)*v2 + (1-*hitBary1-*hitBary2)*v3; If no hit was found, the referenced value will not be modified, </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitBary2</td><td>if non-nullptr, points to a value that will be filled in with the second barycentric coordinate of the hit point within the triangle defined by hitFace and *hitTriangle. If no hit was found, the referenced value will not be modified, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>numerical tolerance for the intersection operation. For numerical reasons, it is wise to allow the intersection routine to consider hits that lie a tiny bit outside mesh triangles. This parameter defines how close a ray has to be to hitting a triangle in order for a hit to register. Obviously, hits within the triangle are always considered, but we also consider hits that are up to a distance of tol*edgeLength away from the triangle, where "edgeLength" is the length of the edge of the triangle that is closest to the ray. This tolerance value is also used to collapse multiple nearly-identical hits that may arise due to numerical imprecision when a ray passes extremely close to a mesh vertex. Any two hits that are less than tol multiplied by the length of rayDirection apart will be considered the same hit, and treated interchangeably. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The given ray intersects the mesh, and the closest intersection of the ray with the mesh is given by the value returned in hitPoint. </li>
<li><b>false</b> The given ray does not intersect this mesh</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> There was an error with the parameters passed to the method. Either <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8a45a60f04ac9114f0d6e865a6285f40b2" title="transform in world space. " translate="no">MSpace::kWorld</a> was specified for a mesh with no world-space transformation, or the mesh had no data, or triIds was non-nullptr without a corresponding faceIds array. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a935fa7510dbeb972223c06ed5d83b400"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool anyIntersection </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp; </td>
<td class="paramname"><em>raySource</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> &amp; </td>
<td class="paramname"><em>rayDirection</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>faceIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>triIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>idsSorted</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>maxParam</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>testBothDirections</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> * </td>
<td class="paramname"><em>accelParams</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp; </td>
<td class="paramname"><em>hitPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>hitRayParam</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>hitFace</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>hitTriangle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>hitBary1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>hitBary2</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>tolerance</em> = <code>1e-6</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Finds any intersection of a ray starting at raySource and travelling in rayDirection with the mesh. </p>
<p>If faceIds is non-nullptr and triIds is nullptr, then only the faces specified by faceIds will be considered for intersection. If both faceIds and triIds are non-nullptr, then each pair of entries will be taken as a (face,triangle) pair to be considered for intersection, where triangles are numbered on each face starting from 0. Thus, the face-triangle pair (10,0) means the first triangle on face 10. If both faceIds and triIds are nullptr, then all face-triangles in the mesh will be considered.</p>
<p>The maxParam and testBothDirections flags can be used to control the radius of the search around the raySource point.</p>
<p>If accelParams is nullptr, the search proceeds by testing all applicable face-triangles looking for intersections. If an <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> structure is passed in via this parameter, the mesh builds an intersection acceleration structure based on the description provided by the parameter object. This acceleration structure is used to speed up the intersection operation, sometimes by a factor of several hundred over the non-accelerated case. Once created, the acceleration structure is cached, and will be reused the next time this method (or <a class="el" href="./class_m_fn_mesh.html#afdb59391c386066b662504d4a055c103" title="Finds the closest intersection of a ray starting at raySource and travelling in rayDirection with the..." translate="no">closestIntersection()</a> or <a class="el" href="./class_m_fn_mesh.html#aa6c4717b168258664d399fb92e2cdcee" title="Finds all intersections of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">allIntersections()</a>) is called with an identically-configured <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> object. If a different <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> object is used, then the acceleration structure will be deleted and re-created according to the new settings. Once created, the acceleration structure will persist until either the object is destroyed (or rebuilt by a construction history operation), or if the <a class="el" href="./class_m_fn_mesh.html#a9e66af440a1965abc80c0e8692c7f475" title="If the mesh has a cached accelerator structure, then this routine forces it to be deleted..." translate="no">freeCachedIntersectionAccelerator()</a> method is called. The <a class="el" href="./class_m_fn_mesh.html#a3bc71baf47c585ab81a20cda45f6dabe" title="Retrieves a string that describes the intersection acceleration structure for this object..." translate="no">cachedIntersectionAcceleratorInfo()</a> and <a class="el" href="./class_m_fn_mesh.html#acda309cf310fdac3ad08665c41a6bf7f" title="Retrieves a string that describes the systemwide resource usage for cached mesh intersection accelera..." translate="no">globalIntersectionAcceleratorsInfo()</a> methods provide useful information about the resource usage of individual acceleration structures, and of all such structures in the system.</p>
<p>If the ray hits the mesh, the details of the found intersection point to the raySource will be returned via the hitPoint, hitRayParam, hitFace, hitTriangle, hitBary1, and hitBary2 parameters. These parameters completely describe where the hit occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">raySource</td><td>Starting point for the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>Direction of the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIds</td><td>(see above) if non-nullptr, describes a subset of faces to consider for intersection. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">triIds</td><td>(see above) if non-nullptr, then along with faceIds describes a set of face-triangles to consider for intersection. If triIds is non-nullptr, then faceIds must be non-nullptr as well, otherwise an error will be generated. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">idsSorted</td><td>should be true if the faceIds or faceIds/triIds arrays are properly sorted into ascending order. For face-triangle pairs, the arrays must be sorted by ascending face ids, then by ascending triangle ids within each face. The routine <a class="el" href="./class_m_fn_mesh.html#af90b27d0d9fc6ab7487735bdb220a76d" title="Convenience routine for sorting faceIds or face/triangle ids before passing them into the closestInte..." translate="no">sortIntersectionFaceTriIds()</a> can be used to perform this task. It is not important to sort ids unless an acceleration structure is being used. When using an acceleration structure in conjunction with a limited set of faces or face-triangles, it is ESSENTIAL to sort the indices, otherwise performance will be severely degraded. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>specifies the space in which raySource and rayDirection are specified, as well as the space in which the hit point will be returned. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">maxParam</td><td>specifies the maximum radius within which hits will be considered. This radius is specified as a multiple of the length of the rayDirection vector, so any hits beyond raySource+maxParam*rayDirection will not be considered. This value must be positive. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">testBothDirections</td><td>specifies that hits in the negative rayDirection should also be considered. The maxParam value still applies to limit the search radius, which means that if testBothDirections is true, then only hits that lie between raySource-maxParam*rayDirection and raySource+maxParam*rayDirection will be considered. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">accelParams</td><td>optional acceleration parameters. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitPoint</td><td>receives the 3d coordinates of the intersection, in the space specified by the space parameter. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitRayParam</td><td>if non-nullptr, points to a value that will be filled in with the parametric distance along the ray to the hit point, if one was found. That is, hitPoint = raySource+(*hitRayParam)*rayDirection. If no hit was found, the referenced value will not be modified. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitFace</td><td>if non-nullptr, points to a value that will be filled in with the face id of the hit point, if one was found. If no hit was found, the referenced value will not be modified. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitTriangle</td><td>if non-nullptr, points to a value that will be filled in with the 0-based index of the triangle that was hit within the face given by *hitFace. If no hit was found, the referenced value will not be modified, </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitBary1</td><td>if non-nullptr, points to a value that will be filled in with the first barycentric coordinate of the hit point within the triangle defined by hitFace and *hitTriangle. If v1, v2, and v3 are the vertices of that triangle, then the barycentric coordinates are such that hitPoint = (*hitBary1)*v1 + (*hitBary2)*v2 + (1-*hitBary1-*hitBary2)*v3; If no hit was found, the referenced value will not be modified, </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitBary2</td><td>if non-nullptr, points to a value that will be filled in with the second barycentric coordinate of the hit point within the triangle defined by hitFace and *hitTriangle. If no hit was found, the referenced value will not be modified, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>numerical tolerance for the intersection operation. For numerical reasons, it is wise to allow the intersection routine to consider hits that lie a tiny bit outside mesh triangles. This parameter defines how close a ray has to be to hitting a triangle in order for a hit to register. Obviously, hits within the triangle are always considered, but we also consider hits that are up to a distance of tol*edgeLength away from the triangle, where "edgeLength" is the length of the edge of the triangle that is closest to the ray. This tolerance value is also used to collapse multiple nearly-identical hits that may arise due to numerical imprecision when a ray passes extremely close to a mesh vertex. Any two hits that are less than tol multiplied by the length of rayDirection apart will be considered the same hit, and treated interchangeably. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The given ray intersects the mesh, and the found intersection of the ray with the mesh is given by the value returned in hitPoint. </li>
<li><b>false</b> The given ray does not intersect this mesh</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> There was an error with the parameters passed to the method. Either <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8a45a60f04ac9114f0d6e865a6285f40b2" title="transform in world space. " translate="no">MSpace::kWorld</a> was specified for a mesh with no world-space transformation, or the mesh had no data, or triIds was non-nullptr without a corresponding faceIds array. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example19" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example19-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example19-content" style="display:none;"><dd><a class="el" href="./intersect_cmd_2intersect_cmd_8cpp-example.html#a38" translate="no">intersectCmd/intersectCmd.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa6c4717b168258664d399fb92e2cdcee"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool allIntersections </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_float_point.html" translate="no">MFloatPoint</a> &amp; </td>
<td class="paramname"><em>raySource</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_vector.html" translate="no">MFloatVector</a> &amp; </td>
<td class="paramname"><em>rayDirection</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>faceIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>triIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>idsSorted</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>maxParam</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>testBothDirections</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> * </td>
<td class="paramname"><em>accelParams</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>sortHits</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>hitPoints</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> * </td>
<td class="paramname"><em>hitRayParams</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>hitFaces</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>hitTriangles</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> * </td>
<td class="paramname"><em>hitBary1s</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> * </td>
<td class="paramname"><em>hitBary2s</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>tolerance</em> = <code>1e-6</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Finds all intersections of a ray starting at raySource and travelling in rayDirection with the mesh. </p>
<p>If faceIds is non-nullptr and triIds is nullptr, then only the faces specified by faceIds will be considered for intersection. If both faceIds and triIds are non-nullptr, then each pair of entries will be taken as a (face,triangle) pair to be considered for intersection, where triangles are numbered on each face starting from 0. Thus, the face-triangle pair (10,0) means the first triangle on face 10. If both faceIds and triIds are nullptr, then all face-triangles in the mesh will be considered.</p>
<p>The maxParam and testBothDirections flags can be used to control the radius of the search around the raySource point.</p>
<p>If accelParams is nullptr, the search proceeds by testing all applicable face-triangles looking for intersections. If an <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> structure is passed in via this parameter, the mesh builds an intersection acceleration structure based on the description provided by the parameter object. This acceleration structure is used to speed up the intersection operation, sometimes by a factor of several hundred over the non-accelerated case. Once created, the acceleration structure is cached, and will be reused the next time this method (or <a class="el" href="./class_m_fn_mesh.html#a935fa7510dbeb972223c06ed5d83b400" title="Finds any intersection of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">anyIntersection()</a> or <a class="el" href="./class_m_fn_mesh.html#aa6c4717b168258664d399fb92e2cdcee" title="Finds all intersections of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">allIntersections()</a>) is called with an identically-configured <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> object. If a different <a class="el" href="./class_m_mesh_isect_accel_params.html" title="Class to define parameters for accelerated intersection operations. " translate="no">MMeshIsectAccelParams</a> object is used, then the acceleration structure will be deleted and re-created according to the new settings. Once created, the acceleration structure will persist until either the object is destroyed (or rebuilt by a construction history operation), or if the <a class="el" href="./class_m_fn_mesh.html#a9e66af440a1965abc80c0e8692c7f475" title="If the mesh has a cached accelerator structure, then this routine forces it to be deleted..." translate="no">freeCachedIntersectionAccelerator()</a> method is called. The <a class="el" href="./class_m_fn_mesh.html#a3bc71baf47c585ab81a20cda45f6dabe" title="Retrieves a string that describes the intersection acceleration structure for this object..." translate="no">cachedIntersectionAcceleratorInfo()</a> and <a class="el" href="./class_m_fn_mesh.html#acda309cf310fdac3ad08665c41a6bf7f" title="Retrieves a string that describes the systemwide resource usage for cached mesh intersection accelera..." translate="no">globalIntersectionAcceleratorsInfo()</a> methods provide useful information about the resource usage of individual acceleration structures, and of all such structures in the system.</p>
<p>If the ray hits the mesh, the details of the intersection points will be returned via the hitPoint, hitRayParam, hitFace, hitTriangle, hitBary1, and hitBary2 parameters. These parameters completely describe where the hit occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">raySource</td><td>Starting point for the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>Direction of the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIds</td><td>(see above) if non-nullptr, describes a subset of faces to consider for intersection. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">triIds</td><td>(see above) if non-nullptr, then along with faceIds describes a set of face-triangles to consider for intersection. If triIds is non-nullptr, then faceIds must be non-nullptr as well, otherwise an error will be generated. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">idsSorted</td><td>should be true if the faceIds or faceIds/triIds arrays are properly sorted into ascending order. For face-triangle pairs, the arrays must be sorted by ascending face ids, then by ascending triangle ids within each face. The routine <a class="el" href="./class_m_fn_mesh.html#af90b27d0d9fc6ab7487735bdb220a76d" title="Convenience routine for sorting faceIds or face/triangle ids before passing them into the closestInte..." translate="no">sortIntersectionFaceTriIds()</a> can be used to perform this task. It is not important to sort ids unless an acceleration structure is being used. When using an acceleration structure in conjunction with a limited set of faces or face-triangles, it is ESSENTIAL to sort the indices, otherwise performance will be severely degraded. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>specifies the space in which raySource and rayDirection are specified, as well as the space in which the hit point will be returned. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">maxParam</td><td>specifies the maximum radius within which hits will be considered. This radius is specified as a multiple of the length of the rayDirection vector, so any hits beyond raySource+maxParam*rayDirection will not be considered. This value must be positive. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">testBothDirections</td><td>specifies that hits in the negative rayDirection should also be considered. The maxParam value still applies to limit the search radius, which means that if testBothDirections is true, then only hits that lie between raySource-maxParam*rayDirection and raySource+maxParam*rayDirection will be considered. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">accelParams</td><td>optional acceleration parameters. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">sortHits</td><td>if true, then hits will be sorted in ascending ray-parametric order, so hits behind the raySource will be first (if testBothDirections is true), moving proceeding closer to the raySource, followed by hits in front of the raySource, proceeding by increasing distance from the raySource. If false, hits will be presented in no particular order in the return arrays. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitPoints</td><td>an array that receives the 3d coordinates of the intersections, in the space specified by the space parameter. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitRayParams</td><td>if non-nullptr, points to an array that will be filled in with the parametric distances along the ray to the hit points, if any were found. That is, for the i'th hit, hitPoints[i] = raySource+(*hitRayParams[i])*rayDirection. If no hit was found, the referenced values will not be modified. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitFaces</td><td>if non-nullptr, points to an array that will be filled in with the face ids of the hit points, if any were found. If no hits were found, the referenced values will not be modified. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitTriangles</td><td>if non-nullptr, points to an array that will be filled in with the 0-based indices of the triangles that were hit within the faces given by *hitFaces. If no hits were found, the referenced values will not be modified, </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitBary1s</td><td>if non-nullptr, points to an array that will be filled in with the first barycentric coordinates of the hit points within the triangles defined by hitFaces and *hitTriangles. For the i'th hit, If v1, v2, and v3 are the vertices of that triangle, then the barycentric coordinates are such that hitPoint[i] = (*hitBary1s)[i]*v1 + (*hitBary2s)[i]*v2 + (1-(*hitBary1s)[i]-(*hitBary2s)[i])*v3; If no hits were found, the referenced value will not be modified, </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hitBary2s</td><td>if non-nullptr, points to an array that will be filled in with the second barycentric coordinates of the hit points within the triangles defined by hitFaces and *hitTriangles. If no hits were found, the referenced values will not be modified, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>numerical tolerance for the intersection operation. For numerical reasons, it is wise to allow the intersection routine to consider hits that lie a tiny bit outside mesh triangles. This parameter defines how close a ray has to be to hitting a triangle in order for a hit to register. Obviously, hits within the triangle are always considered, but we also consider hits that are up to a distance of tol*edgeLength away from the triangle, where "edgeLength" is the length of the edge of the triangle that is closest to the ray. This tolerance value is also used to collapse multiple nearly-identical hits that may arise due to numerical imprecision when a ray passes extremely close to a mesh vertex. Any two hits that are less than tol multiplied by the length of rayDirection apart will be considered the same hit, and treated interchangeably. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The given ray intersects the mesh, and the intersections of the ray with the mesh are given by the values returned in hitPoints. </li>
<li><b>false</b> The given ray does not intersect this mesh</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> There was an error with the parameters passed to the method. Either <a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8a45a60f04ac9114f0d6e865a6285f40b2" title="transform in world space. " translate="no">MSpace::kWorld</a> was specified for a mesh with no world-space transformation, or the mesh had no data, or triIds was non-nullptr without a corresponding faceIds array. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example20" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example20-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example20-content" style="display:none;"><dd><a class="el" href="./intersect_cmd_2intersect_cmd_8cpp-example.html#a43" translate="no">intersectCmd/intersectCmd.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="af90b27d0d9fc6ab7487735bdb220a76d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/sortIntersectionFaceTriIds"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> sortIntersectionFaceTriIds </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>faceIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>triIds</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Convenience routine for sorting faceIds or face/triangle ids before passing them into the <a class="el" href="./class_m_fn_mesh.html#afdb59391c386066b662504d4a055c103" title="Finds the closest intersection of a ray starting at raySource and travelling in rayDirection with the..." translate="no">closestIntersection()</a>, <a class="el" href="./class_m_fn_mesh.html#aa6c4717b168258664d399fb92e2cdcee" title="Finds all intersections of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">allIntersections()</a>, or <a class="el" href="./class_m_fn_mesh.html#a935fa7510dbeb972223c06ed5d83b400" title="Finds any intersection of a ray starting at raySource and travelling in rayDirection with the mesh..." translate="no">anyIntersection()</a> methods. </p>
<p>When using an acceleration structure with the intersection operation, it is essential that any faceId or faceId/triId arrays be sorted properly to ensure optimal performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in,out]</td><td class="paramname">faceIds</td><td>Face IDs to be sorted. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">triIds</td><td>Triangle IDs to be sorted.</td></tr>
</table>
</dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> 'faceIds' was nullptr. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9e66af440a1965abc80c0e8692c7f475"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/freeCachedIntersectionAccelerator"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> freeCachedIntersectionAccelerator </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>If the mesh has a cached accelerator structure, then this routine forces it to be deleted. </p>
<p>Ordinarily, these structures are cached so that series of calls to the geometric query methods that make use of it can reuse the same structure. Once the client is finished with a series of method calls, however, they are responsible for freeing the acceleration structure, which is what this method does.</p>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a3bc71baf47c585ab81a20cda45f6dabe"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/cachedIntersectionAcceleratorInfo"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> cachedIntersectionAcceleratorInfo </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieves a string that describes the intersection acceleration structure for this object, if any. </p>
<p>The string is formatted similar to:</p>
<p>10x10x10 uniform grid, (build time 0.5s), (memory footprint 2000KB)</p>
<p>It describes the configuration of the cached intersection accelerator, as well as how long it took to build it, and how much memory it is currently occupying. If the mesh has no cached intersection accelerator, the empty string is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code.</td></tr>
</table>
</dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The description string </dd></dl>
</div>
</div>
<a class="anchor" id="acda309cf310fdac3ad08665c41a6bf7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/globalIntersectionAcceleratorsInfo"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> globalIntersectionAcceleratorsInfo </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieves a string that describes the systemwide resource usage for cached mesh intersection accelerators. </p>
<p>The string will be formatted similar to:</p>
<p>total 10 accelerators created (2 currently active - total current memory = 10000KB), total build time = 10.2s, peak memory = 14567.1KB</p>
<p>This means that:</p>
<ul>
<li>a total of 10 acceleration structures have been created as instructed by calls to geometric query methods (e.g. closest point or intersection) with non-nullptr accelParams values. These structures are destroyed and re-created when queries with differing acceleration parameters are made for the same mesh, so it is useful to see this value, which is the total count of how many have been created. In this case, 8 of the 10 created have been destroyed, either automatically or via calls to the <a class="el" href="./class_m_fn_mesh.html#a9e66af440a1965abc80c0e8692c7f475" title="If the mesh has a cached accelerator structure, then this routine forces it to be deleted..." translate="no">freeCachedIntersectionAccelerator()</a> method</li>
<li>the total memory footprint for the 2 accelerators currently in existence is 10,000KB</li>
<li>the total build time for all 10 structures that have been created is 10.2 seconds</li>
<li>the peak of total memory usage for all accelerators in the system was 14567.1KB</li>
</ul>
<p>Calling <a class="el" href="./class_m_fn_mesh.html#a16138ce87b1366bc78de69c05319c166" title='As described above, clears the "total count", "total build time", and "peak memory" fields from the i...' translate="no">clearGlobalIntersectionAcceleratorInfo()</a> will clear the "total count", "total build time", and "peak memory" fields from this information. It will not cause information about currently existing accelerators to be lost.</p>
<dl class="section return"><dt>Returns</dt><dd>The information string </dd></dl>
</div>
</div>
<a class="anchor" id="a16138ce87b1366bc78de69c05319c166"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no">void clearGlobalIntersectionAcceleratorInfo </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>As described above, clears the "total count", "total build time", and "peak memory" fields from the information string returned by <a class="el" href="./class_m_fn_mesh.html#acda309cf310fdac3ad08665c41a6bf7f" title="Retrieves a string that describes the systemwide resource usage for cached mesh intersection accelera..." translate="no">globalIntersectionAcceleratorsInfo()</a>. </p>
<p>It will not cause information about currently existing accelerators to be lost. </p>
</div>
</div>
<a class="anchor" id="a4a51a250da25c242a4f9280d5a1b2781"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool intersect </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>raySource</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>rayDirection</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>points</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>tolerance</em> = <code>kMFnMeshPointTolerance</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> * </td>
<td class="paramname"><em>polygonIds</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Determines whether the given ray intersects this polygon and if so, returns the points of intersection. </p>
<p>The points of intersection will be in order of closest point to the raySource.</p>
<p>If the polygonIds array is not nullptr then it will contain the polygon id's that correspond to the points of intersection.</p>
<p>The tolerance parameter is the epsilon value that will be used in the point-in-polygon calculation.</p>
<p>This method is not threadsafe when invoked by multiple threads on the same object at the same time. It is threadsafe as long as each thread operates on a different mesh object.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">raySource</td><td>Starting point for the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>Direction of the ray </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>Storage for any points of intersection </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Tolerance used in intersection calculation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>specifies the coordinate system for this operation </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">polygonIds</td><td>Storage for the polygon id's that correspond to the points of intersection. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The given ray intersects this polygon </li>
<li><b>false</b> The given ray does not intersect this polygon</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space transform. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad5193aa05f1daf24f9bb439d0669758a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getClosestPointAndNormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getClosestPointAndNormal </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>toThisPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>theClosestPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>theNormal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>closestPolygon</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> * </td>
<td class="paramname"><em>accelParams</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the closest point on this surface to the given point. </p>
<p>This method also returns the surface normal at that point.</p>
<p>If world space is specified then the returned point and normal will be in world space. In this case The test point (toThisPoint) is assumed to be in world space.</p>
<p>This method is not threadsafe. For a threadsafe closest point implementation, use the <a class="el" href="./class_m_mesh_intersector.html" title="Mesh intersector. " translate="no">MMeshIntersector</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">toThisPoint</td><td>Point to be compared </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">theClosestPoint</td><td>Storage for the closest point </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">theNormal</td><td>Storage for normal at the closest point </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">closestPolygon</td><td>Storage for the closest polygon id </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">accelParams</td><td>optional acceleration parameters</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a37d285a0c9e137f7ef6aedd0b180f79d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getClosestPoint"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getClosestPoint </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>toThisPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>theClosestPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>closestPolygon</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> * </td>
<td class="paramname"><em>accelParams</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the closest point on this surface to the given point. </p>
<p>If world space is specified then the returned point will be in world space. In this case The test point (toThisPoint) is assumed to be in world space.</p>
<p>This method is not threadsafe. For a threadsafe closest point implementation, use the <a class="el" href="./class_m_mesh_intersector.html" title="Mesh intersector. " translate="no">MMeshIntersector</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">toThisPoint</td><td>Point to be compared </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">theClosestPoint</td><td>Storage for the closest point </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">closestPolygon</td><td>Storage for the closest polygon id </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">accelParams</td><td>optional acceleration parameters</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5d70e4aa5fd6a04874fb17d3ab1ef2d3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getClosestNormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getClosestNormal </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>toThisPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>theNormal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>closestPolygon</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_mesh_isect_accel_params.html" translate="no">MMeshIsectAccelParams</a> * </td>
<td class="paramname"><em>accelParams</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the closest point on this surface to the given point. </p>
<p>This method also returns the surface normal at that point.</p>
<p>If world space is specified then the returned normal will be in world space. In this case The test point (toThisPoint) is assumed to be in world space.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">toThisPoint</td><td>Point to be compared </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">theNormal</td><td>Storage for normal at the closest point </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">closestPolygon</td><td>Storage for the closest polygon id </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">accelParams</td><td>optional acceleration parameters</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example21" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example21-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example21-content" style="display:none;"><dd><a class="el" href="./point_on_mesh_info_2get_point_and_normal_8cpp-example.html#a15" translate="no">pointOnMeshInfo/getPointAndNormal.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a1ef7a8385f5ed8821b93bac29e934349"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getClosestUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getClosestUVs </td>
<td>(</td>
<td class="paramtype">const float2 &amp; </td>
<td class="paramname"><em>toThisUVPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>uvIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the IDs of the UVs on this surface which are nearest in uv space to the given uv set and coordinate. </p>
<p>All these UVs locate at the same distance to the given coordinate.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">toThisUVPoint</td><td>UV coordinate to be compared </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">uvIds</td><td>The list of the closest uvs ids </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid UV set. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a2e7ae06b08040e5fb1e44dd354fc6a29"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/intersectFaceAtUV"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> intersectFaceAtUV </td>
<td>(</td>
<td class="paramtype">const float2 &amp; </td>
<td class="paramname"><em>toThisUVPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>faceId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns ID of the intersected face at given uv set and coordinate. </p>
<p>If multiple faces are intersected, the first intersected one would be returned.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">toThisUVPoint</td><td>UV coordinate to be compared </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">faceId</td><td>Intersected face ID </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid UV set. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a8b9cfa962b307bc28598b6b4885432cc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getConnectedShaders"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getConnectedShaders </td>
<td>(</td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>instanceNumber</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp; </td>
<td class="paramname"><em>shaders</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>indices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns all the shaders (sets) connected to the specified instance of this mesh, as well as an array of polygon/shader assignments. </p>
<p>The indices array will hold, for each polygon in the mesh, an index into the shaders array. If a polygon does not have a shader assigned to it, the value of the index will be -1.</p>
<p>The shader objects can be derived from the sets returned.</p>
<p>Note: This method will only work with a <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> function set which has been initialized with an <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62" title="  " translate="no">MFn::kMesh</a>.</p>
<p>See also getConnectedSetsAndMembers.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">instanceNumber</td><td>The instance number of the mesh to query </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">shaders</td><td>Storage for set objects (shader objects) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Storage for indices matching faces to shaders. For each face, this array contains the index into the shaders array for the shader assigned to the face.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a6ac85fc1c06ee8de9e5a9c3a8505fbe2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/copy"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> copy </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp; </td>
<td class="paramname"><em>source</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method creates a copy of a given source mesh. </p>
<p>After the copy this function set will operate on the new mesh.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the mesh to be copied </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>the DAG parent or kMeshData the new mesh will belong to </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> parentOrOwner was not valid; source object is not one of kMeshGeom, kMeshData, kMesh; dataMesh or underlying geometry was null; or there was no model present to add the object to </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example22" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example22-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example22-content" style="display:none;"><dd><a class="el" href="./test_nobject_node_2test_nobject_node_8cpp-example.html#a11" translate="no">testNobjectNode/testNobjectNode.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aadc717faffda37e0542fa7aae370905b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/updateSurface"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> updateSurface </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Signal that this polygonal mesh has changed and needs to redraw itself. </p>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5e980be04112646bb555d4bb865581e7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/syncObject"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> syncObject </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>If a non-api operation happens that many have changed the underlying Maya object wrapped by this api object, make sure that the api object references a valid maya object. </p>
<p>In particular this call should be used if you are calling mel commands from your plugin. Note that this only applies for mesh shapes: in a plugin node where the dataMesh is being accessed directly this is not necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example23" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example23-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example23-content" style="display:none;"><dd><a class="el" href="./gpu_cache_2_cache_writer_8cpp-example.html#a8" translate="no">gpuCache/CacheWriter.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a507441d17b470728c811d7ba8de26e46"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">const float * getRawPoints </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a pointer to the internal vertex list for this mesh. </p>
<p>The points are in local space.</p>
<p>The points are stored in a single contiguous array of floats, first by coordinate, then by element (xyzxyz...) There are three coordinate values, so each vertex is stored in 12 bytes of data, and the total array length is 12*numVertices() bytes.</p>
<p>This method is useful where performance is critical or memory resources are limited, as it avoids having to make a copy of the points as is done by getVertices. Care must be taken however as the returned pointer may become invalid if any changes are made to the mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to internal vertex list data structure</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a331efdb89bf9c388c7825d4a898a4a41"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">const double * getRawDoublePoints </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a pointer to the internal vertex list for this mesh. </p>
<p>The points are in local space.</p>
<p>The points are stored in a single contiguous array of doubles, first by coordinate, then by element (xyzxyz...) There are three coordinate values, so each vertex is stored in 24 bytes of data, and the total array length is 24*numVertices() bytes.</p>
<p>This method is useful where performance is critical or memory resources are limited, as it avoids having to make a copy of the points as is done by getVertices. Care must be taken however as the returned pointer may become invalid if any changes are made to the mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to internal vertex list data structure</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a99e9b4072cdbea8e3e350243ca7dd482"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">const float * getRawNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns a pointer to the internal normal list for this mesh. </p>
<p>The normals are in local space and are the per-polygon per-vertex normals. To find the normal for a particular vertex-face, use <a class="el" href="./class_m_fn_mesh.html#a46bb663f5ad353fcc5f8064f80a4e471" title="Return normal indices for all vertices for a given face. " translate="no">getFaceNormalIds()</a> or <a class="el" href="./class_m_it_mesh_polygon.html#a681ebea4990239248493769e34b164bd" title="Returns the normal index for the specified vertex. " translate="no">MItMeshPolygon::normalIndex</a> to get the index into the array.</p>
<p>The normals are stored in a single contiguous array of floats, first by coordinate, then by element (xyzxyz...) There are three coordinate values, so each normal is stored in 12 bytes of data, and the total array length is 12*numNormals() bytes.</p>
<p>This method is useful where performance is critical or memory resources are limited, as it avoids having to make a copy of the normals as is done by getNormals. Care must be taken however as the returned pointer may become invalid if any changes are made to the mesh.</p>
<p>This method is not threadsafe.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to internal per-polygon per-vertex normal data structure</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a38510cd198de64ad9308fb265c7e338b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPoints"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPoints </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method copies the vertex list for this mesh into the given point array. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">vertexArray</td><td>Storage for the vertex list </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example24" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example24-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example24-content" style="display:none;"><dd><a class="el" href="./sse_deformer_2sse_deformer_8cpp-example.html#a34" translate="no">sseDeformer/sseDeformer.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a5b3f852a00f3dc096c136cbe04057733"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPoints"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPoints </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method copies the vertex list for this mesh into the given point array. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">vertexArray</td><td>Storage for the vertex list </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a739dfbdbe4935389ac2d3e72d8c1f7dd"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setPoints"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setPoints </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method copies the points in the given point array to the vertices of this polygon. </p>
<p>To keep this method as fast as possible, no checking of the data is performed beyond ensuring that the total number of points passed in is correct. It is up to the caller to ensure that the points provide a valid mesh, for example by ensuring that there are no degenerate faces or non-manifold geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">vertexArray</td><td>Storage for the vertex list </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example25" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example25-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example25-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a71" translate="no">AbcImport/MeshHelper.cpp</a>, <a class="el" href="./sse_deformer_2sse_deformer_8cpp-example.html#a43" translate="no">sseDeformer/sseDeformer.cpp</a>, and <a class="el" href="./test_nobject_node_2test_nobject_node_8cpp-example.html#a16" translate="no">testNobjectNode/testNobjectNode.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a9038f53a1929f36f52e3b0e0f4658bfc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setPoints"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setPoints </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method copies the points in the given point array to the vertices of this mesh. </p>
<p>To keep this method as fast as possible, no checking of the data is performed beyond ensuring that the total number of points passed in is correct. It is up to the caller to ensure that the points provide a valid mesh, for example by ensuring that there are no degenerate faces or non-manifold geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>Storage for the vertex list </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a2f2e041f01dc1ec3648002e2524fbfbc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getVertices"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getVertices </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method retrieves the <b>object-relative (mesh-relative/global)</b> vertex indices for all polygons. </p>
<p>The indices refer to the elements in the array returned by the 'getPoints' method.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">vertexCount</td><td>Vertex count per polygon </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">vertexList</td><td>Storage for the vertex list. NOTE: Global (mesh-relative/object-relative) vertex indices are returned.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a469fc8126bc4424cd00853821d78a55a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPolygonVertices"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPolygonVertices </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method retrieves the <b>object-relative (mesh-relative/global)</b> vertex indices for the specified polygon. </p>
<p>The indices refer to the elements in the array returned by the 'getPoints' method.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon to examine </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">vertexList</td><td>Storage for the vertex list. NOTE: Global (mesh-relative/object-relative) vertex indices are returned.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygon index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example26" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example26-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example26-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#a6" translate="no">AbcExport/MayaMeshWriter.cpp</a>, <a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a20" translate="no">AbcImport/MeshHelper.cpp</a>, <a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a8" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>, and <a class="el" href="./obj_export_2obj_export_8cpp-example.html#a79" translate="no">objExport/objExport.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a78c51f79565ea0c1b4708163322ddcbd"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPolygonTriangleVertices"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPolygonTriangleVertices </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>triangleId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexList</em>[3] </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method retrieves the <b>object-relative (mesh-relative/global)</b> vertex indices for the specified triangle in the specified polygon. </p>
<p>The indices refer to the elements in the array returned by the 'getPoints' method.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon to examine </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">triangleId</td><td>The triangle within the polygon to examine (numbered from zero) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">vertexList</td><td>Storage for the vertex list. NOTE: Global (mesh-relative/object-relative) vertex indices are returned.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygon or triangle index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a930e585693bbd81b655420c8c0c9a4e5"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setPoint"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setPoint </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the position of specified vertex in the vertex list for this mesh. </p>
<p>Note that if you modify the position of a vertex for a shape, a tweak will be created. If you have a shape with no history, the first time that a tweak is created, the underlying pointers under the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> object may change. You will need to call <a class="el" href="./class_m_fn_mesh.html#a5e980be04112646bb555d4bb865581e7" title="If a non-api operation happens that many have changed the underlying Maya object wrapped by this api ..." translate="no">syncObject()</a> to make sure that the object is valid. Subsequent calls to <a class="el" href="./class_m_fn_mesh.html#a930e585693bbd81b655420c8c0c9a4e5" title="Sets the position of specified vertex in the vertex list for this mesh. " translate="no">setPoint()</a> on the same object do not require a syncObject call.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexId</td><td>The object-relative (mesh-relative/global) index of the vertex to be changed </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The new value for the vertex </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Either the vertexId is invalid, or this mesh cannot do a world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a71f31afb68fa92a69b114dd7f3cb12fa"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPoint"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPoint </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the position of the specified vertex in this mesh's vertex list. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexId</td><td>The object-relative (mesh-relative/global) index of the vertex to retrieve </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Storage for the vertex </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Either the vertexId is invalid, or this mesh cannot do a world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a638962fd4d516c8b1141be76b7405bc8"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>normals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method copies the normal list for this mesh into the given array. </p>
<p>The normals are the per-polygon per-vertex normals. To find the normal for a particular vertex-face, use <a class="el" href="./class_m_fn_mesh.html#a46bb663f5ad353fcc5f8064f80a4e471" title="Return normal indices for all vertices for a given face. " translate="no">getFaceNormalIds()</a> or <a class="el" href="./class_m_it_mesh_polygon.html#a681ebea4990239248493769e34b164bd" title="Returns the normal index for the specified vertex. " translate="no">MItMeshPolygon::normalIndex</a> to get the index into the array.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Storage for the per-polygon per-vertex normal list </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a7a23f6abaa6b22b7fbd99c4347e87237"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>normals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set the normal array (user normals) </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">normals</td><td>The normal array to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>World space or Object space</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="afa8cd3b5b04d859a9e04cd5a061e70e2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexNormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexNormal </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>normal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return a per-vertex-per-face normal for a given face (polygon) and given vertex. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of the face of interest </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh-relative/global) vertex index </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>Storage for the per-polygon-per-vertex normal </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a52b49c9c8acf2474b7b91121d33c3646"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexNormals </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>normals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return all per-vertex-per-face normals for a given face. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of the face (polygon) for which to retrive the normals </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Storage for the face normals </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="abb31da2fe90056e46874248e8cc74df6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getNormalIds"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getNormalIds </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>normalCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>normals</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return normal indices for all vertices for a all faces. </p>
<p>The normalIds can be used to index into an array returned by <a class="el" href="./class_m_fn_mesh.html#a638962fd4d516c8b1141be76b7405bc8" title="This method copies the normal list for this mesh into the given array. " translate="no">MFnMesh::getNormals()</a>;</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">normalCounts</td><td>Number of normals for each face </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Storage for the per-polygon normal ids</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a46bb663f5ad353fcc5f8064f80a4e471"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceNormalIds"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceNormalIds </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>normals</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return normal indices for all vertices for a given face. </p>
<p>The normalIds can be used to index into an array returned by <a class="el" href="./class_m_fn_mesh.html#a638962fd4d516c8b1141be76b7405bc8" title="This method copies the normal list for this mesh into the given array. " translate="no">MFnMesh::getNormals()</a>;</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of face (polygon) of interest </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Storage for the per-polygon normal ids</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a8a8b229ef7346eb7d143afb660d1dd61"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceVertexNormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceVertexNormal </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>normalIn</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set Normal for this face/vertex pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">normalIn</td><td>The normal to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceId</td><td>The face to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexId</td><td>The object-relative (mesh-relative/global) vertex index to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>World space or Object space </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid vertex id or cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a504bcb234f4f8fe4133c39826258132c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setVertexNormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setVertexNormal </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>normalIn</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set Shared Normal for this vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">normalIn</td><td>The normal to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexId</td><td>The object-relative (mesh-relative/global) vertex index to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>World space or Object space </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid vertex id or cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a793dd5effb06ae02dc67312fe03ff147"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceVertexNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceVertexNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_vector_array.html" translate="no">MVectorArray</a> &amp; </td>
<td class="paramname"><em>normalsIn</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set Normals for the given face/vertex pairs. </p>
<p>Note that if there is a vertex-face mismatch anywhere in the list, this method will return an error, and not set any of the normals.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">normalsIn</td><td>The normals to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to set them for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The object-relative (mesh-relative/global) vertex indices to set them for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>World space or Object space</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face or vertex id, one of the arrays had a different length from the others, or cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example27" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example27-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example27-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a22" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ae8a691c2b544f265d6d4f4ad7e51d9b1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setVertexNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setVertexNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_vector_array.html" translate="no">MVectorArray</a> &amp; </td>
<td class="paramname"><em>normalsIn</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set Shared Normals for these vertices. </p>
<p>The length of the normalsIn array should be same as the length of the vertexList array.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">normalsIn</td><td>The normals to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The object-relative (mesh-relative/global) vertex indices to set them for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>World space or Object space</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example28" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example28-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example28-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a17" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="afa4040e2d8b5dd180e3a87e39ff70011"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getVertexNormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getVertexNormal </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>normal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000087" translate="no">Deprecated:</a></b></dt><dd>Use getVertexNormal(int, bool, MVector&amp;, MSpace::Space) instead.</dd></dl>
<p>Return the normal at the given vertex. The returned normal is a single per-vertex normal, so unshared normals at a vertex will be averaged. See the class description for more information on normals.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexId</td><td>The object-relative (mesh-relative/global) vertex index to get the normal for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>Storage for the per-vertex normal </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example29" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example29-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example29-content" style="display:none;"><dd><a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a11" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a432134393a93bf17256582487e13af67"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getVertexNormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getVertexNormal </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>angleWeighted</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>normal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the normal at the given vertex. </p>
<p>The returned normal is a single per-vertex normal, so unshared normals at a vertex will be averaged. See the class description for more information on normals.</p>
<p>If angleWeighted is set to true, the normals are computed by an average of surrounding face normals weighted by the angle subtended by the face at the vertex. If angleWeighted is set to false, a simple average of surround face normals is returned.</p>
<p>The simple average evaluation is significantly faster than the angle-weighted average.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexId</td><td>The object-relative (mesh-relative/global) vertex index to get the normal for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">angleWeighted</td><td>Defines algorithm used to compute normal </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>Storage for the per-vertex normal </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="af50bb0d3219a83cb0ce0fcf713f8b569"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getVertexNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getVertexNormals </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>angleWeighted</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>normals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return all vertex normals. </p>
<p>The returned normals are per-vertex normals, so unshared normals at a vertex will be averaged. See the class description for more information on normals.</p>
<p>If angleWeighted is set to true, the normals are computed by an average of surrounding face normals weighted by the angle subtended by the face at the vertex. If angleWeighted is set to false, a simple average of surround face normals is returned.</p>
<p>The simple average evaluation is significantly faster than the angle-weighted average.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">angleWeighted</td><td>Defines algorithm used to compute normal </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Storage for the per-vertex normals </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a44aeccc5c93ffd991475c333a2b8e4d7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPolygonNormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPolygonNormal </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>normal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the normal at the given polygon. </p>
<p>The returned normal is a per-polygon normal. See the class description for more information on normals.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon (face) to get the normal for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>Storage for the per-polygon normal </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="afe13a3760d62c031d662a5761e6e2503"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isNormalLocked </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>normalId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Test if the normal for a face/vertex pairs is locked (user defined). </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">normalId</td><td>Normal to test. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the normal is locked. <b>false</b> if not locked.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5e1135daf5c65996f2849b81f984d455"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/lockVertexNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> lockVertexNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Lock Shared Normals for these vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The object-relative (global) verticex ides to lock normals for</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4614f4ee7780b8d4af2dfa4229cbcc91"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/lockFaceVertexNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> lockFaceVertexNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Lock Normals for these face/vertex pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to lock normal in </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The corresponding object-relative (global) vertex indices to lock them for</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a36af178d046a0fffc4fbffaba5288251"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/unlockVertexNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> unlockVertexNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Unlock Shared Normals for these vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The vertices to unlock normals for</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a1fa6951580cf45b1056fc54788652a96"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/unlockFaceVertexNormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> unlockFaceVertexNormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Unlock Normals for these face/vertex pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to unlock normal in </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The corresponding object-relative (global) vertex indices to unlock them for</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5af3ac4777497a0d4d286c8f140ad2f3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int getTangentId </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the tangent index for a given face vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of the face of interest. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh-relative/global) vertex index. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face or vertex index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="abd8b829f396f2cb6bc039dc61ca9b770"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getTangents"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getTangents </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>tangents</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the tangent vectors for all face vertices. </p>
<p>The tangent is defined as the surface tangent of the polygon running in the U direction defined by the uv map.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">tangents</td><td>Storage for the tangents. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>The uv map set to calculate the tangents against.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> UV set does not exist, or cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4846835bd50ab9b9ebcaa0e39fca7100"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexTangent"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexTangent </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>tangent</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the normalized tangent vector at a given face vertex. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of the face of interest. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh-relative/global) vertex index. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">tangent</td><td>Storage for the tangent. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>The uv map set to calculate the binormals aginst.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face or vertex index, UV set does not exist, or cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5cd47815e91c12f172579e74ea5b4ecb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexTangents"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexTangents </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>tangents</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return all per-vertex-per-face tangents for a given face. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of the face (polygon) for which to retrive the tangents </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">tangents</td><td>Storage for the face tangents </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>The uv map set to calculate the tangents aginst.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face index, UV set does not exist, or cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a761e3f3f6d2b7015ea32affb71b7a0ad"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBinormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBinormals </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>binormals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the binormal vectors for all face vertices. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">binormals</td><td>Storage for the binormals. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>The uv map set to calculate the binormals aginst.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4b6701cf574eed8602a6797687c4f77b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexBinormal"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexBinormal </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>binormal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the binormal vector at a given face vertex. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of the face of interest </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh-relative/global) vertex index </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">binormal</td><td>Storage for the binormal. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>The uv map set to calculate the binormals aginst.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Face or vertex index is invalid, UV set does not exist, or cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ae77bd36d18964cb1df36e1d000f180d3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexBinormals"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexBinormals </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>binormals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return all per-vertex-per-face binormals for a given face. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>Index of the face (polygon) for which to retrive the binormals </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">binormals</td><td>Storage for the face binormals </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Specifies the coordinate system for this operation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>The uv map set to calculate the binormals aginst.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Face index is invalid, UV set does not exist, or cannot do world space operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a641e327847996b0ca10de74960120270"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isRightHandedTangent </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>tangentId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSetName</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns true if the normal, tangent and binormal form a right handed coordinate system. </p>
<p>By default, Maya uses a right-handed system. Mirrored geometry can introduce a left-handed system.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">tangentId</td><td>tangent index for a given face vertex </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSetName</td><td>Name of uv set to use </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> normal, tangent, and binormal are right handed </li>
<li><b>false</b> normal, tangent, and binormal are left handed</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ae1a3e896586efddb2cc39fbbb023d1e2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isPolygonConvex </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method determines if the specified polygon is convex. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The polygon to be tested </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The polygon is convex </li>
<li><b>false</b> The edge is concave</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a603d73f3637830a372ab3678d24ca6e6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getEdgeVertices"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getEdgeVertices </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>edgeId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int2 &amp; </td>
<td class="paramname"><em>vertexList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method retrieves the <b>object-relative (mesh-relative/global)</b> vertex indices corresponding to the specified edge. </p>
<p>The indices can be used to refer to the elements in the array returned by the 'getPoints' method.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeId</td><td>The edge to get the vertices for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">vertexList</td><td>Storage for the 2 object-relative vertex indices</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example30" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example30-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example30-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a62" translate="no">AbcImport/MeshHelper.cpp</a>, and <a class="el" href="./mesh_op_cmd_2mesh_op_fty_action_8cpp-example.html#a5" translate="no">meshOpCmd/meshOpFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa99b5c573c92207e190bfa0cd03bf99f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isEdgeSmooth </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>edgeId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method determines if the specified edge is smooth (soft). </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeId</td><td>The edge to be tested </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The edge is smooth (soft) </li>
<li><b>false</b> The edge is hard</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a31c12a350511130133555671ce7bfbff"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setEdgeSmoothing"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setEdgeSmoothing </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>edgeId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>smooth</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method sets the specified edge to be hard or smooth (soft). </p>
<p>You must use the <b>cleanupEdgeSmoothing</b> method after all the desired edges on your mesh have had setEdgeSmoothing done. Use the <b>updateSurface</b> method to indicate the mesh needs to be redrawn.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeId</td><td>The edge to set the smoothing information for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">smooth</td><td>If true the edge will be smooth (soft), otherwise the edge will be hard.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad824622a3309e93dc8771da755531deb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setEdgeSmoothings"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setEdgeSmoothings </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>edgeIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>smooths</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method sets the specified edges to be hard or smooth (soft). </p>
<p>You must use the <b>cleanupEdgeSmoothing</b> method after all the desired edges on your mesh have had setEdgeSmoothing done. Use the <b>updateSurface</b> method to indicate the mesh needs to be redrawn.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeIds</td><td>The edges to set the smoothing information for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">smooths</td><td>If true the edges will be smooth (soft), otherwise the edges will be hard.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInvalidParameter</b> The length of edgeIds does not match smooths. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aab9e439ab36a41ba3a19c2c32faa7fe1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/cleanupEdgeSmoothing"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> cleanupEdgeSmoothing </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method updates the mesh after setEdgeSmoothing has been done. </p>
<p>This should be called only once, after all the desired edges have been had their soothing set. If you don't call this method, the normals may not be correct, and the object will look odd in shaded mode.</p>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9c7b7ddaccaf7c04d39cc1b58b99fa0b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getCreaseEdges"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getCreaseEdges </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp; </td>
<td class="paramname"><em>edgeIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>creaseData</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the crease edges of the mesh, and also the crease data associated with those edges. </p>
<p>Please note that to make effective use of the creasing variable in software outside of Maya may require a license under patents owned by Pixar(R).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">edgeIds</td><td>The list of crease edges ids. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">creaseData</td><td>The data related to the crease edges.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a62355f26f350f9725bccd7eaa7542df3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setCreaseEdges"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setCreaseEdges </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp; </td>
<td class="paramname"><em>edgeIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>creaseData</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method sets the specified edges of the mesh as crease edges. </p>
<p>Please note that to make effective use of the creasing variable in software outside of Maya may require a license under patents owned by Pixar(R).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">edgeIds</td><td>The list of crease edges ids. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">creaseData</td><td>The data related to the crease edges.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example31" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example31-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example31-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a67" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a465a9efe9747fcb28f38a43bb0b9cac5"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getInvisibleFaces"></a><a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> getInvisibleFaces </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the invisible faces of the mesh. </p>
<p>Invisible faces are like lightweight holes in that they are not rendered but do not require additional geometry the way that holes do. They have the advantage over holes that if the mesh is smoothed then their edges will be smoothed as well, while holes will retain their hard edges.</p>
<p>Invisible faces can be set using the <a class="el" href="./class_m_fn_mesh.html#a5be791c0049247ab13e27cdffff5185a" title="This method sets the specified faces of the mesh to be visible or invisible. " translate="no">setInvisibleFaces()</a> method or the polyHole command.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of invisible face ids.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5be791c0049247ab13e27cdffff5185a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setInvisibleFaces"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setInvisibleFaces </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp; </td>
<td class="paramname"><em>faceIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>makeVisible</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method sets the specified faces of the mesh to be visible or invisible. </p>
<p>See the <a class="el" href="./class_m_fn_mesh.html#a465a9efe9747fcb28f38a43bb0b9cac5" title="This method returns the invisible faces of the mesh. " translate="no">getInvisibleFaces()</a> method for a description of invisible faces.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIds</td><td>The list of face ids to be made visible/invisible. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">makeVisible</td><td>If true the faces will be made visible. The default is false, which will make them invisible.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example32" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example32-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example32-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a69" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a5714478da8dee923b4a3a045818c6240"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getCreaseVertices"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getCreaseVertices </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp; </td>
<td class="paramname"><em>vertexIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>creaseData</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the crease vertices of the mesh, and also the crease data associated with those vertices. </p>
<p>Please note that to make effective use of the creasing variable in software outside of Maya may require a license under patents owned by Pixar(R).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">vertexIds</td><td>The list of crease vertices ids. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">creaseData</td><td>The data related to the crease vertices.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a34be7d28408b76c1011d4122a90786ff"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setCreaseVertices"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setCreaseVertices </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp; </td>
<td class="paramname"><em>vertexIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>creaseData</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method sets the specified vertices of the mesh as crease vertices. </p>
<p>Please note that to make effective use of the creasing variable in software outside of Maya may require a license under patents owned by Pixar(R).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIds</td><td>The list of crease vertices ids. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">creaseData</td><td>The data related to the crease vertices.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example33" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example33-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example33-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a68" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa8c2d263dfbaa7a187f5db2c3edd565d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numUVSets </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of uv sets for an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>return status value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of uv sets for the object</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example34" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example34-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example34-content" style="display:none;"><dd><a class="el" href="./hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#a76" translate="no">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a932b175b29c42758fe67761fca275c61"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/createUVSetWithName"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> createUVSetWithName </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>uvSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> * </td>
<td class="paramname"><em>instances</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a new empty uv set for this mesh. </p>
<p>If the name passed in is empty (zero length), or a uv set with the same name already exists, then a new unique name is generated and used as the new uvset's name.</p>
<p>In the case where the name is empty, the new name will be of the format "uvSet#" where # is a number that makes the name unique for this mesh.</p>
<p>In the case where a uvset already exists with the same name as the name passed in, then the new name will be of the format "userName#", where "userName" was the name specified, and # is a number appended on to "userName" to make the name unique for this mesh.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvSetName</td><td>The name of the uv set to add. If a new name needed to be generated then the new name will be returned by the function. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code. See below. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instances</td><td>The instance number(s) for which the set should be added, or nullptr if the uv-set should be shared by all instances.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name used for the UV set. May be different then the given name if a new name needed to be generated.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a87e9c26e64ac650050d9ab32c7136e10"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/copyUVSetWithName"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> copyUVSetWithName </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>fromName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>toName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies a uv set from one to another for this mesh. </p>
<p>The source must exist. The following cases can occur:</p>
<p>1) If the destination name is the same as the source than no copy will be made. 2) If the destination name exists a copy will be made to the destination. 3) If the destination name does not exist, then a new uv set will be created with a unique name, and then the copy will be made. The name generated will be "destinationName&gt;#", where "destinationName" is the original name sent in, and "#" is a ascending number appended to the end of the original name.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">fromName</td><td>The name of the uv set to change </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">toName</td><td>The name to set the uv set to. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status Code. See below.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the new UV set. May be different then the name passed in if a new name was generated.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4aa4f41f3117c9502db9b54fb6519a7f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/renameUVSet"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> renameUVSet </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>origName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>newName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Renames a uv set from one name to another for this mesh. </p>
<p>The original name must exist, and the new name cannot be the same name as one that already exists. In these cases the uv set will not be renamed.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">origName</td><td>The name of the uv set to change </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">newName</td><td>The name to set the uv set to. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a0b2cb7f416bf34a302016ec90610325d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/deleteUVSet"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> deleteUVSet </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>setName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_selection_list.html" translate="no">MSelectionList</a> * </td>
<td class="paramname"><em>currentSelection</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Deletes a named uv set from the object. </p>
<p>If a uv set with the given name cannot be found, then no uv set will be deleted.</p>
<p>This operation only works when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">setName</td><td>Name of the uv set to delete </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">currentSelection</td><td>Since this method may change the selection list, if you wish to undo its effects, you need to keep track of the current active selection. If this selection list is non-null, then the active selection list will be returned in this argument.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a880eb944dc60e145d27dad4468c9fd11"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setCurrentUVSetName"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setCurrentUVSetName </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>setName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_selection_list.html" translate="no">MSelectionList</a> * </td>
<td class="paramname"><em>currentSelection</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set the "current" uv set for this object. </p>
<p>The "current" uv set is the uv set to use when no uv set name is specified for a uv set operation. If the uv set does not exist then the "current" uv set will not be changed.</p>
<p>This operation only works when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> is a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">setName</td><td>Name of uv set to make "current" </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">currentSelection</td><td>Since this method may change the selection list, if you wish to undo its effects, you need to keep track of the current active selection. If this selection list is non-null, then the active selection list will be returned in this argument.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example35" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example35-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example35-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a58" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a63648568635afc4b0935ee0c4d712565"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/currentUVSetName"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> currentUVSetName </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>instance</em> = <code>kMFnMeshInstanceUnspecified</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the name of the "current" uv set. </p>
<p>The "current" uv set is the uv set which is used for uv operations when no uv set is explicitly specified.</p>
<p>On instanced meshes, uv sets may be applied on a per-instance basis or may be shared across all instances. When the uv sets are per-instance, the concept of the current uv set has two levels of granularity. Namely, the current uv set applies to one or more instances, plus there are other uv sets in the same uv set family that apply to different instances. The instance arguement is used to indicate that if this is a per-instance uv set, you are interested in the name of the uv set that applies to the specified instance. When the index is not specified, the current uv set will be returned regardless of which instance it is for.</p>
<p>If there is no current uv set, then a empty string will be returned on the string argument passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>Instance of the mesh whose set we are interested in, or kMFnMeshInstanceUnspecified for the set which is shared across all instances.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UV set name.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example36" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example36-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example36-content" style="display:none;"><dd><a class="el" href="./gpu_cache_2_cache_writer_8cpp-example.html#a13" translate="no">gpuCache/CacheWriter.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a2f32f69a6f2b124ac085df4b067c76de"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getUVSetNames"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getUVSetNames </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>setNames</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the names of all of the uv sets on this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">setNames</td><td>Array of uv set names found</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example37" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example37-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example37-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a56" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a3abce34eedcd859ac99cd248a40d8fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getUVSetFamilyNames"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getUVSetFamilyNames </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>familyNames</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the names of all of the uv set families on this object. </p>
<p>A uv set family is a set of per-instance sets with the same name with each individual set applying to one or more instances. A set which is shared across all instances will be the sole member of its family.</p>
<p>Given a uv set family name, the method getUVSetsInFamily may be used to determine the names of the associated individual sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">familyNames</td><td>Array of uv set names found</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="abb8b2d8dd14a0820c822db9269d441de"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getUVSetsInFamily"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getUVSetsInFamily </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>familyName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>setNames</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the names of the uv sets that belong to this set family. </p>
<p>Per-instance sets will have multiple sets in a family, with each individual set applying to one or more instances. A set which is shared across all instances will be the sole member of its family and will share the same name as its family.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">familyName</td><td>The uv set family name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">setNames</td><td>Array of uv set names in the family</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aec1c28ba99ebf1d17834e650a96aa91e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isUVSetPerInstance </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return true if this set is per-instance, and false if it is shared across all instances. </p>
<p>The name provided may be an individual set name or a set family name.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The set name or set family name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the set is per-instance</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a21697109f56b5742839159b620d8f4a9"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceUVSetNames"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceUVSetNames </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>setNames</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the list of UV sets mapped to a face. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon ID of the face of interest </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">setNames</td><td>The string array to return the UV sets names in</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred or an internal error. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a014536ed1d56dec2e5ac51bd8b3aa36d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getAssociatedUVSetTextures"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getAssociatedUVSetTextures </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>uvSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object_array.html" translate="no">MObjectArray</a> &amp; </td>
<td class="paramname"><em>textures</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get a list of texture nodes which are using a given uv set. </p>
<p>If the texture has a 2d texture placement, the texture, and not the placement will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvSetName</td><td>Name of uv set to use </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">textures</td><td>Texture nodes using the uv set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a6a6473501431b311db95490e9759318b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getAssociatedUVSetInstances"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getAssociatedUVSetInstances </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>uvSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>instances</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get a list of the instance numbers associated with this uv map. </p>
<p>If the uv map is shared across all instances, an empty array will be returned.</p>
<p>Note, this method may only be used on an <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> that is initialized using a mesh shape. It will return failure if used on an <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> that has no associated shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvSetName</td><td>Name of uv set to use </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">instances</td><td>Instances associated with this uv set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred or the name does not exist </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a51bf5200523771e59ec4bf4c6bfdd0bc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setUVs </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>uArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>vArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets all of the texture coordinates (uv's) for this mesh. </p>
<p>The uv arrays must be of equal size and must be at least as large as the current UV set size. You can determine the UV set size by calling <a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" title="Returns the number of texture (uv) coordinates for this mesh. " translate="no">numUVs()</a> for the default UV set, or numUVs(uvSet) for a named UV set.</p>
<p>If the arrays are larger than the UV set size, then the uv list for this mesh will be grown to accommodate the new uv values.</p>
<p>After using this method to set the UV values, you must call one of the assignUV methods to assign the corresponding UV ids to the geometry.</p>
<p>In order to shrink the uvs array, do the following:</p>
<ul>
<li><a class="el" href="./class_m_fn_mesh.html#a642e3c0881f698c1a7c1ca93f0085d3b" title="This method clears out all texture coordinates for the mesh, and leaves behind an empty UVset..." translate="no">MFnMesh::clearUVs()</a> </li>
<li><a class="el" href="./class_m_fn_mesh.html#a51bf5200523771e59ec4bf4c6bfdd0bc" title="Sets all of the texture coordinates (uv's) for this mesh. " translate="no">MFnMesh::setUVs</a>( ... ) </li>
<li><a class="el" href="./class_m_fn_mesh.html#aecf710967d185b161c044dd95c04345b" title="This method maps all texture coordinates for the mesh. " translate="no">MFnMesh::assignUVs()</a></li>
</ul>
<p>These steps will let you to create an array of uvs which is smaller than the original one.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uArray</td><td>The array of u values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vArray</td><td>The array of v values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> uArray and vArray lengths do not match or the arrays are smaller than the number of UVs in the set. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example38" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example38-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example38-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a38" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aac82902d0da7b2d1addf6b01a71f7d2d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setSomeUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setSomeUVs </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>uvIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>uArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>vArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the specified texture coordinates (UV's) for this mesh. </p>
<p>The uv arrays and uvId array must be of equal size. If the largest uvId in the array is larger than <a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" title="Returns the number of texture (uv) coordinates for this mesh. " translate="no">numUVs()</a> then the uv list for this mesh will be grown to accommodate the new uv values. If a named uv set is given, the array will be grown when the largest uvId is larger than numUVs(uvSet).</p>
<p>If you have added new uvIds, you must call one of the assignUV methods to assign the uvIds to the geometry. If you are modifying existing UVs, you do not need to call one of the assignUV methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvIds</td><td>The array of uvIds to set values for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uArray</td><td>The array of u values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vArray</td><td>The array of v values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> uArray and vArray lengths do not match or the arrays are smaller than <a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" title="Returns the number of texture (uv) coordinates for this mesh. " translate="no">numUVs()</a>. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa41349e47d082451f1744cff85412159"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getUVs </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>uArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>vArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method copies the texture coordinate list for this mesh into the given uv arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">uArray</td><td>Storage for the u texture coordinate list </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">vArray</td><td>Storage for the v texture coordinate list </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example39" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example39-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example39-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#a17" translate="no">AbcExport/MayaMeshWriter.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="afe8bc4718af88a29cca9ca0729c8395a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setUV"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setUV </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>uvId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>u</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the specified texture coordinate. </p>
<p>The uvId is the element in the uv list that will be set. If the uvId is greater than or equal to <a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" title="Returns the number of texture (uv) coordinates for this mesh. " translate="no">numUVs()</a> then the uv list will be grown to accommodate the specified uv. If a named uv set is given, the largest uvId must be larger than numUVs(uvSet).</p>
<p>If the UV being added is new, then you must call one of the assignUV methods in order to update the geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvId</td><td>The element in the uv list to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The new u value that is to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The new v value that is to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example40" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example40-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example40-content" style="display:none;"><dd><a class="el" href="./split_u_v_cmd_2split_u_v_fty_action_8cpp-example.html#a16" translate="no">splitUVCmd/splitUVFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="acca758d84edf1ddc2af1177c4a6ffc2f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getUV"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getUV </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>uvId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float &amp; </td>
<td class="paramname"><em>u</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float &amp; </td>
<td class="paramname"><em>v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the value of the specified texture coordinate from this mesh's uv list. </p>
<p>The uvId is the element in the uv list that will be retrieved.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvId</td><td>The element in the uv list to examine </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Storage for the u value </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Storage for the v value </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid uvId. The uvId should be less than <a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" title="Returns the number of texture (uv) coordinates for this mesh. " translate="no">numUVs()</a> or numUVs(uvSet). </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example41" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example41-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example41-content" style="display:none;"><dd><a class="el" href="./split_u_v_cmd_2split_u_v_fty_action_8cpp-example.html#a15" translate="no">splitUVCmd/splitUVFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a111f9eefcd42b1f317d75b96fc96384a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPointAtUV"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPointAtUV </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>toThisPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float2 &amp; </td>
<td class="paramname"><em>uvPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>tolerance</em> = <code>0.0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the position of the point at the given UV value in the current polygon. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>Search for uv on this face </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">toThisPoint</td><td>Space for the point </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvPoint</td><td>The UV value to try to locate </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>The coordinate system to return "toThisPoint" in </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>tolerance value to compare float data type</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygon id or UV set, or cannot do worldSpace operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a299ae5b36f31f846e0cdde655b21988a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPointsAtUV"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPointsAtUV </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>points</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float2 &amp; </td>
<td class="paramname"><em>uvPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>tolerance</em> = <code>0.0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the positions of the points at the given UV value on the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">polygonIds</td><td>Storage for polygon ids to the return points. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>Storage for the points on this surface to the given uv set and coordinate </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvPoint</td><td>UV coordinate to be compared </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>The coordinate system to return "points" in </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>tolerance value to compare float data type</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygon id or UV set, or cannot do worldSpace operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ae28d849f5c29b8ccf09aa3800ba3a16c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getUVAtPoint"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getUVAtPoint </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>pt</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float2 &amp; </td>
<td class="paramname"><em>uvPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>closestPolygon</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Find the point closest to the given point, and return the UV value at that point. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The point to try to get UV for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">uvPoint</td><td>Space for the UV value </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>The coordinate system for this operation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">closestPolygon</td><td>polygon id of the closest polygon</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid UV set, or cannot do worldSpace operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ace39300b2f541b8928bbad517b5bfbd1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getAxisAtPoint"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getAxisAtPoint </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>pt</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>normal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>uTangent</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>vTangent</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8" translate="no">MSpace::Space</a> </td>
<td class="paramname"><em>space</em> = <code><a class="el" href="./class_m_space.html#ab11a1dda34491acff014ddfc9e6bafb8ad74f4c7c6562dc3f8339a8bba2d28dd0" translate="no">MSpace::kObject</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>closestPolygon</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Find the point on the mesh which is closest to the given point, and return the axis at that point. </p>
<p>The axis or affine space is defined by non-normalized and non-orthogonized U tangent, V tangent and normal. It's useful to detect local surface deformation for meshes with similar UV mapping.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The point to be queried </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>Space for the normal </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">uTangent</td><td>Space for the U tangent </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">vTangent</td><td>Space for the V tangent </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>The coordinate system for this operation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">closestPolygon</td><td>polygon id of the closest polygon</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid UV set, or cannot do worldSpace operation. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kNotFound</b> The given UV value is not found in face. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ae1e08bf33700cb15fd273d66063643ef"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPolygonUV"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPolygonUV </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float &amp; </td>
<td class="paramname"><em>u</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float &amp; </td>
<td class="paramname"><em>v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the value of the specified texture coordinate for a vertex in a polygon. </p>
<p>Since texture coordinates (uv's) are stored per-polygon per-vertex you must specify both the polygon and the vertex that the u and v values are mapped to.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon (face) to examine </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The face-relative (local) vertex id to examine </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Storage for the u value </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Storage for the v value </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygonId or vertexIndex specified. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a1d2b8c1536e8f4ec330ff9d83661f9bd"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPolygonUVid"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPolygonUVid </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>uvId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the id of the specified texture coordinate for a vertex in a polygon. </p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon (face) to examine </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The face-relative (local) vertex id to examine </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">uvId</td><td>Storage for the uv index </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygonId or vertexIndex specified. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example42" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example42-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example42-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#a21" translate="no">AbcExport/MayaMeshWriter.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa8f5741f8b319715af87211e8274ea79"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/assignUV"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> assignUV </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>uvId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Maps a texture coordinate to a specified vertex of a polygon. </p>
<p>Since texture coordinates (uv's) are stored per-polygon per-vertex you must specify both the polygon and the vertex that the uv entry is mapped to.</p>
<p>The vertexIndex (face-relative/local) is the vertex within the polygon that the uv will be mapped to. This index must be in the range 0 to polygonVertexCount(polygonId).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon (face) to map to </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The face-relative (local) vertex id of the polygon to map to </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvId</td><td>The uv entry from the uv list that will be mapped </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygonId, vertexIndex, or uvId specified. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example43" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example43-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example43-content" style="display:none;"><dd><a class="el" href="./split_u_v_cmd_2split_u_v_fty_action_8cpp-example.html#a17" translate="no">splitUVCmd/splitUVFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aecf710967d185b161c044dd95c04345b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/assignUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> assignUVs </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>uvCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>uvIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method maps all texture coordinates for the mesh. </p>
<p>The setUV/setUVs method is used to create the texture coordinate table for the mesh. After the table is created, this method is used to map those values to each polygon on a per-vertex basis. The setUV/setUVs method should be called before the assignUVs method.</p>
<p>The uvCounts array should contain the number of uv's per polygon. Since uv's are mapped per-polygon per-vertex, the entries in this array should match the vertex counts for each polygon in the mesh. For example, the array for a cube would be { 4, 4, 4, 4, 4, 4 } since there are 6 polygons each with 4 vertices.</p>
<p>If an entry in this array is '0' then the corresponding polygon will not be mapped. The sum of all the entries in the uvCounts array must be equal to the size of the uvIds array or this method will fail.</p>
<p>The uvIds array should contain the UV indices that will be mapped to each polygon-vertex in the mesh. The entries in this array specify which uv's in the mesh's uv table are mapped to each polygon-vertex. Each entry in the uvIds array must be less than <a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" title="Returns the number of texture (uv) coordinates for this mesh. " translate="no">numUVs()</a>, or numUVs(uvSet) for a named uvSet. The size of the uvIds array is equivalent to adding up all of the entries in the uvCounts array, so for a cube with all polygons mapped there would be 24 entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvCounts</td><td>The uv counts for each polygon (face) in the mesh </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvIds</td><td>The uv indices to be mapped to each polygon-vertex </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid uvCounts array or invalid uvIds array. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example44" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example44-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example44-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a42" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a642e3c0881f698c1a7c1ca93f0085d3b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/clearUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> clearUVs </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method clears out all texture coordinates for the mesh, and leaves behind an empty UVset. </p>
<p>This method should be used if it is needed to shrink the actual size of the UV table. In this case, the user should call clearUVs, setUVs and then assignUVs to rebuild the mapping info.</p>
<p>When called on a dataMesh, the UVs are removed. When called on a shape with no history, the UVs are removed and the attributes are set on the shape. When called on a shape with history, the polyMapDel command is invoked and a polyMapDel node is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid uvCounts array or invalid uvIds array. </li>
<li><b>MS::kInvalidIndex</b> Invalid uvSet was specified </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example45" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example45-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example45-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a36" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="abe6b4afaec85f867401eb3658c3e5459"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getAssignedUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getAssignedUVs </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>uvCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>uvIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get assigned UVs. </p>
<p>This method finds all texture coordinates for the mesh that have been mapped, and returns them in the same format as the assignUVs.</p>
<p>The uvCounts array that is returned will contain the number of uv's per polygon. Since uv's are mapped per-polygon per-vertex, the entries in this array will match the vertex counts for each polygon in the mesh. For example, the array for a cube would be { 4, 4, 4, 4, 4, 4 } since there are 6 polygons each with 4 vertices.</p>
<p>The uvIds array will contain the UV indices that are mapped to each polygon-vertex in the mesh. The entries in this array indicate which uv's in the mesh's uv table are mapped to each polygon-vertex. Each entry in the uvIds array will be less than <a class="el" href="./class_m_fn_mesh.html#a8ec9383ddfdf01902e7d5c8affd0c14c" title="Returns the number of texture (uv) coordinates for this mesh. " translate="no">numUVs()</a>, or numUVs(uvSet) for a named uvSet. The size of the uvIds array is equivalent to adding up all of the entries in the uvCounts array, so for a cube with all polygons mapped there will be 24 entries.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">uvCounts</td><td>The container for the uv counts for each polygon in the mesh </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">uvIds</td><td>The container for the uv indices mapped to each polygon-vertex </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid uvCounts array or invalid uvIds array. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a2261151d90491f3cef9ae854972798b4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getUvShellsIds"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getUvShellsIds </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>uvShellIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int &amp; </td>
<td class="paramname"><em>nbUvShells</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Constructs an array of unique integer for each UV shell. </p>
<p>This method let the user identify each connected piece of UV.</p>
<p>The uvShellIds array that is returned will contain a UV shell number for each UV in the given UV set. This number uniquely identifies a connected piece in the UV set. Numbers are positive, starting at 0.</p>
<p>For example, the array { 0, 0, 0, 1, 1, 1, 1, 0} would represent an object where UVs 0, 1, 2 and 7 are connected together (UV shell number 0), and UVs 3 to 6 belong to shell number 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">uvShellIds</td><td>The container for the uv shell Ids </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">nbUvShells</td><td>The number of UV shells in this UV set. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9d819fc02dc71cf37f5aa45db4f7df69"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getPinUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getPinUVs </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp; </td>
<td class="paramname"><em>uvIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>pinData</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method returns the pin uvs of the mesh, and also the pin data associated with those uvs. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">uvIds</td><td>The list of pin uvs ids. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">pinData</td><td>The list of pin weights. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a696b96be712e4cd8c8b383c6ce3a6f94"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setPinUVs"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setPinUVs </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> &amp; </td>
<td class="paramname"><em>uvIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>pinData</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method sets the specified uvs of the mesh as "pinned" uvs, a "pinned" uv is one which should not be modified. </p>
<p>If pin weight is set to 1.0 then it becomes fully pinned and uv tools should not modify that uv. If the pin weight is set to a value between 0.0 and 1.0 then uv tools should weight their changes to that uv accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvIds</td><td>The list of pin uvs ids. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pinData</td><td>The list of pin weights. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a8260a31521263408c478daf5eaffc881"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isPolygonUVReversed </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>uvSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method determines if the winding order of texture coordinates (uv's) for specified polygon are reversed (clockwise) </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon to be tested </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">uvSet</td><td>UV set to work with </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The texture coordinates (uv's) are reversed (clockwise) </li>
<li><b>false</b> The texture coordinates (uv's) are not reversed (counter clockwise)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ac82916690bb9966bdc05d342bb48cc08"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int numColorSets </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of color sets for an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>return status value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of color sets for the object</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example46" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example46-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example46-content" style="display:none;"><dd><a class="el" href="./hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#a97" translate="no">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ac392a4fcb7da0759a4301119a395bcd7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/createColorSetWithName"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> createColorSetWithName </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> * </td>
<td class="paramname"><em>instances</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a new empty color set for this mesh. </p>
<p>If the name passed in is empty (zero length), or a color set with the same name already exists, then a new unique name is generated and used as the new color set's name.</p>
<p>In the case where the name is empty, the new name will be of the format "colorSet#" where # is a number that makes the name unique for this mesh.</p>
<p>In the case where a color set already exists with the same name as the name passed in, then the new name will be of the format "userName#", where "userName" was the name specified, and # is a number appended on to "userName" to make the name unique for this mesh.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSetName</td><td>The name of the color set to add. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instances</td><td>The instance number(s) for which the set should be added, or nullptr if the uv-set should be shared by all instances. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ReturnStatus</td><td>Status code. See below.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting name of the color set.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example47" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example47-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example47-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a47" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="acbcb4e7049e79e14b523a8edfb5b4d42"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/deleteColorSet"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> deleteColorSet </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_selection_list.html" translate="no">MSelectionList</a> * </td>
<td class="paramname"><em>currentSelection</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Deletes a named color set from the object. </p>
<p>If a color set with the given name cannot be found, then no color set will be deleted.</p>
<p>This operation only works when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSetName</td><td>Name of the color set to delete </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">currentSelection</td><td>Since this method may change the selection list, if you wish to undo its effects, you need to keep track of the current active selection. If this selection list is non-null, then the active selection list will be returned in this argument.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ae4acd6b84edaab8e7b6234db0337021b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setCurrentColorSetName"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setCurrentColorSetName </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>setName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_selection_list.html" translate="no">MSelectionList</a> * </td>
<td class="paramname"><em>currentSelection</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set the "current" or "working" color set for this object. </p>
<p>The "current" color set is the set to use by functions that do not have a specific color set defined.</p>
<p>This operation only works when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> is a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">setName</td><td>Name of color set to make "current" </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">currentSelection</td><td>Since this method may change the selection list, if you wish to undo its effects, you need to keep track of the current active selection. If this selection list is non-null, then the active selection list will be returned in this argument.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example48" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example48-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example48-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a48" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a05a2db74b6cfc632c605cbac1363eb99"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/currentColorSetName"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> currentColorSetName </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>instance</em> = <code>kMFnMeshInstanceUnspecified</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the name of the "current" or "working" color set. </p>
<p>The "current" color set is the color set which is used for color operations when no color set is explcitly specified.</p>
<p>If there is no current color set, then a empty string will be returned on the string argument passed on.</p>
<p>On instanced meshes, color sets may be applied on a per-instance basis or may be shared across all instances. When the color sets are per-instance, the concept of the current color set has two levels of granularity. Namely, the current color set applies to one or more instances, plus there are other color sets in the same color set family that apply to different instances. The instance arguement is used to indicate that if this is a per-instance color set, you are interested in the name of the color set that applies to the specified instance. When the index is not specified, the current color set will be returned regardless of which instance it is for.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>Instance of the mesh whose set we are interested in, or kMFnMeshInstanceUnspecified for the set which is shared across all instances. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code. See below.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Name of the "current" color set, if any.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa5f322f25f97f76df932054bf5847c8e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getColorSetNames"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getColorSetNames </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>setNames</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the names of all of the colors sets on this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">setNames</td><td>Array of color set names found</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example49" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example49-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example49-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a60" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a9900f1475febb7c47b7a1a435951632f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getColorSetFamilyNames"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getColorSetFamilyNames </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>familyNames</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the names of all of the color set families on this object. </p>
<p>A color set family is a set of per-instance sets with the same name with each individual set applying to one or more instances. A set which is shared across all instances will be the sole member of its family.</p>
<p>Given a color set family name, the method getColorSetsInFamily may be used to determine the names of the associated individual sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">familyNames</td><td>Array of color set names found</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad955599df74aa3caffcaedda6920ebf4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getColorSetsInFamily"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getColorSetsInFamily </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>familyName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>setNames</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the names of the color sets that belong to this set family. </p>
<p>Per-instance sets will have multiple sets in a family, with each individual set applying to one or more instances. A set which is shared across all instances will be the sole member of its family and will share the same name as its family.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">familyName</td><td>The color set family name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">setNames</td><td>Array of color set names in the family</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a41682009252ece153547b52bc7ab17ab"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isColorSetPerInstance </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Return true if this color set is per-instance, and false if it is shared across all instances. </p>
<p>The name provided may be an individual set name or a set family name.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The set name or set family name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the set is per-instance</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a6ddc617454101d1e0b63607e4f70278b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getAssociatedColorSetInstances"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getAssociatedColorSetInstances </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>instances</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get a list of the instance numbers associated with this color map. </p>
<p>If the color map is shared across all instances, an empty array will be returned.</p>
<p>Note, this method may only be used on an <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> that is initialized using a mesh shape. It will return failure if used on an <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> that has no associated shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSetName</td><td>Name of color set to use </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">instances</td><td>Instances associated with this color set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred or the name does not exist </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a2a51e9229a7b5e6d74c1bd5d1ad81864"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceColor </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set vertex-face Color for all vertices on this face. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face to set it for</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInvalidParameter</b> 'faceIndex' was not valid. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aed7bf1abff6c273198f4603222adb82b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceColor </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set vertex-face Color of specified channels for all vertices on this face. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a7b2000791e09a5ab2759ee23044257a9"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setVertexColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setVertexColor </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color for this vertex. </p>
<p>The color is set for the vertex-face in each face that the vertex belongs to.</p>
<p>NOTE: To change the colors of many vertices, it is more efficient to use the batch updating method <a class="el" href="./class_m_fn_mesh.html#ac87fe328d734133476d0ae30796c7400" title="Set color for these vertices. " translate="no">setVertexColors()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh-relative/global) vertex index to set it for </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInvalidParameter</b> 'vertexIndex' was not valid. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a39583d4ee99520690256b8b09619ed94"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setVertexColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setVertexColor </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color of specified channels for this vertex. </p>
<p>The color is set for the vertex-face in each face that the vertex belongs to.</p>
<p>NOTE: To change the colors of many vertices, it is more efficient to use the batch updating method <a class="el" href="./class_m_fn_mesh.html#ac87fe328d734133476d0ae30796c7400" title="Set color for these vertices. " translate="no">setVertexColors()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh-relative/global) vertex index to set it for </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid vertex index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9460ef56bb85ffa256e9ec54d980ea23"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceVertexColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceVertexColor </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color for this vertex in this face. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh_relative/global) vertex index to set it for </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInvalidParameter</b> 'faceIndex' or 'vertexIndex' was not valid. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aec0a38ef3939e21f7169df3647519d96"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceVertexColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceVertexColor </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color of specified channels for this vertex in this face. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh_relative/global) vertex index to set it for </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face or vertex index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a6d5b048dcb3dd6eb1f3572ed324007b8"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceVertexColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceVertexColor </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>localVertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color for this vertex in this face. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">localVertexIndex</td><td>The face-relative (local) vertex index to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to set </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInvalidParameter</b> 'faceIndex' or 'localVertexIndex' was not valid. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad22efa21c2b6e10b04bcf9702361153b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceVertexColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceVertexColor </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>localVertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color of specified channels for this vertex in this face. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">localVertexIndex</td><td>The face-relative (local) vertex index to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to set </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face or vertex index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a66524d11f38db3801bcf91279cbf2f8e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color for these faces. </p>
<p>The color will be set for each vertex-face component of a face.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colors</td><td>The colors to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to set it for</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInvalidParameter</b> 'faceList' contained an invalid face index or did not have the same number of elements as 'colors'. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9caebc9990d005fd57bc5d299c510a1e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color of specified channels for these faces. </p>
<p>The color will be set for each vertex-face component of a face.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colors</td><td>The colors to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> 'faceList' contained an invalid face index or did not have the same number of elements as 'colors'. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ac87fe328d734133476d0ae30796c7400"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setVertexColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setVertexColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color for these vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colors</td><td>The colors to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The vertices to set it for </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInvalidParameter</b> 'vertexList' contained an invalid vertex index or did not have the same number of elements as 'colors'. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a7cc0efa066a791af527a2540f2cc26ab"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setVertexColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setVertexColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set color of specified channels for these vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colors</td><td>The colors to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The vertices to set it for </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> 'vertexList' contained an invalid vertex index or did not have the same number of elements as 'colors'. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a005ad2f6fc047c8bd7bf5d00ccd69084"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceVertexColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceVertexColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set colors for these face/vertex pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colors</td><td>The colors to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The object-relative (mesh-relative/global) vertex indices to set it for </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInvalidParameter</b> 'faceList' contained an invalid face index, 'vertexList' contained an invalid vertex index, or they did not have the same number of elements as 'colors', </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a376d72dd5ca14631c23c001cc202d778"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFaceVertexColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFaceVertexColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set colors of specified channels for these face/vertex pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colors</td><td>The colors to set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to set it for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The object-relative (mesh-relative/global) vertex indices to set it for </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> 'faceList' contained an invalid face index, 'vertexList' contained an invalid vertex index, or they did not have the same number of elements as 'colors'. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ab6c8410fa9ddf943401053bdee6a106e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/removeFaceColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> removeFaceColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove previously set color these faces. </p>
<p>For each face, the color will be unset for each vertex-face component in the face.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to remove color from</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> 'faceList' contained an invalid face index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a37878b3ef7f30b2316caa1711f227a72"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/removeVertexColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> removeVertexColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove color from these vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The object-relative (mesh-relative/global) vertex indices to remove color from</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4f4f4dad9160a70f8610b23269bf7725"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/removeFaceVertexColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> removeFaceVertexColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>faceList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>vertexList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove colors for these face/vertex pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceList</td><td>The faces to remove color for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexList</td><td>The corresponding object-relative (mesh-relative/global) vertex indices to remove color for</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> 'faceList' and 'vertexList' did not have the same number of elements. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a8bb405fe0fb575fc31c6b3be5174a445"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getVertexColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getVertexColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_color.html" translate="no">MColor</a> * </td>
<td class="paramname"><em>defaultUnsetColor</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get colors for all Vertices of the given colorSet. </p>
<p>If the colorSet is not specified, the default color set will be used. If no vertex/face has color for that vertex, the entry returned will be defaultUnsetColor. If the defaultUnsetColor is not given, then (-1, -1, -1, -1) will be used. If a color was set for some or all the faces for that vertex, an average of those verted/face values where the color has been set will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">colors</td><td>Storage for the colors to be returned. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">defaultUnsetColor</td><td>Default Unset color</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a2489d7d07e535211e2ab49a1a1f14c7e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_color.html" translate="no">MColor</a> * </td>
<td class="paramname"><em>defaultUnsetColor</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get colors for all vertex/faces of the given color set. </p>
<p>If the color set is not specified, the default color set will be used. If no vertex/face has color for that vertex, the entry returned will be defaultUnsetColor. If defaultUnsetColor is not given, then (-1, -1, -1, -1) will be used. If a color was set for some but not all the faces for that vertex, the ones where the color has not been explicitly set will have (0,0,0). If a vertex has shared color, the same value will be set for all its vertes/faces.</p>
<p>The colors are returned in face order: e.g. F0V0, F0V1.. F0Vn, F1V0, etc... Use the index returned by getFaceVertexColorIndex if you wish to index directly into the returned color array.</p>
<p>This method is not threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">colors</td><td>Storage for the colors to be returned. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">defaultUnsetColor</td><td>Default unset color</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a83d8e021c382b54ba0eef0b3718d04f8"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexColorIndex"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexColorIndex </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>localVertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>colorIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get an index into the array returned by getFaceVertexColors. </p>
<p>So that you can index into the array directly, instead of walking it in face-vertex order.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face to look for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">localVertexIndex</td><td>The face-relative (local) vertex id to look for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">colorIndex</td><td>Storage for the color index to be returned. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face or vertex index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa770030da9bf7ac10dcb6d554edd2ebf"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setColors </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colorArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets all of the colors for this mesh. </p>
<p>The color array must be at least as large as the current color set size. You can determine the color set size by calling <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a> for the default color set, or numColors(colorSet) for a named color set.</p>
<p>If the array is larger than the color set size, then the color list for this mesh will be grown to accommodate the new color values.</p>
<p>After using this method to set the color values, you can call assignColors to assign the corresponding color ids to the geometry.</p>
<p>In order to shrink the color array, do the following:</p>
<ul>
<li><a class="el" href="./class_m_fn_mesh.html#a8ef0e983f8284a5c2d762984ca49beed" title="This method clears out all color for the mesh, and leaves behind an empty color set. " translate="no">MFnMesh::clearColors()</a> </li>
<li><a class="el" href="./class_m_fn_mesh.html#aa770030da9bf7ac10dcb6d554edd2ebf" title="Sets all of the colors for this mesh. " translate="no">MFnMesh::setColors</a>( ... ) </li>
<li><a class="el" href="./class_m_fn_mesh.html#a9db86252d7a7d109c5b496207168bc20" title="This method maps all colors for the mesh. " translate="no">MFnMesh::assignColors()</a></li>
</ul>
<p>These steps will let you to create an array of colors which is smaller than the original one.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorArray</td><td>The array of color values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>The color set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The colorArray length is smaller than the number of colors in the set. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example50" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example50-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example50-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a51" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a87d355d41093d740991ecd823dd3faf7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setColors </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colorArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets all of the colors of specified channels for this mesh. </p>
<p>The color array must be at least as large as the current color set size. You can determine the color set size by calling <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a> for the default color set, or numColors(colorSet) for a named color set.</p>
<p>If the array is larger than the color set size, then the color list for this mesh will be grown to accommodate the new color values.</p>
<p>After using this method to set the color values, you can call assignColors to assign the corresponding color ids to the geometry.</p>
<p>In order to shrink the color array, do the following:</p>
<ul>
<li><a class="el" href="./class_m_fn_mesh.html#a8ef0e983f8284a5c2d762984ca49beed" title="This method clears out all color for the mesh, and leaves behind an empty color set. " translate="no">MFnMesh::clearColors()</a> </li>
<li><a class="el" href="./class_m_fn_mesh.html#aa770030da9bf7ac10dcb6d554edd2ebf" title="Sets all of the colors for this mesh. " translate="no">MFnMesh::setColors</a>( ... ) </li>
<li><a class="el" href="./class_m_fn_mesh.html#a9db86252d7a7d109c5b496207168bc20" title="This method maps all colors for the mesh. " translate="no">MFnMesh::assignColors()</a></li>
</ul>
<p>These steps will let you to create an array of colors which is smaller than the original one.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorArray</td><td>The array of color values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>The color set to work with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> The colorArray length is smaller than the number of colors in the set. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa694d787411ae5bed8972540ff42fcbd"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setSomeColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setSomeColors </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>colorIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colorArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the specified colors for this mesh. </p>
<p>If the largest colorId in the array is larger than <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a> then the color list for this mesh will be grown to accommodate the new color values.</p>
<p>If you have added new colorIds, you can call assignColors to assign the colorIds to the geometry. If you are modifying existing colors, they will already be referenced by the existing mesh data.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorIds</td><td>The array of colorIds to set values for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorArray</td><td>The array of color values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> colorArray lengths do not match or the arrays are smaller than <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a>. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a43afde2802b2ec0da53095fdcda3db34"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setSomeColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setSomeColors </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>colorIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colorArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the specified colors of specified channels for this mesh. </p>
<p>If the largest colorId in the array is larger than <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a> then the color list for this mesh will be grown to accommodate the new color values.</p>
<p>If you have added new colorIds, you can call assignColors to assign the colorIds to the geometry. If you are modifying existing colors, they will already be referenced by the existing mesh data.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorIds</td><td>The array of colorIds to set values for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorArray</td><td>The array of color values to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> colorArray lengths do not match or the arrays are smaller than <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a>. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a01a4bbfbbe031efd14ee58771d38d236"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_color_array.html" translate="no">MColorArray</a> &amp; </td>
<td class="paramname"><em>colorArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_color.html" translate="no">MColor</a> * </td>
<td class="paramname"><em>defaultUnsetColor</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method copies the color array for this mesh into the given color array. </p>
<p>Use the index returned by getColorIndex to access the array. If the color is not set for a vertex, defaultUnsetColor will be return. If defaultUnsetColor is not set, (0,0,0,1) will be return.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">colorArray</td><td>Storage for the color values list </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">defaultUnsetColor</td><td>Default unset color</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example51" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example51-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example51-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#a3" translate="no">AbcExport/MayaMeshWriter.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="adcc83c6ccc1cbd3cdd5ed6668a149d1f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getColorIndex"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getColorIndex </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>localVertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>colorIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get an index into the array returned by getColors. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face to look for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">localVertexIndex</td><td>The face-relative (local) vertex id to look for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">colorIndex</td><td>Storage for the color index to be returned. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. If no color exists for faceIndex/localVertexIndex, then the colorIndex will return -1. </li>
<li><b>MS::kInvalidParameter</b> Invalid face or vertex index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example52" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example52-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example52-content" style="display:none;"><dd><a class="el" href="./_abc_export_2_maya_mesh_writer_8cpp-example.html#a8" translate="no">AbcExport/MayaMeshWriter.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="acd93503d62808228cbd46f80fb1d53cb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setColor </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>colorId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the specified color values. </p>
<p>The colorId is the element in the color list that will be set. If the colorId is greater than or equal to <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a> then the color list will be grown to accommodate the specified color.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorId</td><td>The element in the color list to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The new color value that is to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad424faddd9b4c9bd31bbf79e05cf6313"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setColor </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>colorId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the specified color values of specified channels. </p>
<p>The colorId is the element in the color list that will be set. If the colorId is greater than or equal to <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a> then the color list will be grown to accommodate the specified color.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorId</td><td>The element in the color list to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The new color value that is to be set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The RGB/RGBA/A channel(s) to set</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad66fe51355fa1faf66ddc616c1884692"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getColor </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>colorId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_color.html" translate="no">MColor</a> &amp; </td>
<td class="paramname"><em>color</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_color.html" translate="no">MColor</a> * </td>
<td class="paramname"><em>defaultUnsetColor</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the value of the specified texture coordinate from this mesh's color list. </p>
<p>The colorId is the element in the color list that will be retrieved. If the color is not set, defaultUnsetColor will be return. If defaultUnsetColor is not set, (0,0,0,1) will be return.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorId</td><td>The element in the color list to examine </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">color</td><td>Storage for the color value </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">defaultUnsetColor</td><td>default unset color</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid colorId. The colorId should be less than <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a> or numColors(colorSet). </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a3949b8d4c4f589ac2d6a1aa23d8493ac"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/assignColor"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> assignColor </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>colorId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Maps a color value to a specified vertex of a polygon. </p>
<p>Since color (vertex data) are stored per-polygon per-vertex you must specify both the polygon and the vertex that the color entry is mapped to.</p>
<p>The vertexIndex (face-relative/local) is the vertex within the polygon that the color will be mapped to. This index must be in the range 0 to polygonVertexCount(polygonId).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon (face) to map to </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The face-relative (local) vertex id of the polygon to map to </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorId</td><td>The color entry from the color list that will be mapped </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygonId, vertexIndex, or colorId specified. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9db86252d7a7d109c5b496207168bc20"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/assignColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> assignColors </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>colorIds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method maps all colors for the mesh. </p>
<p>The setColor/setColors method is used to create a color table for the mesh. After the table is created, this method is used to map those values to each polygon on a per-vertex basis. The setColor/setColors method should be called before the assignColors method.</p>
<p>The colorIds array should contain the color indices that will be mapped to each polygon-vertex in the mesh. The entries in this array specify which colors in the mesh's color table are mapped to each polygon-vertex. Each entry in the colorIds array must be less than <a class="el" href="./class_m_fn_mesh.html#a8eba9438fe4c6ab02d307cc02261193e" title="Returns the number of (vertex) color for this mesh. " translate="no">numColors()</a>, or numColors(colorSet) for a named colorSet. The size of the colorIds array is equivalent to the number of polygon-vertices, so for a cube with all polygons mapped there would be 24 entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorIds</td><td>The color indices to be mapped to each polygon-vertex </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid color set or colorIds array. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example53" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example53-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example53-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a52" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a8ef0e983f8284a5c2d762984ca49beed"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/clearColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> clearColors </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> * </td>
<td class="paramname"><em>colorSet</em> = <code>NULL</code></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method clears out all color for the mesh, and leaves behind an empty color set. </p>
<p>This method should be used if it is needed to shrink the actual size of the color table. In this case, the user should call clearColors, setColors and then assignColors to rebuild the color mapping info.</p>
<p>When called on a dataMesh, the colors are removed. When called on a shape with no history, the colors are removed and the attributes are set on the shape. When called on a shape with history, the polyColorDel command is invoked and a polyColorDel node is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSet</td><td>Color set to work with</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid colorIds array. </li>
<li><b>MS::kInvalidIndex</b> Invalid colorSet was specified </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a97ab47fbb3cbfab6f1d6899d255b32e8"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool displayColors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Determine if the mesh node is set to display vertex colors. </p>
<p>The display of vertex colors is controlled by the mesh node itself. It is not part of the mesh data. Therefore this method is only valid when the function set is operating on a mesh node. It will return a failure status if called when the function set is operating on mesh data.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>The return status of the method</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mesh node is set to display vertex colors. False otherwise.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> The function set was not initialized with a node. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ac5b1b4574da46a7530b5c2782e08ab05"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setDisplayColors"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setDisplayColors </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>enable</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set whether the mesh node should display vertex colors. </p>
<p>The display of vertex colors is controlled by the mesh node itself. It is not part of the mesh data. Therefore this method is only valid when the function set is operating on a mesh node. It will return a failure status if called when the function set is operating on mesh data.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>True to turn on color display, false to turn it off.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> The function set was not initialized with a node, or the node's displayColors attribute could not be set (e.g. node or attribute is locked). </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example54" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example54-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example54-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a49" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ab0e871427039e4f00635a3c5b4af19f1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">int getHoles </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>holeInfoArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>holeVertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieves a list of the holes in the polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">holeInfoArray</td><td>Receives an array of integer triples, one for each hole in the mesh. The first element in each triple represents the index of the holed face. The next two elements represent the number of vertices in the hole and the hole's start index in list of hole vertices in <b>holeVertexArray</b>, respectively. For example, if <b>holeInfoArray</b> = [ 0, 3, 0, 1, 4, 3 ], then this means that face 0 contains a 3-vertex hole whose vertex indices are stored in elements 0, 1, 2 of <b>holeVertexArray</b>, and face 1 contains a 4-vertex hole whose vertex indices are stored in elements 3, 4, 5, 6 of <b>holeVertexArray</b>. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">holeVertexArray</td><td>Receives an array consisting of the vertex indices of every hole in the mesh. The third element of each triple in <b>holeInfoArray</b> is the index of the start of a particular hole's vertex list in this array. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of holes in the mesh.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example55" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example55-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example55-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a70" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a012df987a82e008e957d1946738485cf"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool onBoundary </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>polygonId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>A method to determines whether the specified face in the mesh is a boundary face. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">polygonId</td><td>The polygon (face) to examine </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>The return status of the method</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true If the specified edge is on the border of the object. </li>
<li>false If the specified edge is not on the boundary of the object.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid polygonId was specified </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="af736cc3ed8a3c7c459098b5c9470c1ff"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool isBlindDataTypeUsed </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Is this BlindData type id is already in use in this scene? </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status Code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: Id in use, false: id not in use</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example56" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example56-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example56-content" style="display:none;"><dd><a class="el" href="./blind_data_shader_2blind_data_mesh_8cpp-example.html#a28" translate="no">blindDataShader/blindDataMesh.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa5352e346243d140b7b30ac4242db937"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/createBlindDataType"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> createBlindDataType </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> </td>
<td class="paramname"><em>longNames</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> </td>
<td class="paramname"><em>shortNames</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> </td>
<td class="paramname"><em>formatNames</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a new blind data type. </p>
<p>If the type id is already in use, this method will fail. Format names must be one of "int" "float" "double" "boolean" "string" "binary".</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">longNames</td><td>Attribute long names </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">shortNames</td><td>Attribute short names </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">formatNames</td><td>Names of the data types.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Could not create blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example57" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example57-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example57-content" style="display:none;"><dd><a class="el" href="./blind_data_shader_2blind_data_mesh_8cpp-example.html#a31" translate="no">blindDataShader/blindDataMesh.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a487f967198f594a077152f3999839726"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool hasBlindDataComponentId </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Does this component have blind data with the given ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to check for blind data om When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status Code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: has the specified blind data, false: does not</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a5e98180f88babf1b2d45c7c16d8ae286"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool hasBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns true if any component of the given type on this mesh have blind data with the given ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status Code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: has the specified blind data, false: does not</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4757e5f831a9a1a76c67fc79d18791de"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool hasBlindDataComponentId </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Does this component have any kind of blind data. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to check for blind data on When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status Code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: has the specified blind data, false: does not</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="afbce826a6cca065c8d9ffa0a84728eaa"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool hasBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Does any component of this type have any blind data. </p>
<p>(.e. is there any vertex blind data on this mesh?)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status Code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: has the specified blind data, false: does not</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a88317bf90ae2703149ec9ab200967244"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBlindDataTypes"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBlindDataTypes </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>blindDataIds</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the list of blind data ID's associated with the given component type on this mesh. </p>
<p>(e.g. all blind data ID's present on vertex compontents)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">blindDataIds</td><td>space for this list of blind data id values.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a96c262ac789d822a21278e744152f53b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBlindDataAttrNames"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBlindDataAttrNames </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>longNames</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>shortNames</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>formatNames</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data attribute names and types for the specified blind data type id. </p>
<p>Format names will be one of "int" "float" "double" "boolean" "string" "binary".</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">longNames</td><td>Space for the attribute long names </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">shortNames</td><td>Space for the attribute short names </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">formatNames</td><td>Space for the data format names</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. The specified blind data type does not exist. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="af18375adb69e719960a46d972fa0e962"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFaceVertexBlindDataIndex"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFaceVertexBlindDataIndex </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>vertexIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>blindDataIndex</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the single index to retrieve face-vertex blind data. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index to look for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh-relative/global) vertex index </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">blindDataIndex</td><td>The component index for face vertex blind data storage to be returned</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid face or vertex index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="adfaf9bba50f6afd2dad942ccf15daf30"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBlindDataFaceVertexIndices"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBlindDataFaceVertexIndices </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>faceIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>vertexIndex</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the face and vertex indices from the face-vertex blind data index. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataIndex</td><td>The component index for face vertex blind data storage to decompose </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The corresponding face index to be returned </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">vertexIndex</td><td>The object-relative (mesh-relative/global) vertex index to be returned</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid blind data, face or vertex index. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a52ca8bcf4dbe0c7ad1b0a0e201c6b491"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getIntBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getIntBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute of the specified component. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to get for blind data on. When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data item</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="afc60db4cc7e04e622e4021ff25934f62"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getIntBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getIntBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute of the given type of component. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">compIDs</td><td>Space for the component indexes of the items When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data items</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: has the specified blind data, false: does not</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="adc8318ebcbc33cb018df5d930aa03719"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFloatBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFloatBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute of the specified component. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to get for blind data on When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data item</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a1e748730e9f9c113f7e5aef0786ae0f1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getFloatBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getFloatBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute for all components of the given type. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">compIDs</td><td>Space for the component indexes of the items When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data items</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a7d6413a5c91c2acccd833ccfecdeb896"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getDoubleBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getDoubleBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute of the specified component. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to get for blind data on When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data item</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa6c7a6b3b64285b48430e3c6f5c653fb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getDoubleBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getDoubleBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute for all components of the given type. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">compIDs</td><td>Space for the component indexes of the items When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data items</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4fe04d06c0667b67ed7c8f29dfaf86b5"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBoolBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBoolBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute of the specified component. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to get for blind data on When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data item</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a26f7a0e414b6f5145da4ba8dc24e956e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBoolBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBoolBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute for all components of the given type. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">compIDs</td><td>Space for the component indexes of the items When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data items (note that we return the bool data as an <a class="el" href="./class_m_int_array.html" title="Array of integers data type. " translate="no">MIntArray</a> since we don't have a convenient bool array type</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="abc88d2109836b63f72ddfd7fe7aaeb86"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/stringBlindDataComponentId"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> stringBlindDataComponentId </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute of the specified component. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to get for blind data on When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code. See below.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Blind data.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a1705fdf45427c7b5992c67e919d4db61"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getStringBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getStringBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute for all components of the given type. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">compIDs</td><td>Space for the component indexes of the items When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data items (note that we return the bool data as an <a class="el" href="./class_m_int_array.html" title="Array of integers data type. " translate="no">MIntArray</a> since we don't have a convenient bool array type</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="af2a541f1ff4a7416acc6fe477594524d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/binaryBlindDataComponentId"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> binaryBlindDataComponentId </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute of the specified component. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to get for blind data on When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code. See below.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data item.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a40f5742295cb83ad317ca12e7f73a5d6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBinaryBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBinaryBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data value for the specified blind data attribute for all components of the given type. </p>
<p>If the type of the attribute is not correct, this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute name </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">compIDs</td><td>Space for the component indexes of the items When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Space for the data items (note that we return the bool data as an <a class="el" href="./class_m_int_array.html" title="Array of integers data type. " translate="no">MIntArray</a> since we don't have a convenient bool array type</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a7518cd0a4dcb82857af9a85871beec21"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setIntBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setIntBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for an integer blind data attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a029bbec6cd39909312df1278d5f76371"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setIntBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setIntBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for an integer blind data on an array of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad9d25268bef268ae9cd8e93ec345497f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setIntBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setIntBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a values for an integer blind data on an array of components. </p>
<p>The arrays of values and components must be the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The attribute values for each component</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a589e38acc86daee4382134afd8199125"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFloatBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFloatBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for a float blind data attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a44fc02d1a8a25dabd8d731119d2bc0e7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFloatBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFloatBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for float blind data on an array of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9abee1b8736ee341eb92d4b2b54275b1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setFloatBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setFloatBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_float_array.html" translate="no">MFloatArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a values for a float blind data on an array of components. </p>
<p>The arrays of values and components must be the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The attribute values for each component</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ae53fe2c510e9221ac92d64b8562c39af"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setDoubleBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setDoubleBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for a double blind data attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example58" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example58-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example58-content" style="display:none;"><dd><a class="el" href="./blind_data_shader_2blind_data_mesh_8cpp-example.html#a34" translate="no">blindDataShader/blindDataMesh.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a6de81856f127bec3ddce0d1e73c7b201"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setDoubleBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setDoubleBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for double blind data on an array of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a66000a2c0860bb907ca301463acbc5db"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setDoubleBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setDoubleBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_double_array.html" translate="no">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a values for a double blind data on an array of components. </p>
<p>The arrays of values and components must be the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The attribute values for each component</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4587300ddf64bda38a5f7146285be5dc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setBoolBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setBoolBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for a boolean blind data attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a74badb566f5d7670d9fbf568ce979f7a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setBoolBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setBoolBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for boolean blind data on an array of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ab7dec27ae45e701ad6469411f2c4bd16"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setBoolBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setBoolBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a values for a boolean blind data on an array of components. </p>
<p>The arrays of values and components must be the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The attribute values for each component</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ac88a1c88524c81ee8501994117b63d5d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setStringBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setStringBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for a string blind data attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a7b95148242961bcce9d984e8dad0d37e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setStringBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setStringBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for string blind data on an array of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a0773a54659279feceb61c0a8325980d9"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setStringBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setStringBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a values for a string blind data on an array of components. </p>
<p>The arrays of values and components must be the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The attribute values for each component</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a2ab38f65ca6a1f2d1d8572a856b5ad6c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setBinaryBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setBinaryBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for a binary blind data attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value as an <a class="el" href="./class_m_string.html" title="Manipulate strings. " translate="no">MString</a>. Note that the physical size must be set explicitly for binary data.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a349d6c661c067c39a604d59738e3e3f1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setBinaryBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setBinaryBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for binary blind data on an array of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aad99295aa9378a61406a02b18aab5d11"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setBinaryBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setBinaryBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>compIDs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a values for a binary blind data on an array of components. </p>
<p>The arrays of values and components must be the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compIDs</td><td>The components to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then the elements of <b>compIDs</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The attribute values for each component</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Could not set blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad07c654eb7214ea75891b803c5ee3628"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setBinaryBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setBinaryBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">char * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>length</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set a value for a binary blind data attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to set the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The desired id for the new blind data type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Attribute value as a char string </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of char string to use</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a41bc22c908735cae09a3dab4b8804810"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/clearBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> clearBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete a value for a binary blind data attribute on a particular componenr. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to clear the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The id for the blind data to be cleared </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>Attribute name</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not clear blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a9216a34492c715cbcc879659ff77e1e4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/clearBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> clearBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete the values for the given attribute on the given binary blind data type from all components of the given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The id for the blind data to be cleared </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td>The attribute to clear the blind data for</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not clear blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a2139236dddbcc55d88ec2970531956dd"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/clearBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> clearBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete all blind data from components of the given type, e.g. </p>
<p>all edges from a particular component.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not clear blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aaf3365a6b861eea09cb674278487c763"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/clearBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> clearBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete the values for a binary blind data type (all its attributes) from a particular component. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td>The component to clear the blind data for When <b>compType</b> = <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a> then <b>compID</b> must be obtained by calling MFnMesh::getFaceVertexBlindDataIndex(faceIndex,vertexIndex) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The id for the blind data to be cleared</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not clear blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a421139620f24cf21460c061a4b346e04"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/clearBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> clearBlindData </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete the values for a binary blind data type (all its attributes) from all components of the given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The component type e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The id for the blind data to be cleared</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kInvalidParameter</b> Invalid component id or type, or could not clear blind data. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa4fef6442be0536d2316c00f2251ba29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/componentTypeName"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> componentTypeName </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> &amp; </td>
<td class="paramname"><em>status</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Get a string representing a particular component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td>The type of component to fetch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Status Code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representing the component type, empty string if invalid</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> The component type was not recognized. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a8bcea1244d150d93ab3cf162d5219b74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/componentTypeFromName"></a><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> componentTypeFromName </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>assocName</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Get a component type from its string name. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">assocName</td><td>String representing the component type</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a94dd08feda7b2cf0ff8262312c4fcc09" title="  " translate="no">MFn::kInvalid</a></b> The method failed to match the type. </li>
<li><b><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a18f788d50a75ca81a0dc5a2538f364ae" title="  " translate="no">MFn::kMeshEdgeComponent</a></b> The component type is 'edge'. </li>
<li><b><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a5ddabf9726f89e07cff62014221fe6fb" title="  " translate="no">MFn::kMeshPolygonComponent</a></b> The component type is 'face'. </li>
<li><b><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  " translate="no">MFn::kMeshVertComponent</a></b> The component type is 'vertex'. </li>
<li><b><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ab7f071d2e0868181c4a5822847c4baa6" title="  " translate="no">MFn::kMeshFaceVertComponent</a></b> The component type is 'faceVertex'. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="af876ed6feb4e7a12c1615fd39fba70a2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">void setCheckSamePointTwice </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>check</em> = <code>true</code></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method allows the turning on or off of duplicate point checking when polygons are created or added using this class. </p>
<p>Checking for duplicates, is the default state.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">check</td><td>true for checking, false otherwise </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa9cbec85167bda6017a86e5e566e2d0d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool getCheckSamePointTwice </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Return true if checking for duplicate points is turned on. </p>
<p>Return false otherwise. </p>
</div>
</div>
<a class="anchor" id="a3f723a01bbdf26f5cb58742739de97c4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/createInPlace"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> createInPlace </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>numVertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>numPolygons</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonCounts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>polygonConnects</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Replaces the existing polygonal mesh with a new one specified by array of vertices and polygon connection information. </p>
<p>This function will then operate on the replacement surface.</p>
<p>This method is meant to be as efficient as possible and thus assumes that all the given data is topologically correct.</p>
<p>If the functionset is operating on a mesh node with construction history, this method will fail as the node will continue to get its geometry from its history connection. To use this method you must first break the history connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">numVertices</td><td>number of vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">numPolygons</td><td>number of polygons </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonCounts</td><td>array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polygonConnects</td><td>array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4, 0, 4, 7, 1, 1, 7, 6, 2 }</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> Array length does not match given item count; parentOrOwner was not valid; or there was no model present to add the object to </li>
<li><b>MS::kFailure</b> An object error has occurred or mesh has history. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example59" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example59-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example59-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a29" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a3436ba1b31e988b6eee43573e2909af2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/copyInPlace"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> copyInPlace </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_object.html" translate="no">MObject</a> &amp; </td>
<td class="paramname"><em>source</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method creates copies the given source mesh onto the current surface. </p>
<p>After the copy this function set continues operate on the original mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the mesh to be copied</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> Source object was not one of kMeshGeom, kMeshData, kMesh; or dataMesh or underlying geometry was null </li>
<li><b>MS::kFailure</b> An object error has occurred; or there was no model present to add the object to </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad48b6008bf77ccf6159cd6875a6ce0d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/polyTriangulate"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> polyTriangulate </td>
<td>(</td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>pointsAndHoles</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>pointsCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>outerPointsCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>holesCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>considerNormal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>normals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned short * </td>
<td class="paramname"><em>triangles</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int &amp; </td>
<td class="paramname"><em>trianglesCount</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Triangulates a polygon. </p>
<p>The polygon consists of 2D positions with optional 3D normals and holes. These 2D positions can be in any coordinate system. 3D positions can be projected to a 2D plane by its face normal. 3D normals are references to help triangulation. This function can work without normals but normals can improve the quality. This function works with pointers and is more efficient than the other variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">pointsAndHoles</td><td>Array of 2D positions and hole description. The array contains 2D positions (x,y) followed by the hole offsets. For example, if pointsAndHoles = [x1, y1, x2, y2, ..., x9, y9, o1, o1, o2, o2], then this means that (x1, y1) ~ (x9, y9) are positions, o1 is the offset for the first loop and o2 is the offset for the second loop. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointsCount</td><td>The number of 2D positions in pointsAndHoles </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">outerPointsCount</td><td>The number of outer (non-hole) 2D positions in pointsAndHoles </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">holesCount</td><td>The number of holes in pointsAndHoles </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">considerNormal</td><td>If true then normals are considered during triangulation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normals</td><td>Array of 3D normals. If considerNormal is false, this array can be nullptr. If considerNormal is true, then there must be one normal per point. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">triangles</td><td>Array of triangle indices into pointsAndHoles array. The size of this array is trianglesCount * 3 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">trianglesCount</td><td>The number of triangles written in triangles array</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The triangulation was successful. </li>
<li><b>MS::kFailure</b> The triangulation was failed. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example60" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example60-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example60-content" style="display:none;"><dd><a class="el" href="./gpu_cache_2gpu_cache_util_8h-example.html#a16" translate="no">gpuCache/gpuCacheUtil.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a722ab78f04d7cde092fad106bd94b948"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/polyTriangulate"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> polyTriangulate </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_float_point_array.html" translate="no">MFloatPointArray</a> &amp; </td>
<td class="paramname"><em>points</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>holes</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>outerPointsCount</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_float_vector_array.html" translate="no">MFloatVectorArray</a> &amp; </td>
<td class="paramname"><em>normals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_int_array.html" translate="no">MIntArray</a> &amp; </td>
<td class="paramname"><em>triangles</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Triangulates a polygon. </p>
<p>The polygon consists of positions with optional normals and holes. Normals are references to help triangulation. This function can work without normals but normals can improve the quality. A simple example:</p>
<p><a class="el" href="./class_m_float_point_array.html" title="Array of MFloatPoint data type. " translate="no">MFloatPointArray</a> Points; <a class="el" href="./class_m_int_array.html" title="Array of integers data type. " translate="no">MIntArray</a> Holes; <a class="el" href="./class_m_float_vector_array.html" title="Array of MFloatVectors data type. " translate="no">MFloatVectorArray</a> Normals; <a class="el" href="./class_m_int_array.html" title="Array of integers data type. " translate="no">MIntArray</a> Triangles;</p>
<p>Points.append(<a class="el" href="./class_m_float_point.html" title="Implementation of a point. " translate="no">MFloatPoint</a>(-1, 0, -1)); Points.append(<a class="el" href="./class_m_float_point.html" title="Implementation of a point. " translate="no">MFloatPoint</a>(-1, 0, 1)); Points.append(MFloatPoint(1, 0, 1)); Points.append(<a class="el" href="./class_m_float_point.html" title="Implementation of a point. " translate="no">MFloatPoint</a>(1, 0, -1)); Points.append(<a class="el" href="./class_m_float_point.html" title="Implementation of a point. " translate="no">MFloatPoint</a>(0.5, 0, -0.5)); Points.append(<a class="el" href="./class_m_float_point.html" title="Implementation of a point. " translate="no">MFloatPoint</a>(0.5, 0, 0.5)); Points.append(<a class="el" href="./class_m_float_point.html" title="Implementation of a point. " translate="no">MFloatPoint</a>(-0.5, 0, 0.5)); Points.append(<a class="el" href="./class_m_float_point.html" title="Implementation of a point. " translate="no">MFloatPoint</a>(-0.5, 0, -0.5)); Holes.append(4) // the 1st hole starts at 4th in Points for (unsigned int i = 0; i &lt; 8; i++) Normals.append(MFloatVector(0, 1, 0));</p>
<p>MFnMesh::polyTriangulate(Points, Holes, 4, Normals, Triangles)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Array of 3D points. The poly's outer vertices come first, followed by the vertices for each hole. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">holes</td><td>Array of offsets into the 'points' array indicating where each hole's vertices start. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">outerPointsCount</td><td>The number of outer (non-hole) positions in points array </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normals</td><td>Array of normals. This array can be empty. If this array is not empty, then there must be one normal per point. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">triangles</td><td>Array of triangle indices into points array</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The triangulation was successful. </li>
<li><b>MS::kFailure</b> The triangulation was failed. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aa705f8fc626667e5624fabca8ee77d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/createColorSetWithName"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> createColorSetWithName </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000086" translate="no">Deprecated:</a></b></dt><dd>Use <a class="el" href="./class_m_fn_mesh.html#ac392a4fcb7da0759a4301119a395bcd7" title="Create a new empty color set for this mesh. " translate="no">createColorSetWithName(const MString &amp;, MDGModifier *, const MUintArray *, MStatus *)</a></dd></dl>
<p>Create a new empty color set for this mesh. If the name passed in is empty (zero length), or a color set with the same name already exists, then a new unique name is generated and used as the new color set's name.</p>
<p>In the case where the name is empty, the new name will be of the format "colorSet#" where # is a number that makes the name unique for this mesh.</p>
<p>In the case where a color set already exists with the same name as the name passed in, then the new name will be of the format "userName#", where "userName" was the name specified, and # is a number appended on to "userName" to make the name unique for this mesh.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSetName</td><td>The name of the color set to add. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ReturnStatus</td><td>Status code. See below.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting name of the color set.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="acc1575fc1ca70a9cfea00ad683d36221"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/generateSmoothMesh"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> generateSmoothMesh </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000084" translate="no">Deprecated:</a></b></dt><dd>Use <a class="el" href="./class_m_fn_mesh.html#acb7279765ccba9c472e0845fd91e437e" title="Creates a new polygonal mesh using either the Smooth Mesh Preview attributes of this mesh or a set of..." translate="no">generateSmoothMesh(MObject, MMeshSmoothOptions * , MStatus *)</a> instead.</dd></dl>
<p>Creates a new polygonal mesh using the Smooth Mesh Preview attributes of this mesh. Unlike the <a class="el" href="./class_m_fn_mesh.html#af9b9e5d33d289134d567c62bad4ca3d5" title="Creates a new polygonal mesh given an array of vertices and polygon connection information and sets t..." translate="no">MFnMesh::create</a> functions, this function does not set this function set to operate on the new surface.</p>
<p>The parentOrOwner argument is used to specify the owner of the new surface.</p>
<p>If the parentOrOwner is kMeshData then the created surface will be of type kMeshGeom and will be returned. The parentOrOwner will become the owner of the new mesh.</p>
<p>If parentOrOwner is nullptr then a new transform will be created and returned which will be the parent for the mesh. The new transform will be added to the DAG.</p>
<p>If parentOrOwner is a DAG node then the new mesh will be returned and the parentOrOwner will become its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>parent of the polygon that will be created </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If parentOrOwner is nullptr then the transform for this surface is returned </li>
<li>If parentOrOwner is a DAG object then the new surface shape is returned </li>
<li>The surface geometry is returned if parentOrOwner is of type kMeshData</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kLicenseFailure</b> Application not licensed for attempted operation </li>
<li><b>MS::kInvalidParameter</b> parentOrOwner was not valid; or there was no model present to add the object to </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
<li><b>MS::kInsufficientMemory</b> Insufficient memory to complete this method </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a3b295cc747301e51d3db5e93ea7fcda0"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/currentColorSetName"></a><a class="el" href="./class_m_string.html" translate="no">MString</a> currentColorSetName </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> <b>This method is not available in Python.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000090" translate="no">Deprecated:</a></b></dt><dd>Use MFnMesh::currentColorSetName(int, MStatus*) instead. </dd></dl>
<p>Get the name of the "current" or "working" color set. The "current" color set is the color set which is used for color operations when no color set is explcitly specified.</p>
<p>If there is no current color set, then a empty string will be returned on the string argument passed on.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code. See below.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Name of the "current" color set, if any.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a69651a9c886c553141bd60169326fe4d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/addPolygon"></a><a class="el" href="./class_m_object.html" translate="no">MObject</a> addPolygon </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>vertexArray</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>polyTolerance</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>mergeVertices</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>pointTolerance</em> = <code>kMFnMeshPointTolerance</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>forceGeometry</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html" translate="no">MObject</a> </td>
<td class="paramname"><em>parentOrOwner</em> = <code><a class="el" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63" translate="no">MObject::kNullObj</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> <b>This method is not available in Python.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000085" translate="no">Deprecated:</a></b></dt><dd>Use the other <a class="el" href="./class_m_fn_mesh.html#a5d9b2da1ced87d07152df74788558e07" title="Adds a new polygon to this polygonal mesh. " translate="no">MFnMesh::addPolygon</a> method.</dd></dl>
<p>Adds a new polygon to this polygonal mesh.</p>
<p>If there is no current geometry then a new polygonal mesh is created and parentOrOwner is used to specify the owner of the new surface. If parentOrOwner is nullptr or a DAG parent is specified, then a new transform will be created in the DAG and returned. If the parentOrOwner is kMeshData then the new surface will become its data and the geometry will be returned.</p>
<p>If we are adding to an existing polygonal mesh then parentOrOwner is ignored and the geometry is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">vertexArray</td><td>array of ordered vertices that make up the polygon </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">polyTolerance</td><td>specifies the <em>planar tolerance</em> for the mesh. If all the verticies of a polygon are within this distance of the best fit computed plane between them, the polygon is considered to be planar. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mergeVertices</td><td>If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointTolerance</td><td>specifies how close verticies have to be to before they are <em>merged</em>. This merging is only done if <em>mergeVerticies</em> is true. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">forceGeometry</td><td>if true handle no-manifold topology regardless of non connectivity </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">parentOrOwner</td><td>the DAG parent or kMeshData the new surface will belong to </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transform if one is created, otherwise the geometry.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a46bb7238028e644ff17ecdfc5f372f40"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool intersect </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>raySource</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>rayDirection</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>points</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> <b>This method is not available in Python.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000089" translate="no">Deprecated:</a></b></dt><dd>Use the other <a class="el" href="./class_m_fn_mesh.html#a4a51a250da25c242a4f9280d5a1b2781" title="Determines whether the given ray intersects this polygon and if so, returns the points of intersectio..." translate="no">MFnMesh::intersect</a> method.</dd></dl>
<p>Determines whether the given ray intersects this polygon and if so, returns the points of intersection. The points of intersection will be in order of closest point to the raySource.</p>
<p>This method is not threadsafe when invoked by multiple threads on the same object at the same time. It is threadsafe as long as each thread operates on a different mesh object.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">raySource</td><td>Starting point for the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>Direction of the ray </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>Storage for any points of intersection </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The given ray intersects this polygon </li>
<li><b>false</b> The given ray does not intersect this polygon</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a4408f6f06fc5c2f6a1d1e752461fd6d6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool intersect </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point.html" translate="no">MPoint</a> &amp; </td>
<td class="paramname"><em>raySource</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_vector.html" translate="no">MVector</a> &amp; </td>
<td class="paramname"><em>rayDirection</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html" translate="no">MPointArray</a> &amp; </td>
<td class="paramname"><em>points</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> <b>This method is not available in Python.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000088" translate="no">Deprecated:</a></b></dt><dd>Use the other <a class="el" href="./class_m_fn_mesh.html#a4a51a250da25c242a4f9280d5a1b2781" title="Determines whether the given ray intersects this polygon and if so, returns the points of intersectio..." translate="no">MFnMesh::intersect</a> method.</dd></dl>
<p>Determines whether the given ray intersects this polygon and if so, returns the points of intersection. The points of intersection will be in order of closest point to the raySource.</p>
<p>This method is not threadsafe when invoked by multiple threads on the same object at the same time. It is threadsafe as long as each thread operates on a different mesh object.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">raySource</td><td>Starting point for the ray </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>Direction of the ray </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>Storage for any points of intersection </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> The given ray intersects this polygon </li>
<li><b>false</b> The given ray does not intersect this polygon</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="adb7faf3cbbec47a35785b39b856a943f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBlindDataAttrNames"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBlindDataAttrNames </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>longNames</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string_array.html" translate="no">MStringArray</a> &amp; </td>
<td class="paramname"><em>shortNames</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the blind data attribute names for the specified blind data type id. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td>The blind data id to check for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">longNames</td><td>Space for the attribute long names </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">shortNames</td><td>Space for the attribute short names</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a821fdbfed9826ff767a5a10ac967c2cb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool hasBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> <b>This method is not available in Python.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000091" translate="no">Deprecated:</a></b></dt><dd>Use <a class="el" href="./class_m_fn_mesh.html#a487f967198f594a077152f3999839726" title="Does this component have blind data with the given ID. " translate="no">MFnMesh::hasBlindDataComponentId</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a168464d97542736ee90ced3390fe9e16"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no">bool hasBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> <b>This method is not available in Python.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000092" translate="no">Deprecated:</a></b></dt><dd>Use <a class="el" href="./class_m_fn_mesh.html#a487f967198f594a077152f3999839726" title="Does this component have blind data with the given ID. " translate="no">MFnMesh::hasBlindDataComponentId</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9cd4c10fe30b80798d8e9585bfa44783"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/createUVSet"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> createUVSet </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>uvSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> * </td>
<td class="paramname"><em>instances</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python.</b> </p>
<p>Create a new empty uv set for this mesh. If the name passed in is empty (zero length), or a uv set with the same name already exists, then a new unique name is generated and used as the new uvset's name.</p>
<p>In the case where the name is empty, the new name will be of the format "uvSet#" where # is a number that makes the name unique for this mesh.</p>
<p>In the case where a uvset already exists with the same name as the name passed in, then the new name will be of the format "userName#", where "userName" was the name specified, and # is a number appended on to "userName" to make the name unique for this mesh.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<p><b>Python Notes</b></p>
<p>This method is not supported in Python. Please see <a class="el" href="./class_m_fn_mesh.html#a932b175b29c42758fe67761fca275c61" title="Create a new empty uv set for this mesh. " translate="no">createUVSetWithName()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">uvSetName</td><td>The name of the uv set to add. This name will be overwritten with a different name, if a new name needed to be generated. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instances</td><td>The instance number(s) for which the set should be added, or nullptr if the uv-set should be shared by all instances.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example61" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example61-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example61-content" style="display:none;"><dd><a class="el" href="./_abc_import_2_mesh_helper_8cpp-example.html#a45" translate="no">AbcImport/MeshHelper.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a963207996df5420b2689472d61849326"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/copyUVSet"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> copyUVSet </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>fromName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>toName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python.</b> </p>
<p>Copies a uv set from one to another for this mesh. The source must exist. The following cases can occur:</p>
<p>1) If the destination name is the same as the source than no copy will be made. 2) If the destination name exists a copy will be made to the destination. 3) If the destination name does not exist, then a new uv set will be created with a unique name, and then the copy will be made. The name generated will be "destinationName&gt;#", where "destinationName" is the original name sent in, and "#" is a ascending number appended to the end of the original name.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<p><b>Python Notes</b></p>
<p>This method is not supported in Python. Please see the one which returns a string</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">fromName</td><td>The name of the uv set to change </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">toName</td><td>The name to set the uv set to. May be modified to return the final name used in the case where a new name needs to be generated. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a63d1cbfe5459d728ec2594ccf9baf5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getCurrentUVSetName"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getCurrentUVSetName </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>setName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>instance</em> = <code>kMFnMeshInstanceUnspecified</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python.</b> </p>
<p>Get the name of the "current" uv set. The "current" uv set is the uv set which is used for uv operations when no uv set is explcitly specified.</p>
<p>If there is no current uv set, then a empty string will be returned on the string argument passed on.</p>
<p>On instanced meshes, uv sets may be applied on a per-instance basis or may be shared across all instances. When the uv sets are per-instance, the concept of the current uv set has two levels of granularity. Namely, the current uv set applies to one or more instances, plus there are other uv sets in the same uv set family that apply to different instances. The instance arguement is used to indicate that if this is a per-instance uv set, you are interested in the name of the uv set that applies to the specified instance. When the index is not specified, the current uv set will be returned regardless of which instance it is for.</p>
<p>Note, the instance argument is only applicable on an <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> that is initialized using a mesh shape. It will return failure if used on an <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> that has no associated shape.</p>
<p><b>Python Notes</b></p>
<p>This method is not supported in Python. Please see the one which returns a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">setName</td><td>Name of the "current" uv set, if any. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>Instance of the mesh whose set we are interested in, or kMFnMeshInstanceUnspecified for the set which is shared across all instances.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<dl class="section "><div class="dynheader closed" id="dynsection-example62" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example62-trigger" src="cpp_ref/closed.png"> <b>Examples: </b></img></dt></div><div class="dyncontent" id="dynsection-example62-content" style="display:none;"><dd><a class="el" href="./split_u_v_cmd_2split_u_v_fty_action_8cpp-example.html#a4" translate="no">splitUVCmd/splitUVFtyAction.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a16cc4ceddccecaa8c5872271cdfc6cdb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/createColorSet"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> createColorSet </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em> = <code>NULL</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> * </td>
<td class="paramname"><em>instances</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python.</b> </p>
<p>Create a new empty color set for this mesh. If the name passed in is empty (zero length), or a color set with the same name already exists, then a new unique name is generated and used as the new color set's name.</p>
<p>In the case where the name is empty, the new name will be of the format "colorSet#" where # is a number that makes the name unique for this mesh.</p>
<p>In the case where a color set already exists with the same name as the name passed in, then the new name will be of the format "userName#", where "userName" was the name specified, and # is a number appended on to "userName" to make the name unique for this mesh.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<p><b>Python Notes</b></p>
<p>This method is not supported in Python. Please see <a class="el" href="./class_m_fn_mesh.html#ac392a4fcb7da0759a4301119a395bcd7" title="Create a new empty color set for this mesh. " translate="no">createColorSetWithName()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSetName</td><td>The name of the color set to add. This name will be overwritten with a different name, if a new name needed to be generated. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instances</td><td>The instance number(s) for which the set should be added, or nullptr if the uv-set should be shared by all instances.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a063d856ba751854f745c381891037444"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/createColorSet"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> createColorSet </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>colorSetName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_d_g_modifier.html" translate="no">MDGModifier</a> * </td>
<td class="paramname"><em>modifier</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>clamped</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn_mesh.html#a80dc8673cdbdbb813c71dfa32e0643f2" translate="no">MColorRepresentation</a> </td>
<td class="paramname"><em>rep</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_uint_array.html" translate="no">MUintArray</a> * </td>
<td class="paramname"><em>instances</em> = <code>NULL</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python.</b> </p>
<p>Create a new empty color set of specified channels for this mesh. If the name passed in is empty (zero length), or a color set with the same name already exists, then a new unique name is generated and used as the new color set's name.</p>
<p>In the case where the name is empty, the new name will be of the format "colorSet#" where # is a number that makes the name unique for this mesh.</p>
<p>In the case where a color set already exists with the same name as the name passed in, then the new name will be of the format "userName#", where "userName" was the name specified, and # is a number appended on to "userName" to make the name unique for this mesh.</p>
<p>This operation will only work when the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape.</p>
<p><b>Python Notes</b></p>
<p>This method is not supported in Python. Please see <a class="el" href="./class_m_fn_mesh.html#ac392a4fcb7da0759a4301119a395bcd7" title="Create a new empty color set for this mesh. " translate="no">createColorSetWithName()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">colorSetName</td><td>The name of the color set to add. This name will be overwritten with a different name, if a new name needed to be generated. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">modifier</td><td>Since this method may modify the DG, if you wish to undo its effects, you need to keep track of what needs to be undone. If the modifier is non-null, and this <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> refers to a shape, then it will add the command to be undone to the modifier. Use <a class="el" href="./class_m_d_g_modifier.html#a0789a8d51244cad0495abb2b811c39db" title="Undoes all of the operations that have been given to this modifier. " translate="no">MDGModifier::undoIt</a> to undo the effects of this method. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">clamped</td><td>The color set stores values in 0 to 1 range if true. no range limit if false </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rep</td><td>The color set stores RGB, RGBA, or Alpha </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instances</td><td>The instance number(s) for which the set should be added, or nullptr if the uv-set should be shared by all instances.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aaf39117dff642a4a76ded73ed7c60f46"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getCurrentColorSetName"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getCurrentColorSetName </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>setName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>instance</em> = <code>kMFnMeshInstanceUnspecified</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python.</b> </p>
<p>Get the name of the "current" or "working" color set. The "current" color set is the color set which is used for color operations when no color set is explcitly specified.</p>
<p>If there is no current color set, then a empty string will be returned on the string argument passed on.</p>
<p>On instanced meshes, color sets may be applied on a per-instance basis or may be shared across all instances. When the color sets are per-instance, the concept of the current color set has two levels of granularity. Namely, the current color set applies to one or more instances, plus there are other color sets in the same color set family that apply to different instances. The instance arguement is used to indicate that if this is a per-instance color set, you are interested in the name of the color set that applies to the specified instance. When the index is not specified, the current color set will be returned regardless of which instance it is for.</p>
<p>Note, the instance argument is only applicable on an <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> that is initialized using a mesh shape. It will return failure if used on an <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> that has no associated shape.</p>
<p><b>Python Notes</b></p>
<p>This method is not supported in Python. Please see <a class="el" href="./class_m_fn_mesh.html#a05a2db74b6cfc632c605cbac1363eb99" title='Get the name of the "current" or "working" color set. ' translate="no">currentColorSetName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">setName</td><td>Name of the "current" color set, if any. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>Instance of the mesh whose color set we are interested in, or kMFnMeshInstanceUnspecified for the color set which is shared across all instances.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a29014da3ce4d288534c1eba3bde78664"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getStringBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getStringBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> <b>This method is not available in Python.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000093" translate="no">Deprecated:</a></b></dt><dd>Use <a class="el" href="./class_m_fn_mesh.html#abc88d2109836b63f72ddfd7fe7aaeb86" title="Get the blind data value for the specified blind data attribute of the specified component. " translate="no">MFnMesh::stringBlindDataComponentId</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="acb8efa2513ca72e9f115ba0b46e72982"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/getBinaryBlindData"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> getBinaryBlindData </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>compID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7" translate="no">MFn::Type</a> </td>
<td class="paramname"><em>compType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>blindDataId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> </td>
<td class="paramname"><em>attrName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is obsolete.</b> <b>This method is not available in Python.</b> </p>
<dl class="deprecated"><dt><b><a class="el" href="./deprecated.html#_deprecated000094" translate="no">Deprecated:</a></b></dt><dd>Use <a class="el" href="./class_m_fn_mesh.html#af2a541f1ff4a7416acc6fe477594524d" title="Get the blind data value for the specified blind data attribute of the specified component. " translate="no">MFnMesh::binaryBlindDataComponentId</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">compID</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">compType</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blindDataId</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">attrName</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">data</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aeaf96cd731c1b624e3829abed4bad786"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/metadata"></a>const <a class="el" href="./classadsk_1_1_data_1_1_associations.html" translate="no">adsk::Data::Associations</a> * metadata </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_status.html" translate="no">MStatus</a> * </td>
<td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python. </b></p>
<p>Get the current metadata associated with this mesh.</p>
<p>When the <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> is a mesh node then the metadata returned will be that associated with the output mesh attribute. When it is simple mesh data then the metadata returned is that belonging directly to that mesh data.</p>
<p>Metadata is shared and reference counted so the sequence of events for editing metadata inside a node with an input mesh and output mesh is: <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> inMesh = theInputMesh(); <a class="el" href="./class_m_fn_mesh.html" title="Polygonal surface function set. " translate="no">MFnMesh</a> outMesh = theOutputMesh(); const <a class="el" href="./classadsk_1_1_data_1_1_associations.html" title="Class handling associations between internal and external data. " translate="no">adsk::Data::Associations</a> newMetadata( inMesh.metadata() ); doMetadataEditing( newMetadata ); outMesh.setMetadata( &amp;newMetadata ); The "doMetadataEditing" call will take care of copying anything you are changing so that there is a minimum amount of duplication. After this sequence the inMesh and outMesh will contain different metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code. See below.</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Metadata associated with the mesh, nullptr if there isn't any</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> An object error has occurred. </li>
</ul>
</dd></dl>
<p>Reimplemented from <a class="el" href="./class_m_fn_dependency_node.html#aeaf96cd731c1b624e3829abed4bad786" translate="no">MFnDependencyNode</a>.</p>
</div>
</div>
<a class="anchor" id="a67c91ff141e6ab94c0bc7d75da94719d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/setMetadata"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> setMetadata </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./classadsk_1_1_data_1_1_associations.html" translate="no">adsk::Data::Associations</a> &amp; </td>
<td class="paramname"><em>newMetadata</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python. </b></p>
<p>Replace the existing metadata with the given values.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">newMetadata</td><td>The new associated metadata for this mesh</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> The metadata could not be set onto this node. </li>
</ul>
</dd></dl>
<p>Reimplemented from <a class="el" href="./class_m_fn_dependency_node.html#a67c91ff141e6ab94c0bc7d75da94719d" translate="no">MFnDependencyNode</a>.</p>
</div>
</div>
<a class="anchor" id="a9a27d24e2641c379dad274e938cd33d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname" translate="no"><a class="dashAnchor" name="//apple_ref/cpp/Function/validateMetadata"></a><a class="el" href="./class_m_status.html" translate="no">MStatus</a> validateMetadata </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_string.html" translate="no">MString</a> &amp; </td>
<td class="paramname"><em>errors</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p><b>This method is not available in Python. </b></p>
<p>Verify consistency in all of the existing metadata channels The intended use of this method is to check that the metadata channels are still internally consistent after operations have been performed on the underlying mesh (right number of vertexes, edges, faces, logical connectivity, sensible index values).</p>
<p>It's not meant to provide data validation (e.g. make sure a certain data in a channel is within it's legal range).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">errors</td><td>String containing information about what went wrong</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The method was successful. </li>
<li><b>MS::kFailure</b> A consistency error was found. Check error string for details. </li>
</ul>
</dd></dl>
<p>Reimplemented from <a class="el" href="./class_m_fn_dependency_node.html#a9a27d24e2641c379dad274e938cd33d2" translate="no">MFnDependencyNode</a>.</p>
</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MFnMesh.h</li>
<li>MFnMesh.cpp</li>
</ul>
</hr></div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</link></link></link></link></div></body>
</html>
